const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":122,\"nextId\":122,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"2#前言\",\"4\":\"2#并发\",\"5\":\"2#在计算机中的并发\",\"6\":\"2#并发与并行\",\"7\":\"2#总结\",\"8\":\"3\",\"9\":\"3#hello-world\",\"10\":\"3#当前环境支持并发线程数\",\"11\":\"3#线程管理\",\"12\":\"3#启动新线程\",\"13\":\"3#raii\",\"14\":\"3#传递参数\",\"15\":\"3#std-this-thread\",\"16\":\"3#std-thread-转移所有权\",\"17\":\"3#std-thread-的构造-源码解析\",\"18\":\"3#实现-joining-thread\",\"19\":\"3#c-20-std-jthread\",\"20\":\"3#零开销原则\",\"21\":\"3#线程停止\",\"22\":\"3#总结\",\"23\":\"3#总结-1\",\"24\":\"4\",\"25\":\"4#条件竞争\",\"26\":\"4#使用互斥量\",\"27\":\"4#std-lock-guard\",\"28\":\"4#try-lock\",\"29\":\"4#保护共享数据\",\"30\":\"4#死锁-问题与解决\",\"31\":\"4#std-unique-lock-灵活的锁\",\"32\":\"4#在不同作用域传递互斥量\",\"33\":\"4#保护共享数据的初始化过程\",\"34\":\"4#保护不常更新的数据结构\",\"35\":\"4#std-recursive-mutex\",\"36\":\"4#new、delete-是线程安全的吗\",\"37\":\"4#线程存储期\",\"38\":\"4#注意事项\",\"39\":\"4#cpu-变量\",\"40\":\"4#局部、全局、线程、cpu-变量的对比与使用\",\"41\":\"4#局部变量-不考虑静态局部\",\"42\":\"4#全局变量\",\"43\":\"4#线程变量\",\"44\":\"4#cpu变量\",\"45\":\"4#总结\",\"46\":\"5\",\"47\":\"5#等待事件或条件\",\"48\":\"5#线程安全的队列\",\"49\":\"5#使用条件变量实现后台提示音播放\",\"50\":\"5#注意\",\"51\":\"5#使用-future\",\"52\":\"5#创建异步任务获取返回值\",\"53\":\"5#future-与-std-packaged-task\",\"54\":\"5#使用-std-promise\",\"55\":\"5#future-的状态变化\",\"56\":\"5#多个线程的等待-std-shared-future\",\"57\":\"5#限时等待\",\"58\":\"5#时钟\",\"59\":\"5#时间段\",\"60\":\"5#时间点\",\"61\":\"5#异步任务执行\",\"62\":\"5#背景介绍\",\"63\":\"5#项目说明\",\"64\":\"5#完整代码实现\",\"65\":\"5#注意事项\",\"66\":\"5#跨平台兼容性\",\"67\":\"5#实践建议\",\"68\":\"5#c-20-信号量\",\"69\":\"5#c-20-闩与屏障\",\"70\":\"5#std-latch\",\"71\":\"5#std-barrier\",\"72\":\"5#总结\",\"73\":\"6\",\"74\":\"6#原子操作\",\"75\":\"6#原子类型-std-atomic\",\"76\":\"6#std-atomic-flag\",\"77\":\"6#std-atomic-bool\",\"78\":\"6#std-atomic-t\",\"79\":\"6#std-atomic-std-shared-ptr\",\"80\":\"6#内存次序\",\"81\":\"6#前言\",\"82\":\"6#可见\",\"83\":\"6#std-memory-order\",\"84\":\"6#其它概念\",\"85\":\"6#x86-和-arm-的内存模型-强一致性与弱一致性\",\"86\":\"6#宽松定序\",\"87\":\"6#释放-获取定序\",\"88\":\"6#释放-消费定序\",\"89\":\"6#序列一致定序\",\"90\":\"6#与-volatile-的关系\",\"91\":\"7\",\"92\":\"7#前言\",\"93\":\"8\",\"94\":\"8#学习注意事项\",\"95\":\"8#代码风格\",\"96\":\"8#总结\",\"97\":\"9\",\"98\":\"9#std-thread-的数据成员\",\"99\":\"9#std-thread-的构造函数\",\"100\":\"9#总结\",\"101\":\"10\",\"102\":\"10#std-scoped-lock-的数据成员\",\"103\":\"10#std-scoped-lock的构造与析构\",\"104\":\"10#总结\",\"105\":\"11\",\"106\":\"11#前言\",\"107\":\"11#std-async\",\"108\":\"11#std-future\",\"109\":\"11#get-value-方法详细解释\",\"110\":\"11#总结\",\"111\":\"12\",\"112\":\"12#前言\",\"113\":\"12#市面上常见的线程池\",\"114\":\"12#boost-asio-thread-pool\",\"115\":\"12#qthreadpool\",\"116\":\"12#实现线程池\",\"117\":\"12#总结\",\"118\":\"13\",\"119\":\"14\",\"120\":\"15\",\"121\":\"16\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,66],\"1\":[1,27],\"2\":[1],\"3\":[1,15],\"4\":[1,7],\"5\":[1,39],\"6\":[1,23],\"7\":[1,11],\"8\":[1,12],\"9\":[2,68],\"10\":[1,228],\"11\":[1,15],\"12\":[1,298],\"13\":[1,104],\"14\":[1,226],\"15\":[1,114],\"16\":[1,109],\"17\":[1,27],\"18\":[1,96],\"19\":[1,15],\"20\":[1,52],\"21\":[1,163],\"22\":[1,19],\"23\":[1,46],\"24\":[1,17],\"25\":[1,109],\"26\":[1,85],\"27\":[1,212],\"28\":[1,57],\"29\":[1,63],\"30\":[2,208],\"31\":[1,183],\"32\":[1,98],\"33\":[1,162],\"34\":[1,84],\"35\":[1,83],\"36\":[2,97],\"37\":[1,120],\"38\":[1,61],\"39\":[2,41],\"40\":[1,7],\"41\":[3,8],\"42\":[1,8],\"43\":[1,23],\"44\":[1,29],\"45\":[1,86],\"46\":[1,27],\"47\":[1,201],\"48\":[1,133],\"49\":[1,161],\"50\":[1,113],\"51\":[1,53],\"52\":[1,260],\"53\":[1,196],\"54\":[1,134],\"55\":[2,101],\"56\":[1,137],\"57\":[1,75],\"58\":[1,122],\"59\":[1,190],\"60\":[1,158],\"61\":[1,15],\"62\":[1,65],\"63\":[1,26],\"64\":[1,123],\"65\":[1,15],\"66\":[1,25],\"67\":[1,15],\"68\":[2,174],\"69\":[2,28],\"70\":[1,110],\"71\":[1,290],\"72\":[1,88],\"73\":[1,11],\"74\":[1,54],\"75\":[1,325],\"76\":[1,214],\"77\":[1,152],\"78\":[1,64],\"79\":[1,241],\"80\":[1],\"81\":[1,102],\"82\":[1,93],\"83\":[1,37],\"84\":[1],\"85\":[3,71],\"86\":[1],\"87\":[2],\"88\":[2],\"89\":[1],\"90\":[2,29],\"91\":[1],\"92\":[1,54],\"93\":[1,29],\"94\":[1,58],\"95\":[1,41],\"96\":[1,9],\"97\":[4,32],\"98\":[1,44],\"99\":[1,306],\"100\":[1,147],\"101\":[4,32],\"102\":[1,91],\"103\":[1,159],\"104\":[1,19],\"105\":[5],\"106\":[1,47],\"107\":[1,468],\"108\":[1,304],\"109\":[1,139],\"110\":[1,42],\"111\":[1],\"112\":[1,63],\"113\":[1,9],\"114\":[1,151],\"115\":[1,139],\"116\":[1,264],\"117\":[1,18],\"118\":[1,6],\"119\":[1,5],\"120\":[1,3],\"121\":[1]},\"averageFieldLength\":[1.1967213114754105,96.18715858202417],\"storedFields\":{\"0\":{\"h\":\"现代C++并发编程教程\",\"t\":[\"本仓库用来存放 B 站课程《现代 C++ 并发编程教程》的教案、代码。\",\"不管是否购买课程，任何组织和个人遵守 CC BY-NC-ND 4.0 协议均可随意使用学习。\",\"捐赠、issues、pr 均会在致谢列表中铭记您的贡献。\",\" 国内的 C++ 并发编程的教程并不稀少，不管是书籍、博客、视频。然而大多数是粗糙的、不够准确、复杂的。而我们想以更加现代、简单、准确的方式进行教学。\",\" 我们在教学中可能常常为您展示部分标准库源码，自己手动实现一些库，这是必须的，希望您是已经较为熟练使用模板（如果没有，可以先学习 现代C++模板教程）。阅读源码可以帮助我们更轻松的理解标准库设施的使用与原理。\",\" 本教程假设开发者的最低水平为：C++11 + STL + template。\",\" 虽强调现代，但不用担心，我们几乎是从头教学，即使你从来没使用过 C++ 进行多线程编程，也不成问题。\",\" 我们希望您的编译器版本和标准尽可能的高，我们的代码均会测试三大编译器 gcc、clang、msvc。需要更高的标准会进行强调。\",\"猫猫虫\",\"如果你觉得本仓库对你有所帮助，可以通过支付宝赞助白老师，激励白老师有更多的精力和信心维护本仓库。\",\"提示\",\"每一位开发者赞助 30，白老师一天的食品安全就有了着落。\"]},\"1\":{\"h\":\"此处存放作业\",\"t\":[\"文件名：id + 日期数字。\",\"id ：随意。\",\"日期数字：8 位数字，例如现在是 2024 年 7 月 31 日，那么日期数字则为：20240731\",\"后缀名：根据作业情况，随意。如果是普通代码，自然是 .cpp 后缀。\",\"线程池作业存放在 thread_pool 文件夹中。\"]},\"2\":{\"h\":\"基本概念\"},\"3\":{\"h\":\"前言\",\"t\":[\" 在我们谈起“并发编程”，其实可以直接简单理解为“多线程编程”，我知道你或许有疑问：“那多进程呢？” C++ 语言层面没有进程的概念，并发支持库也不涉及多进程，所以在本教程中，不用在意。\",\" 我们主要使用标准 C++ 进行教学，也会稍微涉及一些其它库。\"]},\"4\":{\"h\":\"并发\",\"t\":[\"并发，指两个或两个以上的独立活动同时发生。\",\"并发在生活中随处可见，我们可以一边走路一边说话，也可以两只手同时做不同的动作，又或者一边看电视一边吃零食。\"]},\"5\":{\"h\":\"在计算机中的并发\",\"t\":[\"计算机中的并发有两种方式：\",\"多核机器的真正并行。\",\"单核机器的任务切换。\",\" 在早期，一些单核机器，它要想并发，执行多个任务，那就只能是任务切换，任务切换会给你一种“好像这些任务都在同时执行”的假象。只有硬件上是多核的，才能进行真正的并行，也就是真正的”同时执行任务“。\",\" 在现在，我们日常使用的机器，基本上是二者都有。我们现在的 CPU 基本都是多核，而操作系统调度基本也一样有任务切换，因为要执行的任务非常之多，CPU 是很快的，但是核心却没有那么多，不可能每一个任务都单独给一个核心。大家可以打开自己电脑的任务管理器看一眼，进程至少上百个，线程更是上千。这基本不可能每一个任务分配一个核心，都并行，而且也没必要。正是任务切换使得这些后台任务可以运行，这样系统使用者就可以同时运行文字处理器、编译器、编辑器和 Web 浏览器。\"]},\"6\":{\"h\":\"并发与并行\",\"t\":[\"事实上，对于这两个术语，并没有非常公认的说法。\",\"有些人认为二者毫无关系，指代的东西完全不同。\",\"有些人认为二者大多数时候是相同的，只是用于描述一些东西的时候关注点不同。\",\"我喜欢第二种，那我们就讲第二种。\",\"对多线程来说，这两个概念大部分是重叠的。对于很多人来说，它们没有什么区别。 这两个词是用来描述硬件同时执行多个任务的方式：\",\"“并行”更加注重性能。使用硬件提高数据处理速度时，会讨论程序的并行性。\",\"当关注重点在于任务分离或任务响应时，会讨论程序的并发性。\",\"这两个术语存在的目的，就是为了区别多线程中不同的关注点。\"]},\"7\":{\"h\":\"总结\",\"t\":[\" 概念从来不是我们的重点，尤其是某些说法准确性也一般，假设开发者对操作系统等知识有基本了解。\",\" 我们也不打算特别介绍什么 C++ 并发库的历史发展、什么时候你该使用多线程、什么时候不该使用多线程... 类似问题应该是看你自己的，而我们回到代码上即可。\"]},\"8\":{\"h\":\"使用线程\",\"t\":[\"在标准 C++ 中，std::thread 可以指代线程，本章中，使用线程也就是代表使用 std::thread （C++20 std::jthread）。\",\"本章围绕着它们来讲解。\"]},\"9\":{\"h\":\"Hello World\",\"t\":[\"在我们初学 C++ 的时候应该都写过这样一段代码：\",\"#include <iostream> int main(){ std::cout << \\\"Hello World!\\\" << std::endl; }\",\"这段代码将\\\"Hello World!\\\"写入到标准输出流，换行并刷新。\",\"我们可以启动一个线程来做这件事情：\",\"#include <iostream> #include <thread> // 引入线程支持头文件 void hello(){ // 定义一个函数用作打印任务 std::cout << \\\"Hello World\\\" << std::endl; } int main(){ std::thread t{ hello }; t.join(); }\",\"std::thread t{ hello }; 创建了一个线程对象 t，将 hello 作为它的可调用(Callable)对象，在新线程中执行。线程对象关联了一个线程资源，我们无需手动控制，在线程对象构造成功，就自动在新线程开始执行函数 hello。\",\"t.join(); 等待线程对象 t 关联的线程执行完毕，否则将一直阻塞。这里的调用是必须的，否则 std::thread 的析构函数将调用 std::terminate() 无法正确析构。\",\"这是因为我们创建线程对象 t 的时候就关联了一个活跃的线程，调用 join() 就是确保线程对象关联的线程已经执行完毕，然后会修改对象的状态，让 std::thread::joinable() 返回 false，表示线程对象目前没有关联活跃线程。std::thread 的析构函数，正是通过 joinable() 判断线程对象目前是否有关联活跃线程，如果为 true，那么就当做有关联活跃线程，会调用 std::terminate()。\",\"如你所见，std::thread 高度封装，其成员函数也很少，我们可以轻易的创建线程执行任务，不过，它的用法也还远不止如此，我们慢慢介绍。\"]},\"10\":{\"h\":\"当前环境支持并发线程数\",\"t\":[\"使用 hardware_concurrency 函数可以获得我们当前硬件支持的并发线程数量，它是 std::thread 的静态成员函数。\",\"#include <iostream> #include <thread> int main(){ unsigned int n = std::thread::hardware_concurrency(); std::cout << \\\"支持 \\\" << n << \\\" 个并发线程。\\\\n\\\"; }\",\"本节其实是要普及一下计算机常识，一些古老的书籍比如 csapp 应该也会提到“超线程技术”。\",\"英特尔® 超线程技术是一项硬件创新，允许在每个内核上运行多个线程。更多的线程意味着可以并行完成更多的工作。\",\"AMD 超线程技术被称为 SMT（Simultaneous Multi-Threading），它与英特尔的技术实现有所不同，不过使用类似。\",\"举个例子：一款 4 核心 8 线程的 CPU，这里的 8 线程其实是指所谓的逻辑处理器，也意味着这颗 CPU 最多可并行执行 8 个任务。\",\"我们的 hardware_concurrency() 获取的值自然也会是 8。\",\"当然了，都 2024 年了，我们还得考虑一个问题：“ 英特尔从 12 代酷睿开始，为其处理器引入了全新的“大小核”混合设计架构”。\",\"比如我的 CPU i7 13700H 它是 14 核心，20 线程，有 8 个能效核，6 个性能核。不过我们说了，物理核心这个通常不看重，hardware_concurrency() 输出的值会为 20。\",\"在进行多线程编程时，我们可以参考此值来确定创建的线程数量，以更好地利用当前硬件，从而提升程序性能。\",\"我们可以举个简单的例子运用这个值：\",\"template<typename ForwardIt> auto sum(ForwardIt first, ForwardIt last){ using value_type = std::iter_value_t<ForwardIt>; std::size_t num_threads = std::thread::hardware_concurrency(); std::ptrdiff_t distance = std::distance(first, last); if(distance > 1024000){ // 计算每个线程处理的元素数量 std::size_t chunk_size = distance / num_threads; std::size_t remainder = distance % num_threads; // 存储每个线程的结果 std::vector<value_type> results(num_threads); // 存储关联线程的线程对象 std::vector<std::thread> threads; // 创建并启动线程 auto start = first; for (std::size_t i = 0; i < num_threads; ++i) { auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0)); threads.emplace_back([start, end, &results, i] { results[i] = std::accumulate(start, end, value_type{}); }); start = end; // 开始迭代器不断向前 } // 等待所有线程执行完毕 for (auto& thread : threads) thread.join(); // 汇总线程的计算结果 value_type total_sum = std::accumulate(results.begin(), results.end(), value_type{}); return total_sum; } value_type total_sum = std::accumulate(first, last, value_type{}); return total_sum; }\",\"运行测试。\",\"我们写了这样一个求和函数 sum，接受两个迭代器计算它们范围中对象的和。\",\"我们先获取了迭代器所指向的值的类型，定义了一个别名 value_type，我们这里使用到的 std::iter_value_t 是 C++20 引入的，返回类型推导是 C++14 引入。如果希望代码可以在 C++11 的环境运行也可以自行修改为：\",\"template<typename ForwardIt> typename std::iterator_traits<ForwardIt>::value_type sum(ForwardIt first, ForwardIt last);\",\"运行测试。\",\"num_threads 是当前硬件支持的并发线程的值。std::distance 用来计算 first 到 last 的距离，也就是我们要进行求和的元素个数了。\",\"我们这里的设计比较简单，毕竟是初学，所以只对元素个数大于 1024000 的进行多线程求和，而小于这个值的则直接使用标准库函数 std::accumulate 求和即可。\",\"多线程求和只需要介绍三个地方\",\"chunk_size 是每个线程分配的任务，但是这是可能有余数的，比如 10 个任务分配三个线程，必然余 1。但是我们也需要执行这个任务，所以还定义了一个对象 remainder ，它存储的就是余数。\",\"auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0)); 这行代码是获取当前线程的执行范围，其实也就是要 chunk_size 再加上我们的余数 remainder 。这里写了一个三目运算符是为了进行分配任务，比如：\",\"假设有 3 个线程执行，并且余数是 2。那么，每个线程的处理情况如下：\",\"当 i = 0 时，由于 0 < 2，所以这个线程会多分配一个元素。\",\"当 i = 1 时，同样因为 1 < 2，这个线程也会多分配一个元素。\",\"当 i = 2 时，由于 2 >= 2，所以这个线程只处理平均数量的元素。\",\"这确保了剩余的 2 个元素被分配给了前两个线程，而第三个线程只处理了平均数量的元素。这样就确保了所有的元素都被正确地分配给了各个线程进行处理。\",\"auto start = first; 在创建线程执行之前先定义了一个开始迭代器。在传递给线程执行的lambda表达式中，最后一行是：start = end; 这是为了让迭代器一直向前。\",\"由于求和不涉及数据竞争之类的问题，所以我们甚至可以在刚讲完 Hello World 就手搓了一个“并行求和”的简单的模板函数。主要的难度其实在于对 C++ 的熟悉程度，而非对线程类 std::thread 的使用了，这里反而是最简单的，无非是用容器存储线程对象管理，最后进行 join() 罢了。\",\"本节代码只是为了学习，而且只是百万数据通常没必要多线程，上亿的话差不多。如果你需要多线程求和，可以使用 C++17 引入的求和算法 std::reduce 并指明执行策略。它的效率接近我们实现的 sum 的两倍，当前环境核心越多数据越多，和单线程效率差距越明显。\"]},\"11\":{\"h\":\"线程管理\",\"t\":[\"在 C++ 标准库中，没有直接管理线程的机制，只能通过对象关联线程后，通过该对象来管理线程。类 std::thread 的对象就是指代线程的对象，而我们本节说的“线程管理”，其实也就是指管理 std::thread 对象。\"]},\"12\":{\"h\":\"启动新线程\",\"t\":[\"使用 C++ 线程库启动线程，就是构造 std::thread 对象。\",\"当然了，如果是默认构造之类的，那么 std::thread 线程对象没有关联线程的，自然也不会启动线程执行任务。\",\"std::thread t; // 构造不表示线程的新 std::thread 对象\",\"我们上一节的示例是传递了一个函数给 std::thread 对象，函数会在新线程中执行。std::thread 支持的形式还有很多，只要是可调用(Callable)对象即可，比如重载了 operator() 的类对象（也可以直接叫函数对象）。\",\"class Task{ public: void operator()()const { std::cout << \\\"operator()()const\\\\n\\\"; } };\",\"我们显然没办法直接像函数使用函数名一样，使用“类名”，函数名可以隐式转换到指向它的函数指针，而类名可不会直接变成对象，我们想使用 Task 自然就得构造对象了\",\"std::thread t{ Task{} }; t.join();\",\"直接创建临时对象即可，可以简化代码并避免引入不必要的局部对象。\",\"不过有件事情需要注意，当我们使用函数对象用于构造 std::thread 的时候，如果你传入的是一个临时对象，且使用的都是 “()”小括号初始化，那么编译器会将此语法解析为函数声明。\",\"std::thread t( Task() ); // 函数声明\",\"这被编译器解析为函数声明，是一个返回类型为 std::thread，函数名为 t，接受一个返回 Task 的空参的函数指针类型，也就是 Task(*)()。\",\"之所以我们看着抽象是因为这里的形参是无名的，且写了个函数类型。\",\"我们用一个简单的示例为你展示：\",\"void h(int(int)); //#1 声明 void h(int (*p)(int)){} //#2 定义\",\"即使我还没有为你讲述概念，我相信你也发现了，#1 和 #2 的区别无非是，#1 省略了形参的名称，还有它的形参是函数类型而不是函数指针类型，没有 *。\",\"在确定每个形参的类型后，类型是 “T 的数组”或某个函数类型 T 的形参会调整为具有类型“指向 T 的指针”。文档。\",\"显然，int(int) 是一个函数类型，它被调整为了一个指向这个函数类型的指针类型。\",\"那么回到我们最初的：\",\"std::thread t( Task() ); // #1 函数声明 std::thread t( Task (*p)() ){ return {}; } // #2 函数定义\",\"#2我们写出了函数形参名称 p，再将函数类型写成函数指针类型，事实上完全等价。我相信，这样，也就足够了。\",\"所以总而言之，建议使用 {} 进行初始化，这是好习惯，大多数时候它是合适的。\",\"C++11 引入的 Lambda 表达式，同样可以作为构造 std::thread 的参数，因为 Lambda 本身就是生成了一个函数对象，它自身就是类类型。\",\"#include <iostream> #include <thread> int main(){ std::thread thread{ [] {std::cout << \\\"Hello World!\\\\n\\\"; } }; thread.join(); }\",\"启动线程后（也就是构造 std::thread 对象）我们必须在线程对象的生存期结束之前，即 std::thread::~thread 调用之前，决定它的执行策略，是 join()（合并）还是 detach()（分离）。\",\"我们先前使用的就是 join()，我们聊一下 detach()，当 std::thread 线程对象调用了 detach()，那么就是线程对象放弃了对线程资源的所有权，不再管理此线程，允许此线程独立的运行，在线程退出时释放所有分配的资源。\",\"放弃了对线程资源的所有权，也就是线程对象没有关联活跃线程了，此时 joinable 为 false。\",\"在单线程的代码中，对象销毁之后再去访问，会产生未定义行为，多线程增加了这个问题发生的几率。\",\"比如函数结束，那么函数局部对象的生存期都已经结束了，都被销毁了，此时线程函数还持有函数局部对象的指针或引用。\",\"#include <iostream> #include <thread> struct func { int& m_i; func(int& i) :m_i{ i } {} void operator()(int n)const { for (int i = 0; i <= n; ++i) { m_i += i; // 可能悬空引用 } } }; int main(){ int n = 0; std::thread my_thread{ func{n},100 }; my_thread.detach(); // 分离，不等待线程结束 } // 分离的线程可能还在运行\",\"主线程（main）创建局部对象 n、创建线程对象 my_thread 启动线程，执行任务 func{n}，局部对象 n 的引用被子线程持有。传入 100 用于调用 func 的 operator(int)。\",\"my_thread.detach();，joinable() 为 false。线程分离，线程对象不再持有线程资源，线程独立的运行。\",\"主线程不等待，此时分离的子线程可能没有执行完毕，但是主线程（main）已经结束，局部对象 n 生存期结束，被销毁，而此时子线程还持有它的引用，访问悬空引用，造成未定义行为。my_thread 已经没有关联线程资源，正常析构，没有问题。\",\"解决方法很简单，将 detach() 替换为 join()。\",\"通常非常不推荐使用 detach()，因为程序员必须确保所有创建的线程正常退出，释放所有获取的资源并执行其它必要的清理操作。这意味着通过调用 detach() 放弃线程的所有权不是一种选择，因此 join 应该在所有场景中使用。 一些老式特殊情况不聊。\",\"另外提示一下，也不要想着 detach() 之后，再次调用 join()\",\"my_thread.detach(); // todo.. my_thread.join(); // 函数结束\",\"认为这样可以确保被分离的线程在这里阻塞执行完？\",\"我们前面聊的很清楚了，detach() 是线程分离，线程对象放弃了线程资源的所有权，此时我们的 my_thread 它现在根本没有关联任何线程。调用 join() 是：“阻塞当前线程直至 *this 所标识的线程结束其执行”，我们的线程对象都没有线程，阻塞什么？执行什么呢？\",\"简单点说，必须是 std::thread 的 joinable() 为 true 即线程对象有活跃线程，才能调用 join() 和 detach()。\",\"顺带的，我们还得处理线程运行后的异常问题，举个例子：你在一个函数中构造了一个 std::thread 对象，线程开始执行，函数继续执行下面别的代码，但是如果抛出了异常呢？下面我的 join() 就会被跳过。\",\"std::thread my_thread{func{n},10}; //todo.. 抛出异常的代码 my_thread.join();\",\"避免程序被抛出的异常所终止，在异常处理过程中调用 join()，从而避免线程对象析构产生问题。\",\"struct func; // 复用之前 void f(){ int n = 0; std::thread t{ func{n},10 }; try{ // todo.. 一些当前线程可能抛出异常的代码 f2(); } catch (...){ t.join(); // 1 throw; } t.join(); // 2 }\",\"我知道你可能有很多疑问，我们既然 catch 接住了异常，为什么还要 throw？以及为什么我们要两个 join()？\",\"这两个问题其实也算一个问题，如果代码里抛出了异常，就会跳转到 catch 的代码中，执行 join() 确保线程正常执行完成，线程对象可以正常析构。然而此时我们必须再次 throw 抛出异常，因为你要是不抛出，那么你不是还得执行一个 t.join()？显然逻辑不对，自然抛出。\",\"至于这个函数产生的异常，由调用方进行处理，我们只是确保函数 f 中创建的线程正常执行完成，其局部对象正常析构释放。测试代码。\",\"我知道你可能会想到：“我在 try 块中最后一行写一个 t.join() ，这样如果前面的代码没有抛出异常，就能正常的调用 join()，如果抛出了异常，那就调用 catch 中的 t.join() 根本不需要最外部 2 那里的 join()，也不需要再次 throw 抛出异常”\",\"void f(){ int n = 0; std::thread t{ func{n},10 }; try{ // todo.. 一些当前线程可能抛出异常的代码 f2(); t.join(); // try 最后一行调用 join() } catch (...){ t.join(); // 如果抛出异常，就在 这里调用 join() } }\",\"你是否觉得这样也可以？也没问题？简单的测试运行的确没问题。\",\"但是这是不对的，你要注意我们的注释：“一些当前线程可能抛出异常的代码”，而不是 f2()，我们的 trycatch 只是为了让线程对象关联的线程得以正确执行完毕，以及线程对象正确析构。并没有处理什么其他的东西，不掩盖错误，try 块中的代码抛出了异常， catch 接住了，我们理所应当再次抛出。\"]},\"13\":{\"h\":\"RAII\",\"t\":[\"“资源获取即初始化”(RAII，Resource Acquisition Is Initialization)。\",\"简单的说是：构造函数申请资源，析构函数释放资源，让对象的生命周期和资源绑定。当异常抛出时，C++ 会自动调用对象的析构函数。\",\"我们可以提供一个类，在析构函数中使用 join() 确保线程执行完成，线程对象正常析构。\",\"class thread_guard{ std::thread& m_t; public: explicit thread_guard(std::thread& t) :m_t{ t } {} ~thread_guard(){ std::puts(\\\"析构\\\"); // 打印日志 不用在乎 if (m_t.joinable()) { // 线程对象当前关联了活跃线程 m_t.join(); } } thread_guard(const thread_guard&) = delete; thread_guard& operator=(const thread_guard&) = delete; }; void f(){ int n = 0; std::thread t{ func{n},10 }; thread_guard g(t); f2(); // 可能抛出异常 }\",\"函数 f 执行完毕，局部对象就要逆序销毁了。因此，thread_guard 对象 g 是第一个被销毁的，调用析构函数。即使函数 f2() 抛出了一个异常，这个销毁依然会发生（前提是你捕获了这个异常）。这确保了线程对象 t 所关联的线程正常的执行完毕以及线程对象的正常析构。测试代码。\",\"如果异常被抛出但未被捕获那么就会调用 std::terminate。是否对未捕获的异常进行任何栈回溯由实现定义。（简单的说就是不一定会调用析构）\",\"我们的测试代码是捕获了异常的，为了观测，看到它一定打印“析构”。\",\"在 thread_guard 的析构函数中，我们要判断 std::thread 线程对象现在是否有关联的活跃线程，如果有，我们才会执行 join()，阻塞当前线程直到线程对象关联的线程执行完毕。如果不想等待线程结束可以使用 detach() ，但是这让 std::thread 对象失去了线程资源的所有权，难以掌控，具体如何，看情况分析。\",\"复制赋值和复制构造定义为 =delete 可以防止编译器隐式生成，同时会阻止移动构造函数和移动赋值运算符的隐式定义。这样的话，对 thread_guard 对象进行复制或赋值等操作会引发一个编译错误。\",\"不允许这些操作主要在于：这是个管理类，而且顾名思义，它就应该只是单纯的管理线程对象仅此而已，只保有一个引用，单纯的做好 RAII 的事情就行，允许其他操作没有价值。\",\"严格来说其实这里倒也不算 RAII，因为 thread_guard 的构造函数其实并没有申请资源，只是保有了线程对象的引用，在析构的时候进行了 join() 。\"]},\"14\":{\"h\":\"传递参数\",\"t\":[\"向可调用对象传递参数很简单，我们前面也都写了，只需要将这些参数作为 std::thread 的构造参数即可。需要注意的是，这些参数会复制到新线程的内存空间中，即使函数中的参数是引用，依然实际是复制。\",\"void f(int, const int& a); int n = 1; std::thread t{ f, 3, n };\",\"线程对象 t 的构造没有问题，可以通过编译，但是这个 n 实际上并没有按引用传递，而是按值复制的。我们可以打印地址来验证我们的猜想。\",\"void f(int, const int& a) { // a 并非引用了局部对象 n std::cout << &a << '\\\\n'; } int main() { int n = 1; std::cout << &n << '\\\\n'; std::thread t{ f, 3, n }; t.join(); }\",\"运行代码，打印的地址截然不同。\",\"可以通过编译，但通常这不符合我们的需求，因为我们的函数中的参数是引用，我们自然希望能引用调用方传递的参数，而不是复制。如果我们的 f 的形参类型不是 const 的引用，则会产生一个编译错误。\",\"想要解决这个问题很简单，我们可以使用标准库的设施 std::ref 、 std::cref 函数模板。\",\"void f(int, int& a) { std::cout << &a << '\\\\n'; } int main() { int n = 1; std::cout << &n << '\\\\n'; std::thread t { f, 3, std::ref(n) }; t.join(); }\",\"运行代码，打印地址完全相同。\",\"我们来解释一下，“ref” 其实就是 “reference”（引用）的缩写，意思也很简单，返回“引用”，当然了，不是真的返回引用，它们返回一个包装类 std::reference_wrapper，顾名思义，这个类就是包装引用对象类模板，将对象包装，可以隐式转换为被包装对象的引用。\",\"“cref”呢？，这个“c”就是“const”，就是返回了 std::reference_wrapper<const T>。我们不详细介绍他们的实现，你简单认为reference_wrapper可以隐式转换为被包装对象的引用即可，\",\"int n = 0; std::reference_wrapper<int> r = std::ref(n); int& p = r; // r 隐式转换为 n 的引用 此时 p 引用的就是 n\",\"int n = 0; std::reference_wrapper<const int> r = std::cref(n); const int& p = r; // r 隐式转换为 n 的 const 的引用 此时 p 引用的就是 n\",\"如果对他们的实现感兴趣，可以观看视频。\",\"以上代码void f(int, int&) 如果不使用 std::ref 并不会和前面 void f(int, const int&) 一样只是多了复制，而是会产生编译错误，这是因为 std::thread 内部会将保有的参数副本转换为右值表达式进行传递，这是为了那些只支持移动的类型，左值引用没办法引用右值表达式，所以产生编译错误。\",\"struct move_only { move_only() { std::puts(\\\"默认构造\\\"); } move_only(const move_only&) = delete; move_only(move_only&&)noexcept { std::puts(\\\"移动构造\\\"); } }; void f(move_only){} int main(){ move_only obj; std::thread t{ f,std::move(obj) }; t.join(); }\",\"运行测试。\",\"没有 std::ref 自然是会保有一个副本，所以有两次移动构造，一次是被 std::thread 构造函数中初始化副本，一次是调用函数 f。\",\"如果还有不理解，不用担心，记住，这一切的问题都会在后面的 std::thread 的构造-源码解析 解释清楚。\",\"成员函数指针也是可调用(Callable)的 ，可以传递给 std::thread 作为构造参数，让其关联的线程执行成员函数。\",\"struct X{ void task_run(int)const; }; X x; int n = 0; std::thread t{ &X::task_run,&x,n }; t.join();\",\"传入成员函数指针、与其配合使用的对象、调用成员函数的参数，构造线程对象 t，启动线程。\",\"如果你是第一次见到成员指针，那么我们稍微聊一下，&X::task_run 是一个整体，它们构成了成员指针，&类名::非静态成员。\",\"成员指针必须和对象一起使用，这是唯一标准用法，成员指针不可以转换到函数指针单独使用，即使是非静态成员函数没有使用任何数据成员。\",\"我们还可以使用模板函数 std::bind与成员指针一起使用\",\"std::thread t{ std::bind(&X::task_run, &x ,n) };\",\"不过需要注意，std::bind 也是默认按值复制的，即使我们的成员函数形参类型为引用：\",\"struct X { void task_run(int& a)const{ std::cout << &a << '\\\\n'; } }; X x; int n = 0; std::cout << &n << '\\\\n'; std::thread t{ std::bind(&X::task_run,&x,n) }; t.join();\",\"除非给参数 n 加上 std::ref，就是按引用传递了：\",\"std::thread t{ std::bind(&X::task_run,&x,std::ref(n)) };\",\"void f(const std::string&); std::thread t{ f,\\\"hello\\\" };\",\"代码创建了一个调用 f(\\\"hello\\\") 的线程。注意，函数 f 实际需要的是一个 std::string 类型的对象作为参数，但这里使用的是字符串字面量，我们要明白“A的引用只能引用A，或者以任何形式转换到A”，字符串字面量的类型是 const char[N] ，它会退化成指向它的const char* 指针，被线程对象保存。在调用 f 的时候，这个指针可以通过 std::string 的转换构造函数，构造出一个临时的 std::string 对象，就能成功调用。\",\"字符串字面量具有静态存储期，指向它的指针这当然没问题了，不用担心生存期的问题，但是如果是指向“动态”对象的指针，就要特别注意了：\",\"void f(const std::string&); void test(){ char buffer[1024]{}; //todo.. code std::thread t{ f,buffer }; t.detach(); }\",\"以上代码可能导致一些问题，buffer 是一个数组对象，作为 std::thread 构造参数的传递的时候会decay-copy （确保实参在按值传递时会退化） 隐式转换为了指向这个数组的指针。\",\"我们要特别强调，std::thread 构造是代表“启动线程”，而不是调用我们传递的可调用对象。\",\"std::thread 的构造函数中调用了创建线程的函数（windows 下可能为 _beginthreadex），它将我们传入的参数，f、buffer ，传递给这个函数，在新线程中执行函数 f。也就是说，调用和执行 f(buffer) 并不是说要在 std::thread 的构造函数中，而是在创建的新线程中，具体什么时候执行，取决于操作系统的调度，所以完全有可能函数 test 先执行完，而新线程此时还没有进行 f(buffer) 的调用，转换为std::string，那么 buffer 指针就悬空了，会导致问题。解决方案：\",\"将 detach() 替换为 join()。\",\"void f(const std::string&); void test(){ char buffer[1024]{}; //todo.. code std::thread t{ f,buffer }; t.join(); }\",\"显式将 buffer 转换为 std::string。\",\"void f(const std::string&); void test(){ char buffer[1024]{}; //todo.. code std::thread t{ f,std::string(buffer) }; t.detach(); }\"]},\"15\":{\"h\":\"\",\"t\":[\"这个命名空间包含了管理当前线程的函数。\",\"yield 建议实现重新调度各执行线程。\",\"get_id 返回当前线程 id。\",\"sleep_for 使当前线程停止执行指定时间。\",\"sleep_until 使当前线程执行停止到指定的时间点。\",\"它们之中最常用的是 get_id，其次是 sleep_for，再然后 yield，sleep_until 较少。\",\"使用 get_id打印主线程和子线程的 ID。\",\"int main() { std::cout << std::this_thread::get_id() << '\\\\n'; std::thread t{ [] { std::cout << std::this_thread::get_id() << '\\\\n'; } }; t.join(); }\",\"使用 sleep_for 延时。当 Sleep 之类的就行，但是它需要接受的参数不同，是 std::chrono 命名空间中的时间对象。\",\"int main() { std::this_thread::sleep_for(std::chrono::seconds(3)); }\",\"主线程延时 3 秒，这个传入了一个临时对象 seconds ，它是模板 std::chrono::duration 的别名，以及还有很多其他的时间类型，都基于这个类。说实话挺麻烦的，如果您支持 C++14，建议使用时间字面量，在 std::chrono_literals 命名空间中。我们可以改成下面这样：\",\"using namespace std::chrono_literals; int main() { std::this_thread::sleep_for(3s); }\",\"简单直观。\",\"yield 减少 CPU 的占用。\",\"while (!isDone()){ std::this_thread::yield(); }\",\"线程需要等待某个操作完成，如果你直接用一个循环不断判断这个操作是否完成就会使得这个线程占满 CPU 时间，这会造成资源浪费。此时可以判断操作是否完成，如果还没完成就调用 yield 交出 CPU 时间片让其他线程执行，过一会儿再来判断是否完成，这样这个线程占用 CPU 时间会大大减少。\",\"使用 sleep_until 让当前线程延迟到具体的时间。我们延时 5 秒就是。\",\"int main() { // 获取当前时间点 auto now = std::chrono::system_clock::now(); // 设置要等待的时间点为当前时间点之后的5秒 auto wakeup_time = now + 5s; // 输出当前时间 auto now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Current time:\\\\t\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\") << std::endl; // 输出等待的时间点 auto wakeup_time_time = std::chrono::system_clock::to_time_t(wakeup_time); std::cout << \\\"Waiting until:\\\\t\\\\t\\\" << std::put_time(std::localtime(&wakeup_time_time), \\\"%H:%M:%S\\\") << std::endl; // 等待到指定的时间点 std::this_thread::sleep_until(wakeup_time); // 输出等待结束后的时间 now = std::chrono::system_clock::now(); now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Time after waiting:\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\") << std::endl; }\",\"sleep_until 本身设置使用很简单，是打印时间格式、设置时区麻烦。运行结果。\",\"介绍了一下 std::this_thread 命名空间中的四个函数的基本用法，我们后续会经常看到这些函数的使用，不用着急。\"]},\"16\":{\"h\":\"转移所有权\",\"t\":[\"传入可调用对象以及参数，构造 std::thread 对象，启动线程，而线程对象拥有了线程的所有权，线程是一种系统资源，所以可称作“线程资源”。\",\"std::thread 不可复制。两个 std::thread 对象不可表示一个线程，std::thread 对线程资源是独占所有权。而移动操作可以将一个 std::thread 对象的线程资源所有权转移给另一个 std::thread 对象。\",\"int main() { std::thread t{ [] { std::cout << std::this_thread::get_id() << '\\\\n'; } }; std::cout << t.joinable() << '\\\\n'; // 线程对象 t 当前关联了活跃线程 打印 1 std::thread t2{ std::move(t) }; // 将 t 的线程资源的所有权移交给 t2 std::cout << t.joinable() << '\\\\n'; // 线程对象 t 当前没有关联活跃线程 打印 0 //t.join(); // Error! t 没有线程资源 t2.join(); // t2 当前持有线程资源 }\",\"这段代码通过移动构造转移了线程对象 t 的线程资源所有权到 t2，这里虽然有两个 std::thread 对象，但是从始至终只有一个线程资源，让持有线程资源的 t2 对象最后调用 join() 阻塞让其线程执行完毕。t 与 t2 都能正常析构。\",\"我们还可以使用移动赋值来转移线程资源的所有权：\",\"int main() { std::thread t; // 默认构造，没有关联活跃线程 std::cout << t.joinable() << '\\\\n'; // 0 std::thread t2{ [] {} }; t = std::move(t2); // 转移线程资源的所有权到 t std::cout << t.joinable() << '\\\\n'; // 1 t.join(); t2 = std::thread([] {}); t2.join(); }\",\"我们只需要介绍 t2 = std::thread([] {}) ，临时对象是右值表达式，不用调用 std::move，这里相当于是将临时的 std::thread 对象所持有的线程资源转移给 t2，t2 再调用 join() 正常析构。\",\"函数返回 std::thread 对象：\",\"std::thread f(){ std::thread t{ [] {} }; return t; } int main(){ std::thread rt = f(); rt.join(); }\",\"这段代码可以通过编译，你是否感到奇怪？我们在函数 f 中创建了一个局部的 std::thread 对象，启动线程，然后返回它。\",\"这里的 return t重载决议[1]选择到了移动构造，将 t 线程资源的所有权转移给函数调用 f() 返回的临时 std::thread 对象中，然后这个临时对象再用来初始化 rt ，临时对象是右值表达式，这里一样选择到移动构造，将临时对象的线程资源所有权移交给 rt。此时 rt 具有线程资源的所有权，由它调用 join() 正常析构。\",\"如果标准达到 C++17，强制的复制消除（RVO）保证这里少一次移动构造的开销（临时对象初始化 rt 的这次）。\",\"所有权也可以在函数内部传递：\",\"void f(std::thread t){ t.join(); } int main(){ std::thread t{ [] {} }; f(std::move(t)); f(std::thread{ [] {} }); }\",\"std::move 将 t 转换为了一个右值表达式，初始化函数f 形参 t，选择到了移动构造转移线程资源的所有权，在函数中调用 t.join() 后正常析构。std::thread{ [] {} } 构造了一个临时对象，本身就是右值表达式，初始化函数f 形参 t，移动构造转移线程资源的所有权到 t，t.join() 后正常析构。\",\"本节内容总体来说是很简单的，如果你有些地方无法理解，那只有一种可能，“对移动语义不了解”，不过这也不是问题，在后续我们详细介绍 std::thread 构造函数的源码即可，不用着急。\"]},\"17\":{\"h\":\"\",\"t\":[\"我们上一个大节讲解了线程管理，也就是 std::thread 的使用，其中的重中之重就是它的构造，传递参数。我们用源码实现为各位从头讲解。\",\"了解其实现，才能更好的使用它，同时也能解释其使用与学习中的各种问题。如：\",\"如何做到的默认按值复制？\",\"为什么需要 std::ref ？\",\"如何支持只能移动的对象？\",\"如何做到接受任意可调用对象？\",\"如何创建的线程？\",\"传递参数一节中的：“std::thread 内部会将保有的参数副本转换为右值表达式进行传递”到底是如何做到的？\",\"当你看完 std::thread 的构造-源码解析 后，可以再回过头来问问自己是否能够回答这些问题。\"]},\"18\":{\"h\":\"实现\",\"t\":[\"这个类和 std::thread 的区别就是析构函数会自动 join 。如果您好好的学习了上一节的内容，阅读了 std::thread 的源码，以下内容不会对您构成任何的难度。\",\"我们存储一个 std::thread 作为底层数据成员，稍微注意一下构造函数和赋值运算符的实现即可。\",\"class joining_thread { std::thread t; public: joining_thread()noexcept = default; template<typename Callable, typename... Args> explicit joining_thread(Callable&& func, Args&&...args) : t{ std::forward<Callable>(func), std::forward<Args>(args)... } {} explicit joining_thread(std::thread t_)noexcept : t{ std::move(t_) } {} joining_thread(joining_thread&& other)noexcept : t{ std::move(other.t) } {} joining_thread& operator=(std::thread&& other)noexcept { if (joinable()) { // 如果当前有活跃线程，那就先执行完 join(); } t = std::move(other); return *this; } ~joining_thread() { if (joinable()) { join(); } } void swap(joining_thread& other)noexcept { t.swap(other.t); } std::thread::id get_id()const noexcept { return t.get_id(); } bool joinable()const noexcept { return t.joinable(); } void join() { t.join(); } void detach() { t.detach(); } std::thread& data()noexcept { return t; } const std::thread& data()const noexcept { return t; } };\",\"简单使用一下：\",\"int main(){ std::cout << std::this_thread::get_id() << '\\\\n'; joining_thread thread{[]{ std::cout << std::this_thread::get_id() << '\\\\n'; } }; joining_thread thread2{ std::move(thread) }; }\",\"使用容器管理线程对象，等待线程执行结束：\",\"void do_work(std::size_t id){ std::cout << id << '\\\\n'; } int main(){ std::vector<std::thread>threads; for (std::size_t i = 0; i < 10; ++i){ threads.emplace_back(do_work, i); // 产生线程 } for(auto& thread:threads){ thread.join(); // 对每个线程对象调用 join() } }\",\"运行测试。\",\"线程对象代表了线程，管理线程对象也就是管理线程，这个 vector 对象管理 10 个线程，保证他们的执行、退出。\",\"使用我们这节实现的 joining_thread 则不需要最后的循环 join()：\",\"int main(){ std::vector<joining_thread>threads; for (std::size_t i = 0; i < 10; ++i){ threads.emplace_back(do_work, i); } }\",\"运行测试。\",\"如果你自己编译了这些代码，相信你注意到了，打印的是乱序的，没什么规律，而且重复运行的结果还不一样，这是正常现象。多线程执行就是如此，无序且操作可能被打断。使用互斥量可以解决这些问题，这也就是下一章节的内容了。\"]},\"19\":{\"h\":\"C++20\",\"t\":[\"std::jthread 相比于 C++11 引入的 std::thread，只是多了两个功能：\",\"RAII 管理：在析构时自动调用 join()。\",\"线程停止功能：线程的取消/停止。\"]},\"20\":{\"h\":\"零开销原则\",\"t\":[\"我知道你肯定有疑问，为什么 C++20 不直接为 std::thread 增加这两个功能，而是创造一个新的线程类型呢？\",\"这就是 C++ 的设计哲学，零开销原则：你不需要为你没有用到的（特性）付出额外的开销。\",\"std::jthread 的通常实现就是单纯的保有 std::thread + std::stop_source 这两个数据成员：\",\"thread _Impl; stop_source _Ssource;\",\"MSVC STL、libstdc++、libc++ 均是如此。\",\"stop_source 通常占 8 字节，先前 std::thread 源码解析详细聊过其不同标准库对其保有的成员不同，简单来说也就是 64 位环境，大小为 16 或者 8。也就是 sizeof(std::jthread) 的值相比 std::thread 会多 8 ，为 24 或 16。\",\"引入 std::jthread 符合零开销原则，它通过创建新的类型提供了更多的功能，而没有影响到原来 std::thread 的性能和内存占用。\"]},\"21\":{\"h\":\"线程停止\",\"t\":[\"第一个功能很简单，不用赘述，我们直接聊这个所谓的“线程停止”就好。\",\"首先要明确，C++ 的 std::jthread 提供的线程停止功能并不同于常见的 POSIX 函数 pthread_cancel。pthread_cancel 是一种发送取消请求的函数，但并不是强制性的线程终止方式。目标线程的可取消性状态和类型决定了取消何时生效。当取消被执行时，进行清理和终止线程[2]。\",\"std::jthread 所谓的线程停止只是一种基于用户代码的控制机制，而不是一种与操作系统系统有关系的线程终止。使用 std::stop_source 和 std::stop_token 提供了一种优雅地请求线程停止的方式，但实际上停止的决定和实现都由用户代码来完成。\",\"using namespace std::literals::chrono_literals; void f(std::stop_token stop_token, int value){ while (!stop_token.stop_requested()){ // 检查是否已经收到停止请求 std::cout << value++ << ' ' << std::flush; std::this_thread::sleep_for(200ms); } std::cout << std::endl; } int main(){ std::jthread thread{ f, 1 }; // 打印 1..15 大约 3 秒 std::this_thread::sleep_for(3s); // jthread 的析构函数调用 request_stop() 和 join()。 }\",\"运行测试。截止目前（2024/5/29 clang19 未发布） libc++ 不完全支持 std::jthread，建议使用 clang 的开发者链接 libstdc++ 或 MSVC STL 进行编译。如果非要使用 libc++，可以添加 -fexperimental-library 编译选项，启用不稳定库功能和实验库功能。这样，我们的这段代码就可以通过编译。\",\"std::jthread 提供了三个成员函数进行所谓的线程停止：\",\"get_stop_source：返回与 jthread 对象关联的 std::stop_source，允许从外部请求线程停止。\",\"get_stop_token：返回与 jthread 对象停止状态[3]关联的 std::stop_token，允许检查是否有停止请求。\",\"request_stop：请求线程停止。\",\"上面这段代码并未出现这三个函数的任何一个调用，不过在 jthread 的析构函数中，会调用 request_stop 请求线程停止。\",\"void _Try_cancel_and_join() noexcept { if (_Impl.joinable()) { _Ssource.request_stop(); _Impl.join(); } } ~jthread() { _Try_cancel_and_join(); }\",\"至于 std::jthread thread{ f, 1 }; 函数 f 的 std::stop_token 的形参是谁传递的？其实就是线程对象自己调用 get_token() 传递的 ，源码一眼便可发现：\",\"template <class _Fn, class... _Args, enable_if_t<!is_same_v<remove_cvref_t<_Fn>, jthread>, int> = 0> _NODISCARD_CTOR_JTHREAD explicit jthread(_Fn&& _Fx, _Args&&... _Ax) { if constexpr (is_invocable_v<decay_t<_Fn>, stop_token, decay_t<_Args>...>) { _Impl._Start(_STD forward<_Fn>(_Fx), _Ssource.get_token(), _STD forward<_Args>(_Ax)...); } else { _Impl._Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...); } }\",\"也就是说虽然最初的那段代码看似什么都没调用，但是实际什么都调用了。这所谓的线程停止，其实简单来说，有点像外部给线程传递信号一样。\",\"std::stop_source：\",\"这是一个可以发出停止请求的类型。当你调用 stop_source 的 request_stop() 方法时，它会设置内部的停止状态为“已请求停止”。\",\"任何持有与这个 stop_source 关联的 std::stop_token 对象都能检查到这个停止请求。\",\"std::stop_token：\",\"这是一个可以检查停止请求的类型。线程内部可以定期检查 stop_token 是否收到了停止请求。\",\"通过调用 stop_token.stop_requested()，线程可以检测到停止状态是否已被设置为“已请求停止”。\"]},\"22\":{\"h\":\"\",\"t\":[\"零开销原则应当很好理解。我们本节的难点只在于使用到了一些 MSVC STL 的源码实现来配合理解，其主要在于“线程停止”。线程停止设施你会感觉是一种类似于外部与线程进行某种信号通信的设施，std::stop_source 和 std::stop_token 都与线程对象关联，然后来管理函数到底如何执行。\",\"我们并没有举很多的例子，我们觉得这一个小例子所牵扯到的内容也就足够了，关键在于理解其设计与概念。\"]},\"23\":{\"h\":\"总结\",\"t\":[\"本章节的内容围绕着：“使用线程”，也就是\\\"使用 std::thread\\\"展开， std::thread 是我们学习 C++ 并发支持库的重中之重，在最后谈起了 C++20 引入的 std::jthread ，它的使用与概念也非常的简单。本章的内容在市面上并不算少见，但是却是少有的准确与完善。即使你早已学习乃至使用 C++ 标准库进行多线程编程，我相信本章也一定可以让你收获良多。\",\"并且如果是第一次学习本章的内容，可能会有一些难以理解的地方。建议你多思考、多记忆，并在以后反复查看和实践。\",\"我尽量以简单通俗的方式进行讲解。学完本章后，你可能还无法在实际环境利用多线程提升程序效率，至少还需要学习到使用互斥量来保护共享数据，才能实际应用多线程编程。\",\"重载决议简单来说就是编译器必须要根据规则选择最合适的函数重载进行调用。 ↩︎\",\"注：通常需要线程执行的函数中有一些系统调用，设置取消点，线程会在那个调用中结束。 ↩︎\",\"注：“停止状态”指的是由 std::stop_source 和 std::stop_token 管理的一种标志，用于通知线程应该停止执行。这种机制不是强制性的终止线程，而是提供一种线程内外都能检查和响应的信号。 ↩︎\"]},\"24\":{\"h\":\"共享数据\",\"t\":[\"本章节主要内容：\",\"多线程共享数据的问题\",\"使用互斥量保护共享数据\",\"保护共享数据的其它方案\",\"有关线程安全的其它问题\",\"在上一章内容，我们对于线程的基本使用和管理，可以说已经比较了解了，甚至深入阅读了部分的 std::thread 源码。所以如果你好好学习了上一章，本章也完全不用担心。\",\"我们本章，就要开始聊共享数据的那些事。\"]},\"25\":{\"h\":\"条件竞争\",\"t\":[\"在多线程的情况下，每个线程都抢着完成自己的任务。在大多数情况下，即使会改变执行顺序，也是良性竞争，这是无所谓的。比如两个线程都要往标准输出输出一段字符，谁先谁后并不会有什么太大影响。\",\"void f() { std::cout << \\\"❤️\\\\n\\\"; } void f2() { std::cout << \\\"😢\\\\n\\\"; } int main(){ std::thread t{ f }; std::thread t2{ f2 }; t.join(); t2.join(); }\",\"std::cout 的 operator<< 调用是线程安全的，不会被打断。即：同步的 C++ 流保证是线程安全的（从多个线程输出的单独字符可能交错，但无数据竞争）\",\"只有在涉及多线程读写相同共享数据的时候，才会导致“恶性的条件竞争”。\",\"std::vector<int>v; void f() { v.emplace_back(1); } void f2() { v.erase(v.begin()); } int main() { std::thread t{ f }; std::thread t2{ f2 }; t.join(); t2.join(); std::cout << v.size() << '\\\\n'; }\",\"比如这段代码就是典型的恶性条件竞争，两个线程共享一个 vector，并对它进行修改。可能导致许多问题，比如 f2 先执行，此时 vector 还没有元素，导致抛出异常。又或者 f 执行了一半，调用了 f2()，等等。\",\"当然了，也有可能先执行 f，然后执行 f2，最后打印了 0，程序老老实实执行完毕。\",\"但是我们显然不能寄希望于这种操作系统的调度。\",\"而且即使不是一个添加元素，一个删除元素，全是 emplace_back 添加元素，也一样会有问题，由于 std::vector 不是线程安全的容器，因此当多个线程同时访问并修改 v 时，可能会发生未定义的行为。具体来说，当两个线程同时尝试向 v 中添加元素时，但是 emplace_back 函数却是可以被打断的，执行了一半，又去执行另一个线程。可能会导致数据竞争，从而引发未定义的结果。\",\"当某个表达式的求值写入某个内存位置，而另一求值读或修改同一内存位置时，称这些表达式冲突。拥有两个冲突的求值的程序就有数据竞争，除非\",\"两个求值都在同一线程上，或者在同一信号处理函数中执行，或\",\"两个冲突的求值都是原子操作（见 std::atomic），或\",\"一个冲突的求值发生早于 另一个（见 std::memory_order）\",\"如果出现数据竞争，那么程序的行为未定义。\",\"标量类型等都同理，有数据竞争，未定义行为：\",\"int cnt = 0; auto f = [&]{cnt++;}; std::thread t1{f}, t2{f}, t3{f}; // 未定义行为\"]},\"26\":{\"h\":\"使用互斥量\",\"t\":[\"互斥量（Mutex），又常被称为互斥锁、互斥体（或者直接被称作“锁”），是一种用来保护临界区[1]的特殊对象，其相当于实现了一个公共的“标志位”。它可以处于锁定（locked）状态，也可以处于解锁（unlocked）状态：\",\"如果互斥量是锁定的，通常说某个特定的线程正持有这个锁。\",\"如果没有线程持有这个互斥量，那么这个互斥量就处于解锁状态。\",\"概念从来不是我们的重点，用一段对比代码为你直观的展示互斥量的作用：\",\"void f() { std::cout << std::this_thread::get_id() << '\\\\n'; } int main() { std::vector<std::thread> threads; for (std::size_t i = 0; i < 10; ++i) threads.emplace_back(f); for (auto& thread : threads) thread.join(); }\",\"这段代码你多次运行它会得到毫无规律和格式的结果，我们可以使用互斥量解决这个问题：\",\"#include <mutex> // 必要标头 std::mutex m; void f() { m.lock(); std::cout << std::this_thread::get_id() << '\\\\n'; m.unlock(); } int main() { std::vector<std::thread>threads; for (std::size_t i = 0; i < 10; ++i) threads.emplace_back(f); for (auto& thread : threads) thread.join(); }\",\"当多个线程执行函数 f 的时候，只有一个线程能成功调用 lock() 给互斥量上锁，其他所有的线程 lock() 的调用将阻塞执行，直至获得锁。第一个调用 lock() 的线程得以继续往下执行，执行我们的 std::cout 输出语句，不会有任何其他的线程打断这个操作。直到线程执行 unlock()，就解锁了互斥量。\",\"那么其他线程此时也就能再有一个成功调用 lock...\",\"至于到底哪个线程才会成功调用，这个是由操作系统调度决定的。\",\"看一遍描述就可以了，简而言之，被 lock() 和 unlock() 包含在其中的代码是线程安全的，同一时间只有一个线程执行，不会被其它线程的执行所打断。\"]},\"27\":{\"h\":\"\",\"t\":[\"不过一般不推荐这样显式的 lock() 与 unlock()，我们可以使用 C++11 标准库引入的“管理类” std::lock_guard：\",\"void f() { std::lock_guard<std::mutex> lc{ m }; std::cout << std::this_thread::get_id() << '\\\\n'; }\",\"那么问题来了，std::lock_guard 是如何做到的呢？它是怎么实现的呢？首先顾名思义，这是一个“管理类”模板，用来管理互斥量的上锁与解锁，我们来看它在 MSVC STL 的实现：\",\"_EXPORT_STD template <class _Mutex> class _NODISCARD_LOCK lock_guard { // class with destructor that unlocks a mutex public: using mutex_type = _Mutex; explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don't lock ~lock_guard() noexcept { _MyMutex.unlock(); } lock_guard(const lock_guard&) = delete; lock_guard& operator=(const lock_guard&) = delete; private: _Mutex& _MyMutex; };\",\"这段代码极其简单，首先管理类，自然不可移动不可复制，我们定义复制构造与复制赋值为弃置函数，同时阻止了移动等函数的隐式定义。\",\"它只保有一个私有数据成员，一个引用，用来引用互斥量。\",\"构造函数中初始化这个引用，同时上锁，析构函数中解锁，这是一个非常典型的 RAII 式的管理。\",\"同时它还提供一个有额外std::adopt_lock_t参数的构造函数 ，如果使用这个构造函数，则构造函数不会上锁。\",\"所以有的时候你可能会看到一些这样的代码：\",\"void f(){ //code.. { std::lock_guard<std::mutex> lc{ m }; // 涉及共享资源的修改的代码... } //code.. }\",\"使用 {} 创建了一个块作用域，限制了对象 lc 的生存期，进入作用域构造 lock_guard 的时候上锁（lock），离开作用域析构的时候解锁（unlock）。\",\"我们要尽可能的让互斥量上锁的粒度小，只用来确保必须的共享资源的线程安全。\",\"“粒度”通常用于描述锁定的范围大小，较小的粒度意味着锁定的范围更小，因此有更好的性能和更少的竞争。\",\"我们举一个例子：\",\"std::mutex m; void add_to_list(int n, std::list<int>& list) { std::vector<int> numbers(n + 1); std::iota(numbers.begin(), numbers.end(), 0); int sum = std::accumulate(numbers.begin(), numbers.end(), 0); { std::lock_guard<std::mutex> lc{ m }; list.push_back(sum); } } void print_list(const std::list<int>& list){ std::lock_guard<std::mutex> lc{ m }; for(const auto& i : list){ std::cout << i << ' '; } std::cout << '\\\\n'; }\",\"std::list<int> list; std::thread t1{ add_to_list,i,std::ref(list) }; std::thread t2{ add_to_list,i,std::ref(list) }; std::thread t3{ print_list,std::cref(list) }; std::thread t4{ print_list,std::cref(list) }; t1.join(); t2.join(); t3.join(); t4.join();\",\"完整代码测试。\",\"先看 add_to_list，只有 list.push_back(sum) 涉及到了对共享数据的修改，需要进行保护，我们用 {} 包起来了。\",\"假设有线程 A、B执行函数 add_to_list() ：线程 A 中的 numbers、sum 与线程 B 中的，不是同一个，希望大家分清楚，自然不存在数据竞争，也不需要上锁。线程 A、B执行完了前面求 0-n 的计算，只有一个线程能在 lock_guard 的构造函数中成功调用 lock() 给互斥量上锁。假设线程 A 成功调用 lock()，那么线程 B 的 lock() 调用就阻塞了，必须等待线程 A 执行完里面的代码，然后作用域结束，调用 lock_guard 的析构函数，解锁 unlock()，此时线程 B 就可以进去执行了，避免了数据竞争，不存在一个对象同时被多个线程修改。\",\"函数 print_list() 就更简单了，打印 list，给整个函数上锁，同一时刻只能有一个线程执行。\",\"我们的使用代码是多个线程执行这两个函数，两个函数共享了一个锁，这样确保了当执行函数 print_list() 打印的时候，list 的状态是确定的。打印函数 print_list 和 add_to_list 函数的修改操作同一时间只能有一个线程在执行。print_list() 不可能看到正在被add_to_list() 修改的 list。\",\"至于到底哪个函数哪个线程会先执行，执行多少次，这些都由操作系统调度决定，也完全有可能连续 4 次都是执行函数 print_list 的线程成功调用 lock，会打印出了一样的值，这都很正常。\",\"C++17 添加了一个新的特性，类模板实参推导， std::lock_guard 可以根据传入的参数自行推导，而不需要写明模板类型参数：\",\"std::mutex m; std::lock_guard lc{ m }; // std::lock_guard<std::mutex>\",\"并且 C++17 还引入了一个新的“管理类”：std::scoped_lock，它相较于 lock_guard的区别在于，它可以管理多个互斥量。不过对于处理一个互斥量的情况，它和 lock_guard 几乎完全相同。\",\"std::mutex m; std::scoped_lock lc{ m }; // std::scoped_lock<std::mutex>\",\"我们在后续管理多个互斥量，会详细了解这个类。\"]},\"28\":{\"h\":\"\",\"t\":[\"try_lock 是互斥量中的一种尝试上锁的方式。与常规的 lock 不同，try_lock 会尝试上锁，但如果锁已经被其他线程占用，则不会阻塞当前线程，而是立即返回。\",\"它的返回类型是 bool ，如果上锁成功就返回 true，失败就返回 false。\",\"这种方法在多线程编程中很有用，特别是在需要保护临界区的同时，又不想线程因为等待锁而阻塞的情况下。\",\"std::mutex mtx; void thread_function(int id) { // 尝试加锁 if (mtx.try_lock()) { std::cout << \\\"线程：\\\" << id << \\\" 获得锁\\\" << std::endl; // 临界区代码 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟临界区操作 mtx.unlock(); // 解锁 std::cout << \\\"线程：\\\" << id << \\\" 释放锁\\\" << std::endl; } else { std::cout << \\\"线程：\\\" << id << \\\" 获取锁失败 处理步骤\\\" << std::endl; } }\",\"如果有两个线程运行这段代码，必然有一个线程无法成功上锁，要走 else 的分支。\",\"std::thread t1(thread_function, 1); std::thread t2(thread_function, 2); t1.join(); t2.join();\",\"可能的运行结果：\",\"线程：1 获得锁 线程：2 获取锁失败 处理步骤 线程：1 释放锁\"]},\"29\":{\"h\":\"保护共享数据\",\"t\":[\"互斥量主要也就是为了保护共享数据，上一节的使用互斥量也已经为各位展示了一些。\",\"然而使用互斥量来保护共享数据也并不是在函数中加上一个 std::lock_guard 就万事大吉了。有的时候只需要一个指针或者引用，就能让这种保护形同虚设。\",\"class Data{ int a{}; std::string b{}; public: void do_something(){ // 修改数据成员等... } }; class Data_wrapper{ Data data; std::mutex m; public: template<class Func> void process_data(Func func){ std::lock_guard<std::mutex> lc{m}; func(data); // 受保护数据传递给函数 } }; Data* p = nullptr; void malicious_function(Data& protected_data){ p = &protected_data; // 受保护的数据被传递到外部 } Data_wrapper d; void foo(){ d.process_data(malicious_function); // 传递了一个恶意的函数 p->do_something(); // 在无保护的情况下访问保护数据 }\",\"成员函数模板 process_data 看起来一点问题也没有，使用 std::lock_guard 对数据做了保护，但是调用方传递了 malicious_function 这样一个恶意的函数，使受保护数据传递给外部，可以在没有被互斥量保护的情况下调用 do_something()。\",\"我们传递的函数就不该是涉及外部副作用的，就应该是单纯的在受互斥量保护的情况下老老实实调用 do_something() 操作受保护的数据。\",\"简而言之：切勿将受保护数据的指针或引用传递到互斥量作用域之外，不然保护将形同虚设。\",\"process_data 的确算是没问题，用户非要做这些事情也是防不住的，我们只是告诉各位可能的情况。\"]},\"30\":{\"h\":\"死锁：问题与解决\",\"t\":[\"试想一下，有一个玩具，这个玩具有两个部分，必须同时拿到两部分才能玩。比如一个遥控汽车，需要遥控器和玩具车才能玩。有两个小孩，他们都想玩这个玩具。当其中一个小孩拿到了遥控器和玩具车时，就可以尽情玩耍。当另一个小孩也想玩，他就得等待另一个小孩玩完才行。再试想，遥控器和玩具车被放在两个不同的地方，并且两个小孩都想要玩，并且一个拿到了遥控器，另一个拿到了玩具车。问题就出现了，除非其中一个孩子决定让另一个先玩，他把自己的那个部分给另一个小孩。但如果他们都不愿意，那么这个遥控汽车就谁都没有办法玩。\",\"我们当然不在乎小孩抢玩具，我们要聊的是线程对锁的竞争：两个线程需要对它们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个线程的互斥量解锁。因为它们都在等待对方释放互斥量，没有线程工作。 这种情况就是死锁。\",\"多个互斥量才可能遇到死锁问题。\",\"避免死锁的一般建议是让两个互斥量以相同的顺序上锁，总在互斥量 B 之前锁住互斥量 A，就通常不会死锁。反面示例\",\"std::mutex m1,m2; std::size_t n{}; void f(){ std::lock_guard<std::mutex> lc1{ m1 }; std::lock_guard<std::mutex> lc2{ m2 }; ++n; } void f2() { std::lock_guard<std::mutex> lc1{ m2 }; std::lock_guard<std::mutex> lc2{ m1 }; ++n; }\",\"f 与 f2 因为互斥量上锁顺序不同，就有死锁风险。函数 f 先锁定 m1，然后再尝试锁定 m2，而函数 f2 先锁定 m2 再锁定 m1 。如果两个线程同时运行，它们就可能会彼此等待对方释放其所需的锁，从而造成死锁。\",\"简而言之，有可能函数 f 锁定了 m1，函数 f2 锁定了 m2，函数 f 要往下执行，给 m2 上锁，所以在等待 f2 解锁 m2，然而函数 f2 也在等待函数 f 解锁 m1 它才能往下执行。所以死锁。测试代码。\",\"但是有的时候即使固定锁顺序，依旧会产生问题。当有多个互斥量保护同一个类的对象时，对于相同类型的两个不同对象进行数据的交换操作，为了保证数据交换的正确性，就要避免其它线程修改，确保每个对象的互斥量都锁住自己要保护的区域。如果按照前面的的选择一个固定的顺序上锁解锁，则毫无意义，比如：\",\"struct X{ X(const std::string& str) :object{ str } {} friend void swap(X& lhs, X& rhs); private: std::string object; std::mutex m; }; void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::lock_guard<std::mutex> lock1{ lhs.m }; std::lock_guard<std::mutex> lock2{ rhs.m }; swap(lhs.object, rhs.object); }\",\"考虑用户调用的时候将参数交换，就会产生死锁：\",\"X a{ \\\"🤣\\\" }, b{ \\\"😅\\\" }; std::thread t{ [&] {swap(a, b); } }; // 1 std::thread t2{ [&] {swap(b, a); } }; // 2\",\"1 执行的时候，先上锁 a 的互斥量，再上锁 b 的互斥量。\",\"2 执行的时候，先上锁 b 的互斥量，再上锁 a 的互斥量。\",\"完全可能线程 A 执行 1 的时候上锁了 a 的互斥量，线程 B 执行 2 上锁了 b 的互斥量。线程 A 往下执行需要上锁 b 的互斥量，线程 B 则要上锁 a 的互斥量执行完毕才能解锁，哪个都没办法往下执行，死锁。测试代码。\",\"其实也就是回到了第一个示例的问题。\",\"C++ 标准库有很多办法解决这个问题，可以使用 std::lock ，它能一次性锁住多个互斥量，并且没有死锁风险。修改 swap 代码后如下：\",\"void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::lock(lhs.m, rhs.m); // 给两个互斥量上锁 std::lock_guard<std::mutex> lock1{ lhs.m,std::adopt_lock }; std::lock_guard<std::mutex> lock2{ rhs.m,std::adopt_lock }; swap(lhs.object, rhs.object); }\",\"因为前面已经使用了 std::lock 上锁，所以后的 std::lock_guard 构造都额外传递了一个 std::adopt_lock 参数，让其选择到不上锁的构造函数。函数退出也能正常解锁。\",\"std::lock 给 lhs.m 或 rhs.m 上锁时若抛出异常，则在重抛前对任何已锁的对象调用 unlock() 解锁，也就是 std::lock 要么将互斥量都上锁，要么一个都不锁。\",\"C++17 新增了 std::scoped_lock ，提供此函数的 RAII 包装，通常它比裸调用 std::lock 更好。\",\"所以我们前面的代码可以改写为：\",\"void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::scoped_lock guard{ lhs.m,rhs.m }; swap(lhs.object, rhs.object); }\",\"对此类有兴趣或任何疑问，建议阅读std::scoped_lock 的源码实现与解析\",\"使用 std::scoped_lock 可以将所有 std::lock 替换掉，减少错误发生。\",\"然而它们的帮助都是有限的，一切最终都是依靠开发者使用与管理。\",\"死锁是多线程编程中令人相当头疼的问题，并且死锁经常是不可预见，甚至难以复现，因为在大部分时间里，程序都能正常完成工作。我们可以通过一些简单的规则，约束开发者的行为，帮助写出“无死锁”的代码。\",\"避免嵌套锁\",\"线程获取一个锁时，就别再获取第二个锁。每个线程只持有一个锁，自然不会产生死锁。如果必须要获取多个锁，使用 std::lock 。\",\"避免在持有锁时调用外部代码\",\"这个建议是很简单的：因为代码是外部提供的，所以没办法确定外部要做什么。外部程序可能做任何事情，包括获取锁。在持有锁的情况下，如果用外部代码要获取一个锁，就会违反第一个指导意见，并造成死锁（有时这是无法避免的）。当写通用代码时（比如保护共享数据中的 Date 类）。这不是接口设计者可以处理的，只能寄希望于调用方传递的代码是能正常执行的。\",\"使用固定顺序获取锁\",\"如同第一个示例那样，固定的顺序上锁就不存在问题。\"]},\"31\":{\"h\":\"灵活的锁\",\"t\":[\"std::unique_lock 是 C++11 引入的一种通用互斥包装器，它相比于 std::lock_guard 更加的灵活。当然，它也更加的复杂，尤其它还可以与我们下一章要讲的条件变量一起使用。使用它可以将之前使用 std::lock_guard 的 swap 改写一下：\",\"void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::unique_lock<std::mutex> lock1{ lhs.m, std::defer_lock }; std::unique_lock<std::mutex> lock2{ rhs.m, std::defer_lock }; std::lock(lock1, lock2); swap(lhs.object, rhs.object); }\",\"解释这段代码最简单的方式就是直接展示标准库的源码，首先，我们要了解 std::defer_lock 是“不获得互斥体的所有权”。没有所有权自然构造函数就不会上锁，但不止如此。我们还要先知道 std::unique_lock 保有的数据成员（都以 MSVC STL 为例）：\",\"private: _Mutex* _Pmtx = nullptr; bool _Owns = false;\",\"如你所见很简单，一个互斥量的指针，还有一个就是表示对象是否拥有互斥量所有权的 bool 类型的对象 _Owns 了。我们前面代码会调用构造函数：\",\"unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept : _Pmtx(_STD addressof(_Mtx)), _Owns(false) {} // construct but don't lock\",\"如你所见，只是初始化了数据成员而已，注意，这个构造函数没有给互斥量上锁，且 _Owns 为 false 表示没有互斥量所有权。并且 std::unique_lock 是有 lock() 、try_lock() 、unlock() 成员函数的，所以可以直接传递给 std::lock、 进行调用。这里还需要提一下 lock() 成员函数的代码：\",\"void lock() { // lock the mutex _Validate(); _Pmtx->lock(); _Owns = true; }\",\"如你所见，正常上锁，并且把 _Owns 设置为 true，即表示当前对象拥有互斥量的所有权。那么接下来看析构函数：\",\"~unique_lock() noexcept { if (_Owns) { _Pmtx->unlock(); } }\",\"必须得是当前对象拥有互斥量的所有权析构函数才会调用 unlock() 解锁互斥量。我们的代码因为调用了 lock ，所以 _Owns 设置为 true ，函数结束对象析构的时候会解锁互斥量。\",\"设计挺奇怪的对吧，这个所有权语义。其实上面的代码还不够简单直接，我们再举个例子：\",\"std::mutex m; int main() { std::unique_lock<std::mutex> lock{ m,std::adopt_lock }; lock.lock(); }\",\"这段代码运行会抛出异常，原因很简单，因为 std::adopt_lock 只是不上锁，但是有所有权，即 _Owns 设置为 true 了，当运行 lock() 成员函数的时候，调用了 _Validate() 进行检测，也就是：\",\"void _Validate() const { // check if the mutex can be locked if (!_Pmtx) { _Throw_system_error(errc::operation_not_permitted); } if (_Owns) { _Throw_system_error(errc::resource_deadlock_would_occur); } }\",\"满足第二个 if，因为 _Owns 为 true 所以抛出异常，别的标准库也都有类似设计。很诡异的设计对吧，正常。除非我们写成：\",\"lock.mutex()->lock();\",\"也就是说 std::unique_lock 要想调用 lock() 成员函数，必须是当前没有所有权。\",\"所以正常的用法其实是，先上锁了互斥量，然后传递 std::adopt_lock 构造 std::unique_lock 对象表示拥有互斥量的所有权，即可在析构的时候正常解锁。如下：\",\"std::mutex m; int main() { m.lock(); std::unique_lock<std::mutex> lock { m,std::adopt_lock }; }\",\"简而言之：\",\"使用 std::defer_lock 构造函数不上锁，要求构造之后上锁\",\"使用 std::adopt_lock 构造函数不上锁，要求在构造之前互斥量上锁\",\"默认构造会上锁，要求构造函数之前和构造函数之后都不能再次上锁\",\"我们前面提到了 std::unique_lock 更加灵活，那么灵活在哪？很简单，它拥有 lock() 和 unlock() 成员函数，所以我们能写出如下代码：\",\"void f() { //code.. std::unique_lock<std::mutex> lock{ m }; // 涉及共享资源的修改的代码... lock.unlock(); // 解锁并释放所有权，析构函数不会再 unlock() //code.. }\",\"而不是像之前 std::lock_guard 一样使用 {}。\",\"另外再聊一聊开销吧，其实倒也还好，多了一个 bool ，内存对齐，x64 环境也就是 16 字节。这都不是最重要的，主要是复杂性和需求，通常建议优先 std::lock_guard，当它无法满足你的需求或者显得代码非常繁琐，那么可以考虑使用 std::unique_lock。\"]},\"32\":{\"h\":\"在不同作用域传递互斥量\",\"t\":[\"首先我们要明白，互斥量满足互斥体 (Mutex)的要求，不可复制不可移动。所谓的在不同作用域传递互斥量，其实只是传递了它们的指针或者引用罢了。可以利用各种类来进行传递，比如前面提到的 std::unique_lock。\",\"std::unique_lock 可以获取互斥量的所有权，而互斥量的所有权可以通过移动操作转移给其他的 std::unique_lock 对象。有些时候，这种转移（就是调用移动构造）是自动发生的，比如当函数返回std::unique_lock 对象。另一种情况就是得显式使用 std::move。\",\"请勿对移动语义和转移所有权抱有错误的幻想，我们说的无非是调用 std::unique_lock 的移动构造罢了：\",\"_NODISCARD_CTOR_LOCK unique_lock(unique_lock&& _Other) noexcept : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns) { _Other._Pmtx = nullptr; _Other._Owns = false; }\",\"将数据成员赋给新对象，原来的置空，这就是所谓的 “所有权”转移，切勿被词语迷惑。\",\"std::unique_lock 是只能移动不可复制的类，它移动即标志其管理的互斥量的所有权转移了。\",\"一种可能的使用是允许函数去锁住一个互斥量，并将互斥量的所有权转移到调用者上，所以调用者可以在这个锁保护的范围内执行代码。\",\"std::unique_lock<std::mutex> get_lock(){ extern std::mutex some_mutex; std::unique_lock<std::mutex> lk{ some_mutex }; return lk; } void process_data(){ std::unique_lock<std::mutex> lk{ get_lock() }; // 执行一些任务... }\",\"return lk 这里会调用移动构造，将互斥量的所有权转移给调用方， process_data 函数结束的时候会解锁互斥量。\",\"我相信你可能对 extern std::mutex some_mutex 有疑问，其实不用感到奇怪，这是一个互斥量的声明，可能别的翻译单元（或 dll 等）有它的定义，成功链接上。我们前面也说了：“所谓的在不同作用域传递互斥量，其实只是传递了它们的指针或者引用罢了”，所以要特别注意互斥量的生存期。\",\"extern 说明符只能搭配变量声明和函数声明（除了类成员或函数形参）。它指定外部链接，而且技术上不影响存储期，但它不能用来定义自动存储期的对象，故所有 extern 对象都具有静态或线程存储期。\",\"如果你简单写一个 std::mutex some_mutex 那么函数 process_data 中的 lk 会持有一个悬垂指针。\",\"举一个使用 extern std::mutex 的完整运行示例。当然，其实理论上你 new std::mutex 也是完全可行...... 🤣🤣\",\"std::unique_lock 是灵活的，同样允许在对象销毁之前就解锁互斥量，调用 unlock() 成员函数即可，不再强调。\"]},\"33\":{\"h\":\"保护共享数据的初始化过程\",\"t\":[\"保护共享数据并非必须使用互斥量，互斥量只是其中一种常见的方式而已，对于一些特殊的场景，也有专门的保护方式，比如对于共享数据的初始化过程的保护。我们通常就不会用互斥量，这会造成很多的额外开销。\",\"我们不想为各位介绍其它乱七八糟的各种保护初始化的方式，我们只介绍三种：双检锁（错误）、使用 std::call_once、静态局部变量初始化从 C++11 开始是线程安全。\",\"双检锁（错误）线程不安全\",\"void f(){ if(!ptr){ // 1 std::lock_guard<std::mutex> lk{ m }; if(!ptr){ // 2 ptr.reset(new some); // 3 } } ptr->do_something(); // 4 }\",\"① 是查看指针是否为空，空才需要初始化，才需要获取锁。指针为空，当获取锁后会再检查一次指针②（这就是双重检查），避免另一线程在第一次检查后再做初始化，并且让当前线程获取锁。\",\"然而这显然没用，因为有潜在的条件竞争。未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步，因此就会产生条件竞争。\",\"简而言之：一个线程知道另一个线程已经在执行③，但是此时还没有创建 some 对象，而只是分配内存对指针写入。那么这个线程在①的时候就不会进入，直接执行了 ptr->do_something()④，得不到正确的结果，因为对象还没构造。\",\"如果你觉得难以理解，那就记住 ptr.reset(new some); 并非是不可打断不可交换的固定指令。\",\"这种错误写法在一些单例中也非常的常见。如果你的同事或上司写出此代码，一般不建议指出，因为不见得你能教会他们，不要“没事找事”，只要不影响自己即可。\",\"C++ 标准委员会也认为处理此问题很重要，所以标准库提供了 std::call_once 和 std::once_flag 来处理这种情况。比起锁住互斥量并显式检查指针，每个线程只需要使用 std::call_once 就可以。使用 std::call_once 比显式使用互斥量消耗的资源更少，特别是当初始化完成之后。\",\"std::shared_ptr<some> ptr; std::once_flag resource_flag; void init_resource(){ ptr.reset(new some); } void foo(){ std::call_once(resource_flag, init_resource); // 线程安全的一次初始化 ptr->do_something(); }\",\"以上代码 std::once_flag 对象是全局命名空间作用域声明，如果你有需要，它也可以是类的成员。用于搭配 std::call_once 使用，保证线程安全的一次初始化。std::call_once 只需要接受可调用 (Callable)对象即可，也不要求一定是函数。\",\"“初始化”，那自然是只有一次。但是 std::call_once 也有一些例外情况（比如异常）会让传入的可调用对象被多次调用，即“多次”初始化：\",\"std::once_flag flag; int n = 0; void f(){ std::call_once(flag, [] { ++n; std::cout << \\\"第\\\" << n << \\\"次调用\\\\n\\\"; throw std::runtime_error(\\\"异常\\\"); }); } int main(){ try{ f(); } catch (std::exception&){} try{ f(); } catch (std::exception&){} }\",\"测试链接。正常情况会保证传入的可调用对象只调用一次，即初始化只有一次。异常之类的是例外。\",\"这种行为很合理，因为异常代表操作失败，需要进行回溯和重置状态，符合语义和设计。\",\"静态局部变量初始化在 C++11 是线程安全\",\"class my_class; inline my_class& get_my_class_instance(){ static my_class instance; // 线程安全的初始化过程 初始化严格发生一次 return instance; }\",\"即使多个线程同时访问 get_my_class_instance 函数，也只有一个线程会执行 instance 的初始化，其它线程会等待初始化完成。这种实现方式是线程安全的，不用担心数据竞争。此方式也在单例中多见，被称作“Meyers Singleton”单例，是简单合理的做法。\",\"其实还有不少其他的做法或者反例，但是觉得没必要再聊了，这些已经足够了，再多下去就冗余了。且本文不是详尽的文档，而是“教程”。\"]},\"34\":{\"h\":\"保护不常更新的数据结构\",\"t\":[\"试想一下，你有一个数据结构存储了用户的设置信息，每次用户打开程序的时候，都要进行读取，且运行时很多地方都依赖这个数据结构需要读取，所以为了效率，我们使用了多线程读写。这个数据结构很少进行改变，而我们知道，多线程读取，是没有数据竞争的，是安全的，但是有些时候又不可避免的有修改和读取都要工作的时候，所以依然必须得使用互斥量进行保护。\",\"然而使用 std::mutex 的开销是过大的，它不管有没有发生数据竞争（也就是就算全是读的情况）也必须是老老实实上锁解锁，只有一个线程可以运行。如果你学过其它语言或者操作系统，相信这个时候就已经想到了：“读写锁”。\",\"C++ 标准库自然为我们提供了： std::shared_timed_mutex（C++14）、 std::shared_mutex（C++17）。它们的区别简单来说，前者支持更多的操作方式，后者有更高的性能优势。\",\"std::shared_mutex 同样支持 std::lock_guard、std::unique_lock。和 std::mutex 做的一样，保证写线程的独占访问。而那些无需修改数据结构的读线程，可以使用 std::shared_lock<std::shared_mutex> 获取访问权，多个线程可以一起读取。\",\"class Settings { private: std::map<std::string, std::string> data_; mutable std::shared_mutex mutex_; // “M&M 规则”：mutable 与 mutex 一起出现 public: void set(const std::string& key, const std::string& value) { std::lock_guard<std::shared_mutex> lock{ mutex_ }; data_[key] = value; } std::string get(const std::string& key) const { std::shared_lock<std::shared_mutex> lock(mutex_); auto it = data_.find(key); return (it != data_.end()) ? it->second : \\\"\\\"; // 如果没有找到键返回空字符串 } };\",\"完整代码。测试链接。标准输出可能交错，但无数据竞争。\",\"std::shared_timed_mutex 具有 std::shared_mutex 的所有功能，并且额外支持超时功能。所以以上代码可以随意更换这两个互斥量。\"]},\"35\":{\"h\":\"\",\"t\":[\"线程对已经上锁的 std::mutex 再次上锁是错误的，这是未定义行为。然而在某些情况下，一个线程会尝试在释放一个互斥量前多次获取，所以提供了std::recursive_mutex。\",\"std::recursive_mutex 是 C++ 标准库提供的一种互斥量类型，它允许同一线程多次锁定同一个互斥量，而不会造成死锁。当同一线程多次对同一个 std::recursive_mutex 进行锁定时，只有在解锁与锁定次数相匹配时，互斥量才会真正释放。但它并不影响不同线程对同一个互斥量进行锁定的情况。不同线程对同一个互斥量进行锁定时，会按照互斥量的规则进行阻塞，\",\"#include <iostream> #include <thread> #include <mutex> std::recursive_mutex mtx; void recursive_function(int count) { // 递归函数，每次递归都会锁定互斥量 mtx.lock(); std::cout << \\\"Locked by thread: \\\" << std::this_thread::get_id() << \\\", count: \\\" << count << std::endl; if (count > 0) { recursive_function(count - 1); // 递归调用 } mtx.unlock(); // 解锁互斥量 } int main() { std::thread t1(recursive_function, 3); std::thread t2(recursive_function, 2); t1.join(); t2.join(); }\",\"运行测试。\",\"lock：线程可以在递归互斥体上重复调用 lock。在线程调用 unlock 匹配次数后，所有权才会得到释放。\",\"unlock：若所有权层数为 1（此线程对 lock() 的调用恰好比 unlock() 多一次 ）则解锁互斥量，否则将所有权层数减少 1。\",\"我们重点的强调了一下这两个成员函数的这个概念，其实也很简单，总而言之就是 unlock 必须和 lock 的调用次数一样，才会真正解锁互斥量。\",\"同样的，我们也可以使用 std::lock_guard、std::unique_lock 帮我们管理 std::recursive_mutex，而非显式调用 lock 与 unlock：\",\"void recursive_function(int count) { std::lock_guard<std::recursive_mutex> lc{ mtx }; std::cout << \\\"Locked by thread: \\\" << std::this_thread::get_id() << \\\", count: \\\" << count << std::endl; if (count > 0) { recursive_function(count - 1); } }\",\"运行测试。\"]},\"36\":{\"h\":\"、 是线程安全的吗？\",\"t\":[\"如果你的标准达到 C++11，要求下列函数是线程安全的：\",\"new 运算符和 delete 运算符的库版本\",\"全局 new 运算符和 delete 运算符的用户替换版本\",\"std::calloc、std::malloc、std::realloc、std::aligned_alloc (C++17 起)、std::free\",\"所以以下函数在多线程运行是线程安全的：\",\"void f(){ T* p = new T{}; delete p; }\",\"内存分配、释放操作是线程安全，构造和析构不涉及共享资源。而局部对象 p 对于每个线程来说是独立的。换句话说，每个线程都有其自己的 p 对象实例，因此它们不会共享同一个对象，自然没有数据竞争。\",\"如果 p 是全局对象（或者外部的，只要可被多个线程读写），多个线程同时对其进行访问和修改时，就可能会导致数据竞争和未定义行为。因此，确保全局对象的线程安全访问通常需要额外的同步措施，比如互斥量或原子操作。\",\"T* p = nullptr; void f(){ p = new T{}; // 存在数据竞争 delete p; }\",\"即使 p 是局部对象，如果构造函数（析构同理）涉及读写共享资源，那么一样存在数据竞争，需要进行额外的同步措施进行保护。\",\"int n = 1; struct X{ X(int v){ ::n += v; } }; void f(){ X* p = new X{ 1 }; // 存在数据竞争 delete p; }\",\"一个直观的展示是，我们可以在构造函数中使用 std::cout，看到无序的输出，例子。\",\"值得注意的是，如果是自己重载 operator new、operator delete 替换了库的全局版本，那么它的线程安全就要我们来保证。\",\"// 全局的 new 运算符，替换了库的版本 void* operator new (std::size_t count){ return ::operator new(count); }\",\"以上代码是线程安全的，因为 C++11 保证了 new 运算符的库版本，即 ::operator new 是线程安全的，我们直接调用它自然不成问题。如果你需要更多的操作，就得使用互斥量之类的方式保护了。\",\"总而言之，new 表达式线程安全要考虑三方面：operator new、构造函数、修改指针。\",\"delete 表达式线程安全考虑两方面：operator delete、析构函数。\",\"C++ 只保证了 operator new、operator delete 这两个方面的线程安全（不包括用户定义的），其它方面就得自己保证了。前面的内容也都提到了。\"]},\"37\":{\"h\":\"线程存储期\",\"t\":[\"线程存储期（也有人喜欢称作“线程局部存储”）的概念源自操作系统，是一种非常古老的机制，广泛应用于各种编程语言。线程存储期的对象在线程开始时分配，并在线程结束时释放。每个线程拥有自己独立的对象实例，互不干扰。在 C++11中，引入了thread_local关键字，用于声明具有线程存储期的对象。不少开发者喜欢直接将声明为线程存储期的对象称为：线程变量；也与全局变量、CPU 变量，在一起讨论。\",\"以下是一段示例代码，展示了 thread_local 关键字的使用：\",\"int global_counter = 0; thread_local int thread_local_counter = 0; void print_counters(){ std::cout << \\\"global：\\\" << global_counter++ << '\\\\n'; std::cout << \\\"thread_local：\\\" << thread_local_counter++ << '\\\\n'; } int main(){ std::thread{ print_counters }.join(); std::thread{ print_counters }.join(); }\",\"运行结果：\",\"global：0 thread_local：0 global：1 thread_local：0\",\"这段代码很好的展示了 thread_local 关键字的使用以及它的作用。每一个线程都有独立的 thread_local_counter 对象，它们不是同一个。\",\"我知道你会有问题：“那么 C++11 之前呢？”那时开发者通常使用 POSIX 线程（Pthreads）或 Win32 线程的接口，或者依赖各家编译器的扩展。例如：\",\"POSIX：使用 pthread_key_t 和相关的函数（ pthread_key_create、pthread_setspecific、pthread_getspecific 和pthread_key_delete）来管理线程局部存储。\",\"Win32：使用 TLS（Thread Local Storage）机制，通过函数 TlsAlloc、TlsSetValue、TlsGetValue 和 TlsFree 来实现线程局部存储。\",\"GCC：使用 __thread 。\",\"MSVC：使用 __declspec(thread)。\",\"POSIX 与 Win32 接口的就不再介绍了，有兴趣参见我们的链接即可。我们就拿先前的代码改成使用 GCC 与 MSVC 的编译器扩展即可。\",\"__thread int thread_local_counter = 0; // GCC __declspec(thread) int thread_local_counter = 0; // MSVC\",\"MSVC 无法使用 GCC 的编译器扩展，GCC 也肯定无法使用 MSVC 的扩展，不过 Clang 编译器可以，它支持 __thread 与 __declspec(thread) 两种。Clang 默认情况就支持 GCC 的编译器扩展，如果要支持 MSVC，需要设置 -fms-extensions 编译选项。\",\"__declspec(thread) 运行测试\",\"__thread 运行测试\",\"要注意的是，这些扩展并不是标准的 C++ 语言特性，它们的跨平台性和可移植性较差，我们应当使用 C++ 标准的 thread_local。\",\"了解其它 API 以及编译器扩展有助于理解历史上线程存储期的演进。同时扩展知识面。\"]},\"38\":{\"h\":\"注意事项\",\"t\":[\"需要注意的是，在 MSVC 的实现中，如果 std::async 策略为 launch::async ，但却并不是每次都创建一个新的线程，而是从线程池获取线程。这意味着无法保证线程局部变量在任务完成时会被销毁。如果线程被回收并用于新的 std::async 调用，则旧的线程局部变量仍然存在。因此，建议不要将线程局部变量与 std::async 一起使用。文档。\",\"虽然还没有讲 std::async ，不过还是可以注意一下这个问题，我们用一个简单的示例为你展示：\",\"int n = 0; struct X { ~X() { ++n; } }; thread_local X x{}; void use_thread_local_x() { // 如果不写此弃值表达式，那么在 Gcc 与 Clang 编译此代码，会优化掉 x (void)x; } int main() { std::cout << \\\"使用 std::thread: \\\\n\\\"; std::thread{ use_thread_local_x }.join(); std::cout << n << '\\\\n'; std::cout << \\\"使用 std::async: \\\\n\\\"; std::async(std::launch::async, use_thread_local_x); std::cout << n << '\\\\n'; }\",\"在不同编译器上的输出结果：\",\"Linux/Windows GCC、Clang：会输出 1、2，因为线程变量 x 在每个任务中被正确销毁析构。\",\"Windows MSVC：会输出 1、1，因为线程被线程池复用，线程依然活跃，线程变量 x 也就还未释放。\"]},\"39\":{\"h\":\"CPU 变量\",\"t\":[\"CPU 变量的概念很好理解。就像线程变量为每个线程提供独立的对象实例，互不干扰一样，CPU 变量也是如此。在创建 CPU 变量时，系统上的每个 CPU [2] 都会获得该变量的一个副本。\",\"在 Linux 内核中，从 2.6[3] 版本开始引入了 Per-CPU 变量（Per-CPU variables）功能。Per-CPU 变量是为每个处理器单独分配的变量副本，旨在减少多处理器访问共享数据时的同步开销，提升性能。每个处理器只访问自己的变量副本，不需要进行同步操作，避免了数据竞争，增强了并行处理能力。\",\"在 Windows 内核中，没有直接对应的 Per-CPU 变量机制。\",\"本节是偏向概念的认识，而非实际进行内核编程，C++ 语言层面也并未提供此抽象。理解 CPU 变量的概念对于系统编程和内核开发非常重要。这些概念在面试和技术讨论中常常出现，掌握这些知识不仅有助于应对面试问题，也能提升对多处理器系统性能优化的理解。\"]},\"40\":{\"h\":\"\",\"t\":[\"在并发编程中，不同的变量有不同的使用场景和特点。以下是局部变量、全局变量、线程变量、CPU变量的对比：\"]},\"41\":{\"h\":\"局部变量（不考虑静态局部）\",\"t\":[\"它拥有自动存储期，随作用域开始分配，结束时释放。每个线程、每次调用都有独立实例，完全独立，几乎无需同步。\"]},\"42\":{\"h\":\"全局变量\",\"t\":[\"拥有 静态（static）存储期，它的存储在程序开始时分配，并在程序结束时解分配；且它在主函数执行之前进行初始化。\"]},\"43\":{\"h\":\"线程变量\",\"t\":[\"拥有 线程（thread） 存储期。它的存储在线程开始时分配，并在线程结束时解分配。每个线程拥有它自身的对象实例。只有声明为 thread_local 的对象拥有此存储期（不考虑非标准用法）。它的初始化需要考虑局部与非局部两种情况： \",\"非局部变量：所有具有线程局部存储期的非局部变量的初始化，会作为线程启动的一部分进行，并按顺序早于线程函数的执行开始。\",\"静态局部变量[4]：控制流首次经过它的声明时才会被初始化（除非它被零初始化或常量初始化）。在其后所有的调用中，声明都会被跳过。\"]},\"44\":{\"h\":\"CPU变量\",\"t\":[\"它在标准 C++ 中无对应抽象实现，是操作系统内核功能。它主要依赖于当前系统内核来进行使用，也无法跨平台。基本概念与线程变量类似：CPU 变量是为每个处理器单独分配的变量副本。\",\"局部变量适合临时数据，作用域结束自动释放，几乎[5]无需同步。\",\"全局变量适合整个程序的共享状态，但需要使用同步设施进行保护。\",\"线程变量适合线程的独立状态，通常[6]无需同步。\",\"CPU 变量的使用是少见的，主要用于内核开发和追求极致性能的高并发场景，减少 CPU 同步开销。\",\"总而言之，结合实际使用即可，把这四种变量拿出来进行对比，增进理解，加深印象。\"]},\"45\":{\"h\":\"\",\"t\":[\"本章讨论了多线程的共享数据引发的恶性条件竞争会带来的问题。并说明了可以使用互斥量（std::mutex）保护共享数据，并且要注意互斥量上锁的“粒度”。C++标准库提供了很多工具，包括管理互斥量的管理类（std::lock_guard），但是互斥量只能解决它能解决的问题，并且它有自己的问题（死锁）。同时我们讲述了一些避免死锁的方法和技术。还讲了一下互斥量所有权转移。然后讨论了面对不同情况保护共享数据的不同方式，使用 std::call_once() 保护共享数据的初始化过程，使用读写锁（std::shared_mutex）保护不常更新的数据结构。以及特殊情况可能用到的互斥量 recursive_mutex，有些人可能喜欢称作：递归锁。然后聊了一下 new、delete 运算符的库函数实际是线程安全的。最后介绍了一下线程存储期、CPU 变量，和各种变量进行了一个对比。\",\"下一章，我们将开始讲述同步操作，会使用到 Futures、条件变量等设施。\",\"\\\"临界区\\\"指的是一个访问共享资源的程序片段，而这些共享资源又无法同时被多个线程访问的特性。在临界区中，通常会使用同步机制，比如我们要讲的互斥量（Mutex）。 ↩︎\",\"“每个 CPU”，指的是系统中的每个物理处理器或每个逻辑处理器（如果超线程被启用）。 ↩︎\",\"Linux 内核版本历史。 ↩︎\",\"“静态局部变量”：是指拥有静态或线程存储期的局部变量。 ↩︎\",\"之所以说是“几乎”，是因为局部对象的构造、析构，或其它成员函数也可能修改共享数据、全局状态。如果它们不是线程安全的，同样可能产生数据竞争，例如，某类型 X 的构造函数会自增一个全局变量 n，那么即使局部对象本身是独立的，但由于构造函数修改了共享数据，依然会产生数据竞争。不过实践中这种情况较少，即使涉及到全局的状态，通常其本身也是线程安全的，例如前文提到的 new、delete 线程安全的问题。 ↩︎\",\"之所以说“通常”而不是一定，是因为理论上线程变量一样可能产生数据竞争（例如有一个全局的指针指向了一个线程局部变量，其它线程通过这个指针读写线程局部变量而不附加同步，自然会产生数据竞争），只不过实践中通常不会那样做，所以我们不额外提及。 ↩︎\"]},\"46\":{\"h\":\"同步操作\",\"t\":[\"\\\"同步操作\\\"是指在计算机科学和信息技术中的一种操作方式，其中不同的任务或操作按顺序执行，一个操作完成后才能开始下一个操作。在多线程编程中，各个任务通常需要通过同步设施进行相互协调和等待，以确保数据的一致性和正确性。\",\"本章的主要内容有：\",\"条件变量\",\"std::future 等待异步任务\",\"在规定时间内等待\",\"Qt 实现异步任务的示例\",\"其它 C++20 同步设施：信号量、闩与屏障\",\"本章将讨论如何使用条件变量等待事件，介绍 future 等标准库设施用作同步操作，使用Qt+CMake 构建一个项目展示多线程的必要性，介绍 C++20 引入的新的同步设施。\"]},\"47\":{\"h\":\"等待事件或条件\",\"t\":[\"假设你正在一辆夜间运行的地铁上，那么你要如何在正确的站点下车呢？\",\"一直不休息，每一站都能知道，这样就不会错过你要下车的站点，但是这会很疲惫。\",\"可以看一下时间，估算一下地铁到达目的地的时间，然后设置一个稍早的闹钟，就休息。这个方法听起来还行，但是你可能被过早的叫醒，甚至估算错误导致坐过站，又或者闹钟没电了睡过站。\",\"事实上最简单的方式是，到站的时候有人或者其它东西能将你叫醒（比如手机的地图，到达设置的位置就提醒）。\",\"这和线程有什么关系呢？其实第一种方法就是在说”忙等待（busy waiting）”也称“自旋“。\",\"bool flag = false; std::mutex m; void wait_for_flag(){ std::unique_lock<std::mutex> lk{ m }; while (!flag){ lk.unlock(); // 1 解锁互斥量 lk.lock(); // 2 上锁互斥量 } }\",\"第二种方法就是加个延时，这种实现进步了很多，减少浪费的执行时间，但很难确定正确的休眠时间。这会影响到程序的行为，在需要快速响应的程序中就意味着丢帧或错过了一个时间片。循环中，休眠②前函数对互斥量解锁①，再休眠结束后再对互斥量上锁，让另外的线程有机会获取锁并设置标识（因为修改函数和等待函数共用一个互斥量）。\",\"void wait_for_flag(){ std::unique_lock<std::mutex> lk{ m }; while (!flag){ lk.unlock(); // 1 解锁互斥量 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 2 休眠 lk.lock(); // 3 上锁互斥量 } }\",\"第三种方式（也是最好的）实际上就是使用条件变量了。通过另一线程触发等待事件的机制是最基本的唤醒方式，这种机制就称为“条件变量”。\",\"C++ 标准库对条件变量有两套实现：std::condition_variable 和 std::condition_variable_any，这两个实现都包含在 <condition_variable> 头文件中。\",\"condition_variable_any 类是 std::condition_variable 的泛化。相对于只在 std::unique_lock<std::mutex> 上工作的 std::condition_variable，condition_variable_any 能在任何满足可基本锁定(BasicLockable)要求的锁上工作，所以增加了 _any 后缀。显而易见，这种区分必然是 any 版更加通用但是却有更多的性能开销。所以通常首选std::condition_variable。有特殊需求，才会考虑 std::condition_variable_any。\",\"std::mutex mtx; std::condition_variable cv; bool arrived = false; void wait_for_arrival() { std::unique_lock<std::mutex> lck(mtx); cv.wait(lck, []{ return arrived; }); // 等待 arrived 变为 true std::cout << \\\"到达目的地，可以下车了！\\\" << std::endl; } void simulate_arrival() { std::this_thread::sleep_for(std::chrono::seconds(5)); // 模拟地铁到站，假设5秒后到达目的地 { std::lock_guard<std::mutex> lck(mtx); arrived = true; // 设置条件变量为 true，表示到达目的地 } cv.notify_one(); // 通知等待的线程 }\",\"运行测试。更换为 std::condition_variable_any 效果相同。\",\"std::mutex mtx: 创建了一个互斥量，用于保护共享数据的访问，确保在多线程环境下的数据同步。\",\"std::condition_variable cv: 创建了一个条件变量，用于线程间的同步，当条件不满足时，线程可以等待，直到条件满足时被唤醒。\",\"bool arrived = false: 设置了一个标志位，表示是否到达目的地。\",\"在 wait_for_arrival 函数中：\",\"std::unique_lock<std::mutex> lck(mtx): 使用互斥量创建了一个独占锁。\",\"cv.wait(lck, []{ return arrived; }): 阻塞当前线程，释放（unlock）锁，直到条件被满足。\",\"一旦条件满足，即 arrived 变为 true，并且条件变量 cv 被唤醒（包括虚假唤醒），那么当前线程会重新获取锁（lock），并执行后续的操作。\",\"在 simulate_arrival 函数中：\",\"std::this_thread::sleep_for(std::chrono::seconds(5)): 模拟地铁到站，暂停当前线程 5 秒。\",\"设置 arrived 为 true，表示到达目的地。\",\"cv.notify_one(): 唤醒一个等待条件变量的线程。\",\"这样，当 simulate_arrival 函数执行后，arrived 被设置为 true，并且通过 cv.notify_one() 唤醒了等待在条件变量上的线程，从而使得 wait_for_arrival 函数中的等待结束，可以执行后续的操作，即输出提示信息。\",\"条件变量的 wait 成员函数有两个版本，以上代码使用的就是第二个版本，传入了一个谓词。\",\"void wait(std::unique_lock<std::mutex>& lock); // 1 template<class Predicate> void wait(std::unique_lock<std::mutex>& lock, Predicate pred); // 2\",\"②等价于：\",\"while (!pred()) wait(lock);\",\"第二个版本只是对第一个版本的包装，等待并判断谓词，会调用第一个版本的重载。这可以避免“虚假唤醒（spurious wakeup）”。\",\"条件变量虚假唤醒是指在使用条件变量进行线程同步时，有时候线程可能会在没有收到通知的情况下被唤醒。问题取决于程序和系统的具体实现。解决方法很简单，在循环中等待并判断条件可一并解决。使用 C++ 标准库则没有这个烦恼了。\",\"我们也可以简单看一下 MSVC STL 的源码实现：\",\"void wait(unique_lock<mutex>& _Lck) noexcept { _Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx()); } template <class _Predicate> void wait(unique_lock<mutex>& _Lck, _Predicate _Pred) { while (!_Pred()) { wait(_Lck); } }\"]},\"48\":{\"h\":\"线程安全的队列\",\"t\":[\"在本节中，我们介将绍一个更为复杂的示例，以巩固我们对条件变量的学习。为了实现一个线程安全的队列，我们需要考虑以下两个关键点：\",\"当执行 push 操作时，需要确保没有其他线程正在执行 push 或 pop 操作；同样，在执行 pop 操作时，也需要确保没有其他线程正在执行 push 或 pop 操作。\",\"当队列为空时，不应该执行 pop 操作。因此，我们需要使用条件变量来传递一个谓词，以确保在执行 pop 操作时队列不为空。\",\"基于以上思考，我们设计了一个名为 threadsafe_queue 的模板类，如下：\",\"template<typename T> class threadsafe_queue { mutable std::mutex m; // 互斥量，用于保护队列操作的独占访问 std::condition_variable data_cond; // 条件变量，用于在队列为空时等待 std::queue<T> data_queue; // 实际存储数据的队列 public: threadsafe_queue() {} void push(T new_value) { { std::lock_guard<std::mutex> lk { m }; data_queue.push(new_value); } data_cond.notify_one(); } // 从队列中弹出元素（阻塞直到队列不为空） void pop(T& value) { std::unique_lock<std::mutex> lk{ m }; data_cond.wait(lk, [this] {return !data_queue.empty(); }); value = data_queue.front(); data_queue.pop(); } // 从队列中弹出元素（阻塞直到队列不为空），并返回一个指向弹出元素的 shared_ptr std::shared_ptr<T> pop() { std::unique_lock<std::mutex> lk{ m }; data_cond.wait(lk, [this] {return !data_queue.empty(); }); std::shared_ptr<T> res { std::make_shared<T>(data_queue.front()) }; data_queue.pop(); return res; } bool empty()const { std::lock_guard<std::mutex> lk (m); return data_queue.empty(); } };\",\"请无视我们省略的构造、赋值、交换、try_xx 等操作。以上示例已经足够。\",\"光写好了肯定不够，我们还得测试运行，我们可以写一个经典的：”生产者消费者模型“，也就是一个线程 push ”生产“，一个线程 pop ”消费“。\",\"void producer(threadsafe_queue<int>& q) { for (int i = 0; i < 5; ++i) { q.push(i); } } void consumer(threadsafe_queue<int>& q) { for (int i = 0; i < 5; ++i) { int value{}; q.pop(value); } }\",\"两个线程分别运行 producer 与 consumer，为了观测运行我们可以为 push 与 pop 中增加打印语句：\",\"std::cout << \\\"push:\\\" << new_value << std::endl; std::cout << \\\"pop:\\\" << value << std::endl;\",\"可能的运行结果是：\",\"push:0 pop:0 push:1 pop:1 push:2 push:3 push:4 pop:2 pop:3 pop:4\",\"这很正常，到底哪个线程会抢到 CPU 时间片持续运行，是系统调度决定的，我们只需要保证一开始提到的两点就行了：\",\"push 与 pop 都只能单独执行；当队列为空时，不执行 pop 操作。\",\"我们可以给一个简单的示意图帮助你理解这段运行结果：\",\"初始状态：队列为空 +---+---+---+---+---+ Producer 线程插入元素 0： +---+---+---+---+---+ | 0 | | | | | Consumer 线程弹出元素 0： +---+---+---+---+---+ | | | | | | Producer 线程插入元素 1： +---+---+---+---+---+ | 1 | | | | | Consumer 线程弹出元素 1： +---+---+---+---+---+ | | | | | | Producer 线程插入元素 2： +---+---+---+---+---+ | | 2 | | | | Producer 线程插入元素 3： +---+---+---+---+---+ | | 2 | 3 | | | Producer 线程插入元素 4： +---+---+---+---+---+ | | 2 | 3 | 4 | | Consumer 线程弹出元素 2： +---+---+---+---+---+ | | | 3 | 4 | | Consumer 线程弹出元素 3： +---+---+---+---+---+ | | | | 4 | | Consumer 线程弹出元素 4： +---+---+---+---+---+ | | | | | | 队列为空，所有元素已被弹出\",\"到此，也就可以了。\"]},\"49\":{\"h\":\"使用条件变量实现后台提示音播放\",\"t\":[\"一个常见的场景是：当你的软件完成了主要功能后，领导可能突然要求添加一些竞争对手产品的功能。比如领导看到了人家的设备跑起来总是有一些播报，说明当前的情况，执行的过程，或者报错了也会有提示音说明。于是就想让我们的程序也增加“语音提示”的功能。此时，你需要考虑如何在程序运行到不同状态时添加适当的语音播报，并且确保这些提示音的播放不会影响其他功能的正常运行。\",\"为了不影响程序的流畅执行，提示音的播放显然不能占据业务线程的资源。我们需要额外启动一个线程来专门处理这个任务。\",\"但是，大多数的提示音播放都是短暂且简单。如果每次播放提示音时都新建一个线程，且不说创建线程也需要大量时间，可能影响业务正常的执行任务的流程，就光是其频繁创建线程的开销也是不能接受的。\",\"因此，更合理的方案是：在程序启动时，就启动一个专门用于播放提示音的线程。当没有需要播放的提示时，该线程会一直处于等待状态；一旦有提示音需要播放，线程就被唤醒，完成播放任务。\",\"具体来说，我们可以通过条件变量来实现这一逻辑，核心是监控一个音频队列。我们可以封装一个类型，包含以下功能：\",\"一个成员函数在对象构造时就启动，使用条件变量监控队列是否为空，互斥量确保共享资源的同步。如果队列中有任务，就取出并播放提示音；如果队列为空，则线程保持阻塞状态，等待新的任务到来。\",\"提供一个外部函数，以供在需要播放提示音的时候调用它，向队列添加新的元素，该函数需要通过互斥量来保护数据一致性，并在成功添加任务后唤醒条件变量，通知播放线程执行任务。\",\"这种设计通过合理利用条件变量和互斥量，不仅有效减少了 CPU 的无效开销，还能够确保主线程的顺畅运行。它不仅适用于提示音的播放，还能扩展用于其他类似的后台任务场景。\",\"我们引入 SFML 三方库进行声音播放，然后再自己进行上层封装。\",\"class AudioPlayer { public: AudioPlayer() : stop{ false }, player_thread{ &AudioPlayer::playMusic, this } {} ~AudioPlayer() { // 等待队列中所有音乐播放完毕 while (!audio_queue.empty()) { std::this_thread::sleep_for(50ms); } stop = true; cond.notify_all(); if (player_thread.joinable()) { player_thread.join(); } } void addAudioPath(const std::string& path) { std::lock_guard<std::mutex> lock{ mtx }; // 互斥量确保了同一时间不会有其它地方在操作共享资源（队列） audio_queue.push(path); // 为队列添加元素 表示有新的提示音需要播放 cond.notify_one(); // 通知线程新的音频 } private: void playMusic() { while (!stop) { std::string path; { std::unique_lock<std::mutex> lock{ mtx }; cond.wait(lock, [this] { return !audio_queue.empty() || stop; }); if (audio_queue.empty()) return; // 防止在对象为空时析构出错 path = audio_queue.front(); // 从队列中取出元素 audio_queue.pop(); // 取出后就删除元素，表示此元素已被使用 } if (!music.openFromFile(path)) { std::cerr << \\\"无法加载音频文件: \\\" << path << std::endl; continue; // 继续播放下一个音频 } music.play(); // 等待音频播放完毕 while (music.getStatus() == sf::SoundSource::Playing) { sf::sleep(sf::seconds(0.1f)); // sleep 避免忙等占用 CPU } } } std::atomic<bool> stop; // 控制线程的停止与退出， std::thread player_thread; // 后台执行音频任务的专用线程 std::mutex mtx; // 保护共享资源 std::condition_variable cond; // 控制线程等待和唤醒，当有新任务时通知音频线程 std::queue<std::string> audio_queue; // 音频任务队列，存储待播放的音频文件路径 sf::Music music; // SFML 音频播放器，用于加载和播放音频文件 };\",\"该代码实现了一个简单的后台音频播放类型，通过条件变量和互斥量确保播放线程 playMusic 只在只在有音频任务需要播放时工作（当外部通过调用 addAudioPath() 向队列添加播放任务时）。在没有任务时，线程保持等待状态，避免占用 CPU 资源影响主程序的运行。\"]},\"50\":{\"h\":\"注意\",\"t\":[\"其实这段代码还存在着一个初始化顺序导致的问题，见 #27\",\"此外，关于提示音的播报，为了避免每次都手动添加路径，我们可以创建一个音频资源数组，便于使用：\",\"static constexpr std::array soundResources{ \\\"./sound/01初始化失败.ogg\\\", \\\"./sound/02初始化成功.ogg\\\", \\\"./sound/03试剂不足，请添加.ogg\\\", \\\"./sound/04试剂已失效，请更新.ogg\\\", \\\"./sound/05清洗液不足，请添加.ogg\\\", \\\"./sound/06废液桶即将装满，请及时清空.ogg\\\", \\\"./sound/07废料箱即将装满，请及时清空.ogg\\\", \\\"./sound/08激发液A液不足，请添加.ogg\\\", \\\"./sound/09激发液B液不足，请添加.ogg\\\", \\\"./sound/10反应杯不足，请添加.ogg\\\", \\\"./sound/11检测全部完成.ogg\\\" };\",\"为了提高代码的可读性，我们还可以使用一个枚举类型来表示音频资源的索引：\",\"enum SoundIndex { InitializationFailed, InitializationSuccessful, ReagentInsufficient, ReagentExpired, CleaningAgentInsufficient, WasteBinAlmostFull, WasteContainerAlmostFull, LiquidAInsufficient, LiquidBInsufficient, ReactionCupInsufficient, DetectionCompleted, SoundCount // 总音频数量，用于计数 };\",\"注\",\"需要注意的是 SFML不支持 .mp3 格式的音频文件，大家可以使用 ffmpeg 或者其它软件网站将音频转换为支持的格式。\",\"SFML 自 2.6 版本开始通过 minimp3 支持 .mp3 格式的音频文件。不过新版本的 SFML 也要求更高版本的工具链。\",\"如果只是为了播放 .mp3 的音乐，也可以直接使用 minimp3 。\",\"如果是测试使用，不知道去哪生成这些语音播报，我们推荐 tts-vue。\",\"我们的代码也可以在 Linux 中运行，并且整体仅需 C++11 标准（除了 soundResources 数组）。 SFML 依赖于 FLAC 和 OpenAL 这两个库。官网上下载的 windows 版本的 SFML 已包含这些依赖，但在 Linux 上需要用户自行下载并安装它们。如：\",\"sudo apt-get install libflac-dev sudo apt-get install libopenal-dev\",\"提示\",\"这种设计思路非常常见。例如，USBMonitor-cpp 是一个跨平台的 C++ 库，用于监测 U 盘插拔状态变化。感兴趣的话可以参考该项目，进一步学习和实践。\"]},\"51\":{\"h\":\"使用\",\"t\":[\"举个例子：我们在车站等车，你可能会做一些别的事情打发时间，比如学习现代 C++ 模板教程、观看 mq白 的视频教程、玩手机等。不过，你始终在等待一件事情：车到站。\",\"C++ 标准库将这种事件称为 future。它用于处理线程中需要等待某个事件的情况，线程知道预期结果。等待的同时也可以执行其它的任务。\",\"C++ 标准库有两种 future，都声明在 <future> 头文件中：独占的 std::future 、共享的 std::shared_future。它们的区别与 std::unique_ptr 和 std::shared_ptr 类似。std::future 只能与单个指定事件关联，而 std::shared_future 能关联多个事件。它们都是模板，它们的模板类型参数，就是其关联的事件（函数）的返回类型。当多个线程需要访问一个独立 future 对象时， 必须使用互斥量或类似同步机制进行保护。而多个线程访问同一共享状态，若每个线程都是通过其自身的 shared_future 对象副本进行访问，则是安全的。\",\"最简单有效的使用是，我们先前讲的 std::thread 在线程中执行任务是没有返回值的，这个问题就能使用 future 解决。\"]},\"52\":{\"h\":\"创建异步任务获取返回值\",\"t\":[\"假设需要执行一个耗时任务并获取其返回值，但是并不急切的需要它。那么就可以启动新线程计算，然而 std::thread 没提供直接从线程获取返回值的机制。所以我们可以使用 std::async 函数模板。\",\"使用 std::async 启动一个异步任务，它会返回一个 std::future 对象，这个对象和任务关联，将持有最终计算出来的结果。当需要任务执行完的结果的时候，只需要调用 get() 成员函数，就会阻塞直到 future 为就绪为止（即任务执行完毕），返回执行结果。valid() 成员函数检查 future 当前是否关联共享状态，即是否当前关联任务。还未关联，或者任务已经执行完（调用了 get()、set()），都会返回 false。\",\"#include <iostream> #include <thread> #include <future> // 引入 future 头文件 int task(int n) { std::cout << \\\"异步任务 ID: \\\" << std::this_thread::get_id() << '\\\\n'; return n * n; } int main() { std::future<int> future = std::async(task, 10); std::cout << \\\"main: \\\" << std::this_thread::get_id() << '\\\\n'; std::cout << std::boolalpha << future.valid() << '\\\\n'; // true std::cout << future.get() << '\\\\n'; std::cout << std::boolalpha << future.valid() << '\\\\n'; // false }\",\"运行测试。\",\"与 std::thread 一样，std::async 支持任意可调用(Callable)对象，以及传递调用参数。包括支持使用 std::ref ，以及支持只能移动的类型。我们下面详细聊一下 std::async 参数传递的事。\",\"struct X{ int operator()(int n)const{ return n * n; } }; struct Y{ int f(int n)const{ return n * n; } }; void f(int& p) { std::cout << &p << '\\\\n'; } int main(){ Y y; int n = 0; auto t1 = std::async(X{}, 10); auto t2 = std::async(&Y::f,&y,10); auto t3 = std::async([] {}); auto t4 = std::async(f, std::ref(n)); std::cout << &n << '\\\\n'; }\",\"运行测试。\",\"如你所见，它支持所有可调用(Callable)对象，并且也是默认按值复制，必须使用 std::ref 才能传递引用。并且它和 std::thread 一样，内部会将保有的参数副本转换为右值表达式进行传递，这是为了那些只支持移动的类型，左值引用没办法引用右值表达式，所以如果不使用 std::ref，这里 void f(int&) 就会导致编译错误，如果是 void f(const int&) 则可以通过编译，不过引用的不是我们传递的局部对象。\",\"void f(const int& p) {} void f2(int& p ){} int n = 0; std::async(f, n); // OK! 可以通过编译，不过引用的并非是局部的n std::async(f2, n); // Error! 无法通过编译\",\"我们来展示使用 std::move ，也就是移动传递参数并接受返回值：\",\"struct move_only{ move_only() { std::puts(\\\"默认构造\\\"); } move_only(move_only&&)noexcept { std::puts(\\\"移动构造\\\"); } move_only& operator=(move_only&&) noexcept { std::puts(\\\"移动赋值\\\"); return *this; } move_only(const move_only&) = delete; }; move_only task(move_only x){ std::cout << \\\"异步任务 ID: \\\" << std::this_thread::get_id() << '\\\\n'; return x; } int main(){ move_only x; std::future<move_only> future = std::async(task, std::move(x)); std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout << \\\"main\\\\n\\\"; move_only result = future.get(); // 等待异步任务执行完毕 }\",\"运行测试。\",\"如你所见，它支持只移动类型，我们将参数使用 std::move 传递，接收参数的时候直接调用 get 函数即可。\",\"接下来我们聊 std::async 的执行策略，我们前面一直没有使用，其实就是在传递可调用对象与参数之前传递枚举值罢了：\",\"std::launch::async 在不同线程上执行异步任务。\",\"std::launch::deferred 惰性求值，不创建线程，等待 future 对象调用 wait 或 get 成员函数的时候执行任务。\",\"而我们先前一直没有写明这个参数，是因为 std::async 函数模板有两个重载，不给出执行策略就是以：std::launch::async | std::launch::deferred 调用另一个重载版本（这一点中在源码中很明显），此策略表示由实现选择到底是否创建线程执行异步任务。典型情况是，如果系统资源充足，并且异步任务的执行不会导致性能问题，那么系统可能会选择在新线程中执行任务。但是，如果系统资源有限，或者延迟执行可以提高性能或节省资源，那么系统可能会选择延迟执行。\",\"如果你阅读 libstdc++ 的代码，会发现的确如此。\",\"然而值得注意的是，在 MSVC STL 的实现中，launch::async | launch::deferred 与 launch::async 执行策略毫无区别，源码如下：\",\"template <class _Ret, class _Fty> _Associated_state<typename _P_arg_type<_Ret>::type>* _Get_associated_state(launch _Psync, _Fty&& _Fnarg) { // construct associated asynchronous state object for the launch type switch (_Psync) { // select launch type case launch::deferred: return new _Deferred_async_state<_Ret>(_STD forward<_Fty>(_Fnarg)); case launch::async: // TRANSITION, fixed in vMajorNext, should create a new thread here default: return new _Task_async_state<_Ret>(_STD forward<_Fty>(_Fnarg)); } }\",\"且 _Task_async_state 会通过 ::Concurrency::create_task[1] 从线程池中获取线程并执行任务返回包装对象。\",\"简而言之，使用 std::async，只要不是 launch::deferred 策略，那么 MSVC STL 实现中都是必然在线程中执行任务。因为是线程池，所以执行新任务是否创建新线程，任务执行完毕线程是否立即销毁，不确定。\",\"我们来展示一下：\",\"void f(){ std::cout << std::this_thread::get_id() << '\\\\n'; } int main(){ std::cout << std::this_thread::get_id() << '\\\\n'; auto f1 = std::async(std::launch::deferred, f); f1.wait(); // 在 wait() 或 get() 调用时执行，不创建线程 auto f2 = std::async(std::launch::async,f); // 创建线程执行异步任务 auto f3 = std::async(std::launch::deferred | std::launch::async, f); // 实现选择的执行方式 }\",\"运行测试。\",\"其实到此基本就差不多了，我们再介绍两个常见问题即可：\",\"如果从 std::async 获得的 std::future 没有被移动或绑定到引用，那么在完整表达式结尾， std::future 的**析构函数将阻塞，直到到异步任务完成**。因为临时对象的生存期就在这一行，而对象生存期结束就会调用调用析构函数。\",\"std::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f() std::async(std::launch::async, []{ g(); }); // f() 完成前不开始\",\"如你所见，这并不能创建异步任务，它会阻塞，然后逐个执行。\",\"被移动的 std::future 没有所有权，失去共享状态，不能调用 get、wait 成员函数。\",\"auto t = std::async([] {}); std::future<void> future{ std::move(t) }; t.wait(); // Error! 抛出异常\",\"如同没有线程资源所有权的 std::thread 对象调用 join() 一样错误，这是移动语义的基本语义逻辑。\"]},\"53\":{\"h\":\"与\",\"t\":[\"类模板 std::packaged_task 包装任何可调用(Callable)目标（函数、lambda 表达式、bind 表达式或其它函数对象），使得能异步调用它。其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。\",\"通常它会和 std::future 一起使用，不过也可以单独使用，我们一步一步来：\",\"std::packaged_task<double(int, int)> task([](int a, int b){ return std::pow(a, b); }); task(10, 2); // 执行传递的 lambda，但无法获取返回值\",\"它有 operator() 的重载，它会执行我们传递的可调用(Callable)对象，不过这个重载的返回类型是 void没办法获取返回值。\",\"如果想要异步的获取返回值，我们需要在调用 operator() 之前，让它和 future 关联，然后使用 future.get()，也就是：\",\"std::packaged_task<double(int, int)> task([](int a, int b){ return std::pow(a, b); }); std::future<double>future = task.get_future(); task(10, 2); // 此处执行任务 std::cout << future.get() << '\\\\n'; // 不阻塞，此处获取返回值\",\"运行测试。\",\"先关联任务，再执行任务，当我们想要获取任务的返回值的时候，就 future.get() 即可。值得注意的是，任务并不会在线程中执行，想要在线程中执行异步任务，然后再获取返回值，我们可以这么做：\",\"std::packaged_task<double(int, int)> task([](int a, int b){ return std::pow(a, b); }); std::future<double> future = task.get_future(); std::thread t{ std::move(task),10,2 }; // 任务在线程中执行 // todo.. 幻想还有许多耗时的代码 t.join(); std::cout << future.get() << '\\\\n'; // 并不阻塞，获取任务返回值罢了\",\"运行测试。\",\"因为 task 本身是重载了 operator() 的，是可调用对象，自然可以传递给 std::thread 执行，以及传递调用参数。唯一需要注意的是我们使用了 std::move ，这是因为 std::packaged_task 只能移动，不能复制。\",\"简而言之，其实 std::packaged_task 也就是一个“包装”类而已，它本身并没什么特殊的，老老实实执行我们传递的任务，且方便我们获取返回值罢了，明确这一点，那么一切都不成问题。\",\"std::packaged_task 也可以在线程中传递，在需要的时候获取返回值，而非像上面那样将它自己作为可调用对象：\",\"template<typename R, typename...Ts, typename...Args> requires std::invocable<std::packaged_task<R(Ts...)>&, Args...> void async_task(std::packaged_task<R(Ts...)>& task, Args&&...args) { // todo.. task(std::forward<Args>(args)...); } int main() { std::packaged_task<int(int,int)> task([](int a,int b){ return a + b; }); int value = 50; std::future<int> future = task.get_future(); // 创建一个线程来执行异步任务 std::thread t{ [&] {async_task(task, value, value); } }; std::cout << future.get() << '\\\\n'; t.join(); }\",\"运行测试。\",\"我们套了一个 lambda，这是因为函数模板不是函数，它并非具体类型，没办法直接被那样传递使用，只能包一层了。这只是一个简单的示例，展示可以使用 std::packaged_task 作函数形参，然后我们来传递任务进行异步调用等操作。\",\"我们再将第二章实现的并行 sum 改成 std::package_task + std::future 的形式：\",\"template<typename ForwardIt> auto sum(ForwardIt first, ForwardIt last) { using value_type = std::iter_value_t<ForwardIt>; std::size_t num_threads = std::thread::hardware_concurrency(); std::ptrdiff_t distance = std::distance(first, last); if (distance > 1024000) { // 计算每个线程处理的元素数量 std::size_t chunk_size = distance / num_threads; std::size_t remainder = distance % num_threads; // 存储每个线程要执行的任务 std::vector<std::packaged_task<value_type()>> tasks; // 和每一个任务进行关联的 future 用于获取返回值 std::vector<std::future<value_type>> futures(num_threads); // 存储关联线程的线程对象 std::vector<std::thread> threads; // 制作任务、与 future 关联、启动线程执行 auto start = first; for (std::size_t i = 0; i < num_threads; ++i) { auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0)); tasks.emplace_back(std::packaged_task<value_type()>{[start, end, i] { return std::accumulate(start, end, value_type{}); }}); start = end; // 开始迭代器不断向前 futures[i] = tasks[i].get_future(); // 任务与 std::future 关联 threads.emplace_back(std::move(tasks[i])); } // 等待所有线程执行完毕 for (auto& thread : threads) thread.join(); // 汇总线程的计算结果 value_type total_sum {}; for (std::size_t i = 0; i < num_threads; ++i) { total_sum += futures[i].get(); } return total_sum; } value_type total_sum = std::accumulate(first, last, value_type{}); return total_sum; }\",\"运行测试。\",\"相比于之前，其实不同无非是定义了 std::vector<std::packaged_task<value_type()>> tasks 与 std::vector<std::future<value_type>> futures ，然后在循环中制造任务插入容器，关联 future，再放到线程中执行。最后汇总的时候写一个循环，futures[i].get() 获取任务的返回值加起来即可。\",\"到此，也就可以了。\"]},\"54\":{\"h\":\"使用\",\"t\":[\"类模板 std::promise 用于存储一个值或一个异常，之后通过 std::promise 对象所创建的 std::future 对象异步获得。\",\"// 计算函数，接受一个整数并返回它的平方 void calculate_square(std::promise<int> promiseObj, int num) { // 模拟一些计算 std::this_thread::sleep_for(std::chrono::seconds(1)); // 计算平方并设置值到 promise 中 promiseObj.set_value(num * num); } // 创建一个 promise 对象，用于存储计算结果 std::promise<int> promise; // 从 promise 获取 future 对象进行关联 std::future<int> future = promise.get_future(); // 启动一个线程进行计算 int num = 5; std::thread t(calculate_square, std::move(promise), num); // 阻塞，直到结果可用 int result = future.get(); std::cout << num << \\\" 的平方是：\\\" << result << std::endl; t.join();\",\"运行测试。\",\"我们在新线程中通过调用 set_value() 函数设置 promise 的值，并在主线程中通过与其关联的 future 对象的 get() 成员函数获取这个值，如果promise的值还没有被设置，那么将阻塞当前线程，直到被设置为止。同样的 std::promise只能移动，不可复制，所以我们使用了 std::move 进行传递。\",\"除了 set_value() 函数外，std::promise 还有一个 set_exception() 成员函数，它接受一个 std::exception_ptr 类型的参数，这个参数通常通过 std::current_exception() 获取，用于指示当前线程中抛出的异常。然后，std::future 对象通过 get() 函数获取这个异常，如果 promise 所在的函数有异常被抛出，则 std::future 对象会重新抛出这个异常，从而允许主线程捕获并处理它。\",\"void throw_function(std::promise<int> prom) { try { throw std::runtime_error(\\\"一个异常\\\"); } catch (...) { prom.set_exception(std::current_exception()); } } int main() { std::promise<int> prom; std::future<int> fut = prom.get_future(); std::thread t(throw_function, std::move(prom)); try { std::cout << \\\"等待线程执行，抛出异常并设置\\\\n\\\"; fut.get(); } catch (std::exception& e) { std::cerr << \\\"来自线程的异常: \\\" << e.what() << '\\\\n'; } t.join(); }\",\"运行结果：\",\"等待线程执行，抛出异常并设置 来自线程的异常: 一个异常\",\"你可能对这段代码还有一些疑问：我们写的是 promise<int> ，但是却没有使用 set_value 设置值，你可能会想着再写一行 prom.set_value(0)？\",\"共享状态的 promise 已经存储值或者异常，再次调用 set_value（set_exception） 会抛出 std::future_error 异常，将错误码设置为 promise_already_satisfied。这是因为 std::promise 对象只能是存储值或者异常其中一种，而无法共存。\",\"简而言之，set_value 与 set_exception 二选一，如果先前调用了 set_value ，就不可再次调用 set_exception，反之亦然（不然就会抛出异常），示例如下：\",\"void throw_function(std::promise<int> prom) { prom.set_value(100); try { throw std::runtime_error(\\\"一个异常\\\"); } catch (...) { try{ // 共享状态的 promise 已存储值，调用 set_exception 产生异常 prom.set_exception(std::current_exception()); }catch (std::exception& e){ std::cerr << \\\"来自 set_exception 的异常: \\\" << e.what() << '\\\\n'; } } } int main() { std::promise<int> prom; std::future<int> fut = prom.get_future(); std::thread t(throw_function, std::move(prom)); std::cout << \\\"等待线程执行，抛出异常并设置\\\\n\\\"; std::cout << \\\"值：\\\" << fut.get() << '\\\\n'; // 100 t.join(); }\",\"运行结果：\",\"等待线程执行，抛出异常并设置 值：100 来自 set_exception 的异常: promise already satisfied\"]},\"55\":{\"h\":\"future 的状态变化\",\"t\":[\"需要注意的是，future 是一次性的，所以你需要注意移动。并且，调用 get 函数后，future 对象也会失去共享状态。\",\"移动语义：这一点很好理解并且常见，因为移动操作标志着所有权的转移，意味着 future 不再拥有共享状态（如之前所提到）。get 和 wait 函数要求 future 对象拥有共享状态，否则会抛出异常。\",\"共享状态失效：调用 get 成员函数时，future 对象必须拥有共享状态，但调用完成后，它就会失去共享状态，不能再次调用 get。这是我们在本节需要特别讨论的内容。\",\"std::future<void>future = std::async([] {}); std::cout << std::boolalpha << future.valid() << '\\\\n'; // true future.get(); std::cout << std::boolalpha << future.valid() << '\\\\n'; // false try { future.get(); // 抛出 future_errc::no_state 异常 } catch (std::exception& e) { std::cerr << e.what() << '\\\\n'; }\",\"运行测试。\",\"这个问题在许多文档中没有明确说明，但通过阅读源码（MSVC STL），可以很清楚地理解：\",\"// std::future<void> void get() { // block until ready then return or throw the stored exception future _Local{_STD move(*this)}; _Local._Get_value(); } // std::future<T> _Ty get() { // block until ready then return the stored result or throw the stored exception future _Local{_STD move(*this)}; return _STD move(_Local._Get_value()); } // std::future<T&> _Ty& get() { // block until ready then return the stored result or throw the stored exception future _Local{_STD move(*this)}; return *_Local._Get_value(); }\",\"如上所示，我们展示了 std::future 的所有特化中 get 成员函数的实现。注意到了吗？尽管我们可能不了解移动构造函数的具体实现，但根据通用的语义，可以看出 future _Local{_STD move(*this)}; 将当前对象的共享状态转移给了这个局部对象，而局部对象在函数结束时析构。这意味着当前对象失去共享状态，并且状态被完全销毁。\",\"另外一提，std::future<T> 这个特化，它 return std::move 是为了支持只能移动的类型能够使用 get 返回值，参见前文的 move_only 类型。\",\"如果需要进行多次 get 调用，可以考虑使用下文提到的 std::shared_future。\"]},\"56\":{\"h\":\"多个线程的等待\",\"t\":[\"之前的例子中我们一直使用 std::future，但 std::future 有一个局限：future 是一次性的，它的结果只能被一个线程获取。get() 成员函数只能调用一次，当结果被某个线程获取后，std::future 就无法再用于其他线程。\",\"int task(){ // todo.. return 10; } void thread_functio(std::future<int>& fut){ // todo.. int result = fut.get(); std::cout << result << '\\\\n'; // todo.. } int main(){ auto future = std::async(task); // 启动耗时的异步任务 // 可能有多个线程都需要此任务的返回值，于是我们将与其关联的 future 对象的引入传入 std::thread t{ thread_functio,std::ref(future) }; std::thread t2{ thread_functio,std::ref(future) }; t.join(); t2.join(); }\",\"可能有多个线程都需要耗时的异步任务的返回值，于是我们将与其关联的 future 对象的引入传给线程对象，让它能在需要的时候获取。\",\"但是这存在个问题，future 是一次性的，只能被调用一次 get() 成员函数，所以以上代码存在问题。\",\"此时就需要使用 std::shared_future 来替代 std::future 了。std::future 与 std::shared_future 的区别就如同 std::unique_ptr、std::shared_ptr 一样。\",\"std::future 是只能移动的，其所有权可以在不同的对象中互相传递，但只有一个对象可以获得特定的同步结果。而 std::shared_future 是可复制的，多个对象可以指代同一个共享状态。\",\"在多个线程中对同一个 std::shared_future 对象进行操作时（如果没有进行同步保护）存在条件竞争。而从多个线程访问同一共享状态，若每个线程都是通过其自身的 shared_future 对象副本进行访问，则是安全的。\",\"std::string fetch_data() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return \\\"从网络获取的数据！\\\"; } int main() { std::future<std::string> future_data = std::async(std::launch::async, fetch_data); // // 转移共享状态，原来的 future 被清空 valid() == false std::shared_future<std::string> shared_future_data = future_data.share(); // 第一个线程等待结果并访问数据 std::thread thread1([&shared_future_data] { std::cout << \\\"线程1：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程1：收到数据：\\\" << shared_future_data.get() << std::endl; }); // 第二个线程等待结果并访问数据 std::thread thread2([&shared_future_data] { std::cout << \\\"线程2：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程2：收到数据：\\\" << shared_future_data.get() << std::endl; }); thread1.join(); thread2.join(); }\",\"这段代码存在数据竞争，就如同我们先前所说：“在多个线程中对同一个 std::shared_future 对象进行操作时（如果没有进行同步保护）存在条件竞争”，它并没有提供线程安全的方式。而我们的 lambda 是按引用传递，也就是“同一个”进行操作了。可以改为：\",\"std::string fetch_data() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return \\\"从网络获取的数据！\\\"; } int main() { std::future<std::string> future_data = std::async(std::launch::async, fetch_data); std::shared_future<std::string> shared_future_data = future_data.share(); std::thread thread1([shared_future_data] { std::cout << \\\"线程1：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程1：收到数据：\\\" << shared_future_data.get() << std::endl; }); std::thread thread2([shared_future_data] { std::cout << \\\"线程2：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程2：收到数据：\\\" << shared_future_data.get() << std::endl; }); thread1.join(); thread2.join(); }\",\"这样访问的就都是 std::shared_future 的副本了，我们的 lambda 按复制捕获 std::shared_future 对象，每个线程都有一个 shared_future 的副本，这样不会有任何问题。这一点和 std::shared_ptr 类似[2]。\",\"std::promise 也同，它的 get_future() 成员函数一样可以用来构造 std::shared_future，虽然它的返回类型是 std::future，不过不影响，这是因为 std::shared_future 有一个 std::future<T>&& 参数的构造函数，转移 std::future 的所有权。\",\"std::promise<std::string> p; std::shared_future<std::string> sf{ p.get_future() }; // 隐式转移所有权\",\"就不需要再强调了。\"]},\"57\":{\"h\":\"限时等待\",\"t\":[\"阻塞调用会将线程挂起一段（不确定的）时间，直到对应的事件发生。通常情况下，这样的方式很好，但是在一些情况下，需要限定线程等待的时间，因为无限期地等待事件发生可能会导致性能下降或资源浪费。一个常见的例子是在很多网络库中的 connect 函数，这个函数调用是阻塞的，但是也是限时的，一定时间内没有连接到服务器就不会继续阻塞了，会进行其它处理，比如抛出异常。\",\"介绍两种指定超时的方式，一种是“时间段”，另一种是“时间点”，其实就是先前讲的 std::this::thread::sleep_for 与 std::this_thread::sleep_until 的区别。前者是需要指定等待一段时间（比如 10 毫秒）。而后者是指定等待到一个具体的时间点（比如到 2024-05-07T12:01:10.123）。多数函数都对两种超时方式进行处理。处理持续时间的函数以 _for 作为后缀，处理绝对时间的函数以 _until 作为后缀。\",\"条件变量 std::condition_variable 的等待函数，也有两个超时的版本 wait_for 和 wait_until 。它们和我们先前讲的 wait 成员函数一样有两个重载，可以选择是否传递一个谓词。它们相比于 wait 多了一个解除阻塞的可能，即：超过指定的时长或抵达指定的时间点。\",\"在讲述它的使用细节之前，我们还是要来先聊一下 C++ 中的时间库（chrono），指定时间的方式，它较为麻烦。我们分：时钟（clock）、时间段（duration）、*时间点（time point）*三个阶段稍微介绍一下。\"]},\"58\":{\"h\":\"时钟\",\"t\":[\"在 C++ 标准库中，时钟被视为时间信息的来源。C++ 定义了很多种时间类型，每种时钟类型都提供了四种不同的信息：\",\"当前时间\",\"时间类型\",\"时钟节拍\",\"稳定时钟\",\"当前时间可以通过静态成员函数 now 获取，例如，std::chrono::system_clock::now() 会返回系统的当前时间。特定的时间点则可以通过 time_point 来指定。system_clock::now() 的返回类型就是 time_point。\",\"时钟节拍被指定为 1/x（x 在不同硬件上有不同的值）秒，这是由时间周期所决定。假设一个时钟一秒有 25 个节拍，因此一个周期为 std::ratio<1,25> 。当一个时钟的时钟节拍每 2.5 秒一次，周期就可以表示为 std::ratio<5,2>。\",\"类模板 std::chrono::duration 表示时间间隔。\",\"template<class Rep, class Period = std::ratio<1>> class duration;\",\"std::ratio 是一个分数类模板，它有两个非类型模板参数，也就是分子与分母，分母有默认实参 1，所以 std::ratio<1> 等价于 std::ratio<1,1>。\",\"如你所见，它默认的时钟节拍是 1，这是一个很重要的类，标准库通过它定义了很多的时间类型，比如 std::chrono::minutes 是分钟类型，那么它的 Period 就是 std::ratio<60> ，因为一分钟等于 60 秒。\",\"using minutes = duration<int, ratio<60>>;\",\"稳定时钟（Steady Clock）是指提供稳定、持续递增的时间流逝信息的时钟。它的特点是不受系统时间调整或变化的影响，即使在系统休眠或时钟调整的情况下，它也能保持稳定。在 C++ 标准库中，std::chrono::steady_clock 就是一个稳定时钟。它通常用于测量时间间隔和性能计时等需要高精度和稳定性的场景。可以通过 is_steady 静态常量判断当前时钟是否是稳定时钟。\",\"稳定时钟的主要优点在于，它可以提供相对于起始时间的稳定的递增时间，因此适用于需要保持时间顺序和不受系统时间变化影响的应用场景。相比之下，像 std::chrono::system_clock 这样的系统时钟可能会受到系统时间调整或变化的影响，因此在某些情况下可能不适合对时间间隔进行精确测量。\",\"不管使用哪种时钟获取时间，C++ 都提供了函数，可以将时间点转换为 time_t 类型的值：\",\"auto now = std::chrono::system_clock::now(); time_t now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Current time:\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\\n\\\"); auto now2 = std::chrono::steady_clock::now(); now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Current time:\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\\n\\\");\",\"C++ 的时间库极其繁杂，主要在于类型之多，以及实现之复杂。根据我们的描述，了解基本构成、概念、使用，即可。\"]},\"59\":{\"h\":\"时间段\",\"t\":[\"时间部分最简单的就是时间段，主要的内容就是我们上面讲的类模板 std::chrono::duration ，它用于对时间段进行处理。\",\"它的第一个参数是类型表示，第二个参数就是先前提到的“节拍”，需要传递一个 std::ratio 类型，也就是一个时钟所用的秒数。\",\"标准库在 std::chrono 命名空间内为时间段提供了一系列的类型，它们都是通过 std::chrono::duration 定义的别名：\",\"using nanoseconds = duration<long long, nano>; using microseconds = duration<long long, micro>; using milliseconds = duration<long long, milli>; using seconds = duration<long long>; using minutes = duration<int, ratio<60>>; using hours = duration<int, ratio<3600>>; // CXX20 using days = duration<int, ratio_multiply<ratio<24>, hours::period>>; using weeks = duration<int, ratio_multiply<ratio<7>, days::period>>; using years = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>; using months = duration<int, ratio_divide<years::period, ratio<12>>>;\",\"如果没有指明 duration 的第二个非类型模板参数，那么代表默认 std::ratio<1>，比如 seconds 也就是一秒。\",\"如上，是 MSVC STL 定义的，看似有一些没有使用 ratio 作为第二个参数，其实也还是别名罢了，见：\",\"using milli = ratio<1, 1000>; // 千分之一秒，也就是一毫秒了\",\"并且为了方便使用，在 C++14 标准库增加了时间字面量，存在于 std::chrono_literals 命名空间中，让我们得以简单的使用：\",\"using namespace std::chrono_literals; auto one_nanosecond = 1ns; auto one_microsecond = 1us; auto one_millisecond = 1ms; auto one_second = 1s; auto one_minute = 1min; auto one_hour = 1h;\",\"当不要求截断值的情况下（时转换为秒时没问题的，但反过来不行）时间段有隐式转换，显式转换可以由 std::chrono::duration_cast<> 来完成。\",\"std::chrono::milliseconds ms{ 3999 }; std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(ms); std::cout << s.count() << '\\\\n';\",\"这里的结果是截断的，而不会进行所谓的四舍五入，3999 毫秒，也就是 3.999 秒最终的值是 3。\",\"很多时候这并不是我们想要的，比如我们想要的其实是输出 3.999 秒，而不是 3 秒 或者 3999 毫秒。\",\"seconds 是 duration<long long> 这意味着它无法接受浮点数，我们直接改成 duration<double> 即可：\",\"std::chrono::duration<double> s = std::chrono::duration_cast<std::chrono::duration<double>>(ms);\",\"当然了，这样写很冗余，并且这种形式的转换是可以直接隐式的，也就是其实我们可以直接：\",\"std::chrono::duration<double> s = ms;\",\"无需使用 duration_cast，可以直接隐式转换。\",\"另外我们用的 duration 都是省略了 ratio 的，其实默认类型就是 ratio<1>，代表一秒。参见源码声明：\",\"_EXPORT_STD template <class _Rep, class _Period = ratio<1>> class duration;\",\"时间库支持四则运算，可以对两个时间段进行加减乘除。时间段对象可以通过 count() 成员函数获得计次数。例如 std::chrono::milliseconds{123}.count() 的结果就是 123。\",\"基于时间段的等待都是由 std::chrono::duration<> 来完成。例如：等待一个 future 对象在 35 毫秒内变为就绪状态：\",\"std::future<int> future = std::async([] {return 6; }); if (future.wait_for(35ms) == std::future_status::ready) std::cout << future.get() << '\\\\n';\",\"wait_for： 等待结果，如果在指定的超时间隔后仍然无法得到结果，则返回。它的返回类型是一个枚举类 std::future_status ，三个枚举项分别表示三种 future 状态。\",\"deferred\",\"共享状态持有的函数正在延迟运行，结果将仅在明确请求时计算\",\"ready\",\"共享状态就绪\",\"timeout\",\"共享状态在经过指定的等待时间内仍未就绪\",\"timeout 超时，也很好理解，那我们就提一下 deferred ：\",\"auto future = std::async(std::launch::deferred, []{}); if (future.wait_for(35ms) == std::future_status::deferred) std::cout << \\\"future_status::deferred \\\" << \\\"正在延迟执行\\\\n\\\"; future.wait(); // 在 wait() 或 get() 调用时执行，不创建线程\"]},\"60\":{\"h\":\"时间点\",\"t\":[\"时间点可用 std::chrono::time_point<> 来表示，第一个模板参数用来指定使用的时钟，第二个模板参数用来表示时间单位（std::chrono::duration<>）。时间点顾名思义就是时间中的一个点，在 C++ 中用于表达当前时间，先前提到的静态成员函数 now() 获取当前时间，它们的返回类型都是 std::chrono::time_point。\",\"template< class Clock, class Duration = typename Clock::duration > class time_point;\",\"如你所见，它的第二个模板参数是时间段，就是时间的间隔，其实也就可以理解为表示时间点的精度，默认是根据第一个参数时钟得到的，所以假设有类型：\",\"std::chrono::time_point<std::chrono::system_clock>\",\"那它等价于：\",\"std::chrono::time_point<std::chrono::system_clock, std::chrono::system_clock::duration>\",\"也就是说第二个参数的实际类型是：\",\"std::chrono::duration<long long,std::ratio<1, 10000000>> // // 100 nanoseconds\",\"也就是说 std::chrono::time_point<std::chrono::system_clock> 的精度是 100 纳秒。\",\"更多的问题参见源码都很直观。\",\"注意，这里的精度并非是实际的时间精度。时间和硬件系统等关系极大，以 windows 为例：\",\"Windows 内核中的时间间隔计时器默认每隔 15.6 毫秒触发一次中断。因此，如果你使用基于系统时钟的计时方法，默认情况下精度约为 15.6 毫秒。不可能达到纳秒级别。\",\"由于这个系统时钟的限制，那些基于系统时钟的 API（例如 Sleep()、WaitForSingleObject() 等）的最小睡眠时间默认就是 15.6 毫秒左右。\",\"如：\",\"std::this_thread::sleep_for(std::chrono::milliseconds(1));\",\"不过我们也可以使用系统 API 调整系统时钟的精度，需要链接 windows 多媒体库 winmm.lib ，然后使用 API：\",\"timeBeginPeriod(1); // 设置时钟精度为 1 毫秒 // todo.. timeEndPeriod(1); // 恢复默认精度\",\"同样的，时间点也支持加减以及比较操作。\",\"std::chrono::steady_clock::now() + std::chrono::nanoseconds(500); // 500 纳秒之后的时间\",\"可以减去一个时间点，结果是两个时间点的时间差。这对于代码块的计时是很有用的，如：\",\"auto start = std::chrono::steady_clock::now(); std::this_thread::sleep_for(std::chrono::seconds(1)); auto end = std::chrono::steady_clock::now(); auto result = std::chrono::duration_cast<std::chrono::milliseconds>(end - start); std::cout << result.count() << '\\\\n';\",\"运行测试。\",\"我们进行了一个显式的转换，最终输出的是以毫秒作为单位，有可能不会是 1000，没有这么精确。\",\"等待条件变量满足条件——带超时功能\",\"using namespace std::chrono_literals; std::condition_variable cv; bool done{}; std::mutex m; bool wait_loop() { const auto timeout = std::chrono::steady_clock::now() + 500ms; std::unique_lock<std::mutex> lk{ m }; while (!done) { if (cv.wait_until(lk, timeout) == std::cv_status::timeout) { std::cout << \\\"超时 500ms\\\\n\\\"; return false; } } return true; }\",\"运行测试。\",\"_until 也就是等待到一个时间点，我们设置的是等待到当前时间往后 500 毫秒。如果超过了这个时间还没有被唤醒，那就打印超时，并退出循环，函数返回 false。\",\"到此，时间点的知识也就足够了。\"]},\"61\":{\"h\":\"异步任务执行\",\"t\":[\"在开发带有 UI 的程序时，主线程用于处理 UI 更新和用户交互，如果在主线程中执行耗时任务会导致界面卡顿。因此，需要使用异步任务来减轻主线程的压力。以下是一个使用 Qt 实现异步任务的示例，展示了如何在不阻塞 UI 线程的情况下执行耗时任务，并更新进度条。\"]},\"62\":{\"h\":\"背景介绍\",\"t\":[\"在 Qt 中，GUI 控件通常只能在创建它们的线程中进行操作，因为它们是线程不安全的。我们可以使用 QMetaObject::invokeMethod 来跨线程调用主线程上的控件方法，从而在其他线程中安全地更新 UI 控件。以下代码示例展示了如何通过 QMetaObject::invokeMethod 确保 UI 控件的更新操作在主线程中执行。\",\"void task(){ future = std::async(std::launch::async, [=] { QMetaObject::invokeMethod(this, [this] { button->setEnabled(false); progressBar->setRange(0, 1000); button->setText(\\\"正在执行...\\\"); }); for (int i = 0; i < 1000; ++i) { std::this_thread::sleep_for(10ms); QMetaObject::invokeMethod(this, [this, i] { progressBar->setValue(i); }); } QMetaObject::invokeMethod(this, [this] { button->setText(\\\"start\\\"); button->setEnabled(true); }); }); }\",\"上面的代码创建了一个异步任务，并指明了执行策略。任务在线程中执行，不会阻塞 UI 线程。如果不这样做，界面将会卡顿（可以尝试将函数的第一行与最后一行注释掉以验证这一点）。\",\"进度条\",\"在启动进度条后，能够正常点击“测试”按钮并触发弹窗，说明 UI 没有被阻塞。相反，如果不使用线程，界面将会卡住，无法点击“测试”按钮或移动窗口。\"]},\"63\":{\"h\":\"项目说明\",\"t\":[\"项目使用 Visual Studio + CMake，可以直接安装 Qt 插件后打开此项目。项目结构简单，所有界面与设置均通过代码控制，无需进行其他 UI 操作。只需关注 async_progress_bar.h、async_progress_bar.cpp 和 main.cpp 这三个文件，它们位于仓库的 code 文件夹中。\"]},\"64\":{\"h\":\"完整代码实现\",\"t\":[\"class async_progress_bar : public QMainWindow{ Q_OBJECT public: async_progress_bar(QWidget *parent = nullptr); ~async_progress_bar(); void task(){ future = std::async(std::launch::async, [=] { QMetaObject::invokeMethod(this, [this] { // 这里显示的线程 ID 就是主线程，代表这些任务就是在主线程，即 UI 线程执行 QMessageBox::information(nullptr, \\\"线程ID\\\", std::to_string(_Thrd_id()).c_str()); button->setEnabled(false); progress_bar->setRange(0, 1000); button->setText(\\\"正在执行...\\\"); }); for (int i = 0; i <= 1000; ++i) { std::this_thread::sleep_for(10ms); QMetaObject::invokeMethod(this, [this, i] { progress_bar->setValue(i); }); } QMetaObject::invokeMethod(this, [this] { button->setText(\\\"start\\\"); button->setEnabled(true); }); // 不在 invokeMethod 中获取线程 ID，这里显示的是子线程的ID auto s = std::to_string(_Thrd_id()); QMetaObject::invokeMethod(this, [=] { QMessageBox::information(nullptr, \\\"线程ID\\\", s.c_str()); }); }); } private: QString progress_bar_style = \\\"QProgressBar {\\\" \\\" border: 2px solid grey;\\\" \\\" border-radius: 5px;\\\" \\\" background-color: lightgrey;\\\" \\\" text-align: center;\\\" // 文本居中 \\\" color: #000000;\\\" // 文本颜色 \\\"}\\\" \\\"QProgressBar::chunk {\\\" \\\" background-color: #7FFF00;\\\" \\\" width: 10px;\\\" // 设置每个进度块的宽度 \\\" font: bold 14px;\\\" // 设置进度条文本字体 \\\"}\\\"; QString button_style = \\\"QPushButton {\\\" \\\" text-align: center;\\\" // 文本居中 \\\"}\\\"; QProgressBar* progress_bar{}; QPushButton* button{}; QPushButton* button2{}; Ui::async_progress_barClass ui{}; std::future<void>future; }; // 创建控件 设置布局、样式 连接信号 async_progress_bar::async_progress_bar(QWidget *parent) : QMainWindow{ parent }, progress_bar{ new QProgressBar(this) }, button{ new QPushButton(\\\"start\\\",this) },button2{ new QPushButton(\\\"测试\\\",this) } { ui.setupUi(this); progress_bar->setStyleSheet(progress_bar_style); progress_bar->setRange(0, 1000); button->setMinimumSize(100, 50); button->setMaximumWidth(100); button->setStyleSheet(button_style); button->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed); button2->setMinimumSize(100, 50); button2->setMaximumWidth(100); button2->setStyleSheet(button_style); button2->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed); QVBoxLayout* layout = new QVBoxLayout; layout->addWidget(progress_bar); layout->addWidget(button, 0, Qt::AlignHCenter); layout->addWidget(button2, 0, Qt::AlignHCenter); // 设置窗口布局为垂直布局管理器 centralWidget()->setLayout(layout); connect(button, &QPushButton::clicked, this, &async_progress_bar::task); connect(button2, &QPushButton::clicked, []{ QMessageBox::information(nullptr, \\\"测试\\\", \\\"没有卡界面！\\\"); }); }\"]},\"65\":{\"h\":\"注意事项\",\"t\":[\"QMetaObject::invokeMethod 的 lambda 是在主线程运行的，通过显示的线程 ID 可以验证这一点。\",\"使用 std::async 的 std::launch::async 参数强制异步执行任务，以确保任务在新线程中运行。\"]},\"66\":{\"h\":\"跨平台兼容性\",\"t\":[\"C++11 的 std::this_thread::get_id() 返回的内部类 std::thread::id 没办法直接转换为 unsigned int，我们就直接使用了 win32 的 API _Thrd_id() 了。如果您是 Linux 之类的环境，使用 POSIX 接口 pthread_self()。\"]},\"67\":{\"h\":\"实践建议\",\"t\":[\"这个例子其实很好的展示了多线程异步的作用，因为有 UI，所以很直观，毕竟如果你不用线程，那么不就卡界面了，用了就没事。\",\"建议下载并运行此项目，通过实际操作理解代码效果。同时，可以尝试修改代码，观察不同情况下 UI 的响应情况，以加深对异步任务处理的理解。\"]},\"68\":{\"h\":\"C++20 信号量\",\"t\":[\"C++20 引入了信号量，对于那些熟悉操作系统或其它并发支持库的开发者来说，这个同步设施的概念应该不会感到陌生。信号量源自操作系统，是一个古老而广泛应用的同步设施，在各种编程语言中都有自己的抽象实现。然而，C++ 标准库对其的支持却来得很晚，在 C++20 中才得以引入。\",\"信号量是一个非常轻量简单的同步设施，它维护一个计数，这个计数不能小于 0。信号量提供两种基本操作：释放（增加计数）和等待（减少计数）。如果当前信号量的计数值为 0，那么执行“等待”操作的线程将会一直阻塞，直到计数大于 0，也就是其它线程执行了“释放”操作。\",\"C++ 提供了两个信号量类型：std::counting_semaphore 与 std::binary_semaphore，定义在 <semaphore> 中。\",\"binary_semaphore[3] 只是 counting_semaphore 的一个特化别名：\",\"using binary_semaphore = counting_semaphore<1>;\",\"好了，我们举一个简单的例子来使用一下：\",\"// 全局二元信号量对象 // 设置对象初始计数为 0 std::binary_semaphore smph_signal_main_to_thread{ 0 }; std::binary_semaphore smph_signal_thread_to_main{ 0 }; void thread_proc() { smph_signal_main_to_thread.acquire(); std::cout << \\\"[线程] 获得信号\\\" << std::endl; std::this_thread::sleep_for(3s); std::cout << \\\"[线程] 发送信号\\\\n\\\"; smph_signal_thread_to_main.release(); } int main() { std::jthread thr_worker{ thread_proc }; std::cout << \\\"[主] 发送信号\\\\n\\\"; smph_signal_main_to_thread.release(); smph_signal_thread_to_main.acquire(); std::cout << \\\"[主] 获得信号\\\\n\\\"; }\",\"运行结果：\",\"[主] 发送信号 [线程] 获得信号 [线程] 发送信号 [主] 获得信号\",\"acquire 函数就是我们先前说的“等待”（原子地减少计数），release 函数就是\\\"释放\\\"（原子地增加计数）。\",\"信号量常用于发信/提醒而非互斥，通过初始化该信号量为 0 从而阻塞尝试 acquire() 的接收者，直至提醒者通过调用 release(n) “发信”。在此方面可把信号量当作条件变量的替代品，通常它有更好的性能。\",\"假设我们有一个 Web 服务器，它只能处理有限数量的并发请求。为了防止服务器过载，我们可以使用信号量来限制并发请求的数量。\",\"// 定义一个信号量，最大并发数为 3 std::counting_semaphore<3> semaphore{ 3 }; void handle_request(int request_id) { // 请求到达，尝试获取信号量 std::cout << \\\"进入 handle_request 尝试获取信号量\\\\n\\\"; semaphore.acquire(); std::cout << \\\"成功获取信号量\\\\n\\\"; // 此处延时三秒可以方便测试，会看到先输出 3 个“成功获取信号量”，因为只有三个线程能成功调用 acquire，剩余的会被阻塞 std::this_thread::sleep_for(3s); // 模拟处理时间 std::random_device rd; std::mt19937 gen{ rd() }; std::uniform_int_distribution<> dis(1, 5); int processing_time = dis(gen); std::this_thread::sleep_for(std::chrono::seconds(processing_time)); std::cout << std::format(\\\"请求 {} 已被处理\\\\n\\\", request_id); semaphore.release(); } int main() { // 模拟 10 个并发请求 std::vector<std::jthread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(handle_request, i); } }\",\"运行测试。\",\"这段代码很简单，以至于我们可以在这里来再说一条概念：\",\"counting_semaphore 是一个轻量同步原语，能控制对共享资源的访问。不同于 std::mutex，counting_semaphore允许同一资源进行多个并发的访问，至少允许 LeastMaxValue 个同时访问者[4]。\",\"binary_semaphore 是 std::counting_semaphore 的特化的别名，其 LeastMaxValue 为 1。\",\"LeastMaxValue 是我们设置的非类型模板参数，意思是信号量维护的计数最大值。我们这段代码设置的是 3，也就是允许 3 个同时访问者。\",\"虽然说是说有 LeastMaxValue 可能不是最大，但是我们通常不用在意这个事情，MSVC STL 的实现中 max 函数就是直接返回 LeastMaxValue，将它视为信号量维护的计数最大值即可。\",\"牢记信号量的基本的概念不变，计数的值不能小于 0，如果当前信号量的计数值为 0，那么执行“等待”（acquire）操作的线程将会一直阻塞。明白这点，那么就都不存在问题。\",\"通过这种方式，可以有效控制 Web 服务器处理并发请求的数量，防止服务器过载。\"]},\"69\":{\"h\":\"C++20 闩与屏障\",\"t\":[\"闩 (latch) 与屏障 (barrier) 是线程协调机制，允许任何数量的线程阻塞直至期待数量的线程到达。闩不能重复使用，而屏障则可以。\",\"std::latch：单次使用的线程屏障\",\"std::barrier：可复用的线程屏障\",\"它们定义在标头 <latch> 与 <barrier>。\",\"与信号量类似，屏障也是一种古老而广泛应用的同步机制。许多系统 API 提供了对屏障机制的支持，例如 POSIX 和 Win32。此外，OpenMP 也提供了屏障机制来支持多线程编程。\"]},\"70\":{\"h\":\"\",\"t\":[\"“闩” ，中文语境一般说“门闩” 是指门背后用来关门的棍子。不过不用在意，在 C++ 中的意思就是先前说的：单次使用的线程屏障。\",\"latch 类维护着一个 std::ptrdiff_t 类型的计数[5]，且只能减少计数，无法增加计数。在创建对象的时候初始化计数器的值。线程可以阻塞，直到 latch 对象的计数减少到零。由于无法增加计数，这使得 latch 成为一种单次使用的屏障。\",\"std::latch work_start{ 3 }; void work(){ std::cout << \\\"等待其它线程执行\\\\n\\\"; work_start.wait(); // 等待计数为 0 std::cout << \\\"任务开始执行\\\\n\\\"; } int main(){ std::jthread thread{ work }; std::this_thread::sleep_for(3s); std::cout << \\\"休眠结束\\\\n\\\"; work_start.count_down(); // 默认值是 1 减少计数 1 work_start.count_down(2); // 传递参数 2 减少计数 2 }\",\"运行结果：\",\"等待其它线程执行 休眠结束 任务开始执行\",\"在这个例子中，通过调用 wait 函数阻塞子线程，直到主线程调用 count_down 函数原子地将计数减至 0，从而解除阻塞。这个例子清楚地展示了 latch 的使用，其逻辑比信号量更简单。\",\"由于 latch 的计数不可增加，它的使用通常非常简单，可以用来划分任务执行的工作区间。例如：\",\"std::latch latch{ 10 }; void f(int id) { //todo.. 脑补任务 std::this_thread::sleep_for(1s); std::cout << std::format(\\\"线程 {} 执行完任务，开始等待其它线程执行到此处\\\\n\\\", id); latch.arrive_and_wait(); std::cout << std::format(\\\"线程 {} 彻底退出函数\\\\n\\\", id); } int main() { std::vector<std::jthread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(f,i); } }\",\"运行测试。\",\"arrive_and_wait 函数等价于：count_down(n); wait();。也就是减少计数 + 等待。这意味着\",\"必须等待所有线程执行到 latch.arrive_and_wait(); 将 latch 的计数减少至 0 才能继续往下执行。这个示例非常直观地展示了如何使用 latch 来划分任务执行的工作区间。\",\"由于 latch 的功能受限，通常用于简单直接的需求，不少情况很多同步设施都能完成你的需求，在这个时候请考虑使用尽可能功能最少的那一个。\",\"使用功能尽可能少的设施有助于开发者阅读代码理解含义。如果使用的是一个功能丰富的设施，可能就无法直接猜测其意图。\"]},\"71\":{\"h\":\"\",\"t\":[\"上节我们学习了 std::latch ，本节内容也不会对你构成难度。\",\"template< class CompletionFunction = /* 未指定 */ > class barrier;\",\"CompletionFunction - 函数对象类型。\",\"std::barrier 和 std::latch 最大的不同是，前者可以在阶段完成之后将计数重置为构造时传递的值，而后者只能减少计数。我们用一个非常简单直观的示例为你展示：\",\"std::barrier barrier{ 10, [n = 1]()mutable noexcept {std::cout << \\\"\\\\t第\\\" << n++ << \\\"轮结束\\\\n\\\"; } }; void f(int start, int end){ for (int i = start; i <= end; ++i) { std::osyncstream{ std::cout } << i << ' '; barrier.arrive_and_wait(); // 减少计数并等待 解除阻塞时就重置计数并调用函数对象 std::this_thread::sleep_for(300ms); } } int main(){ std::vector<std::jthread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(f, i * 10 + 1, (i + 1) * 10); } }\",\"可能的运行结果：\",\"1 21 11 31 41 51 61 71 81 91 第1轮结束 12 2 22 32 42 52 62 72 92 82 第2轮结束 13 63 73 33 23 53 83 93 43 3 第3轮结束 14 44 24 34 94 74 64 4 84 54 第4轮结束 5 95 15 45 75 25 55 65 35 85 第5轮结束 6 46 16 26 56 96 86 66 76 36 第6轮结束 47 17 57 97 87 67 77 7 27 37 第7轮结束 38 8 28 78 68 88 98 58 18 48 第8轮结束 9 39 29 69 89 99 59 19 79 49 第9轮结束 30 40 70 10 90 50 60 20 80 100 第10轮结束\",\"注意输出的规律，第一轮每个数字最后一位都是 1，第二轮每个数字最后一位都是 2……以此类推，因为我们分配给每个线程的输出任务就是如此，然后利用了屏障一轮一轮地打印。\",\"arrive_and_wait 等价于 wait(arrive());。原子地将期待计数减少 1，然后在当前阶段的同步点阻塞直至运行当前阶段的阶段完成步骤。\",\"arrive_and_wait() 会在期待计数减少至 0 时调用我们构造 barrier 对象时传入的 lambda 表达式，并解除所有在阶段同步点上阻塞的线程。之后重置期待计数为构造中指定的值。屏障的一个阶段就完成了。\",\"并发调用barrier 除了析构函数外的成员函数不会引起数据竞争。\",\"另外你可能注意到我们使用了 std::osyncstream ，它是 C++20 引入的，此处是确保输出流在多线程环境中同步，避免除数据竞争，而且将不以任何方式穿插或截断。\",\"虽然 std::cout 的 operator<< 调用是线程安全的，不会被打断，但多个 operator<< 的调用在多线程环境中可能会交错，导致输出结果混乱，使用 std::osyncstream 就可以解决这个问题。开发者可以尝试去除 std::osyncstream 直接使用 std::cout，效果会非常明显。\",\"使用 arrive 或 arrive_and_wait 减少的都是当前屏障计数，我们称作“期待计数”。不管如何减少计数，当完成一个阶段，就重置期待计数为构造中指定的值了。\",\"标准库还提供一个函数 arrive_and_drop 可以改变重置的计数值：它将所有后继阶段的初始期待计数减少一，当前阶段的期待计数也减少一。\",\"不用感到难以理解，我们来解释一下这个概念：\",\"std::barrier barrier{ 4 }; // 初始化计数为 4 完成阶段重置计数也是 4 barrier.arrive_and_wait(); // 当前计数减 1，不影响之后重置计数 4 barrier.arrive_and_drop(); // 当前计数与重置之后的计数均减 1 完成阶段会重置计数为 3\",\"arrive_and_drop 可以用来控制在需要的时候，让一些线程退出同步，如：\",\"std::atomic_int active_threads{ 4 }; std::barrier barrier{ 4, [n = 1]() mutable noexcept { std::cout << \\\"\\\\t第\\\" << n++ << \\\"轮结束，活跃线程数: \\\" << active_threads << '\\\\n'; } }; void f(int thread_id) { for (int i = 1; i <= 5; ++i) { std::osyncstream{ std::cout } << \\\"线程 \\\" << thread_id << \\\" 输出: \\\" << i << '\\\\n'; if (i == 3 && thread_id == 2) { // 假设线程 ID 为 2 的线程在完成第三轮同步后退出 std::osyncstream{ std::cout } << \\\"线程 \\\" << thread_id << \\\" 完成并退出\\\\n\\\"; --active_threads; // 减少活跃线程数 barrier.arrive_and_drop(); // 减少当前计数 1，并减少重置计数 1 return; } barrier.arrive_and_wait(); // 减少计数并等待，解除阻塞时重置计数并调用函数对象 } } int main() { std::vector<std::jthread> threads; for (int i = 1; i <= 4; ++i) { threads.emplace_back(f, i); } }\",\"运行测试。\",\"初始线程有 4 个，线程 2 在执行了三轮同步便直接退出了，调用 arrive_and_drop 函数，下一个阶段的计数会重置为 3，也就是执行完第三轮同步后只有三个活跃线程继续执行。查看输出结果，非常的直观。\",\"这样，arrive_and_drop 的作用就非常明显了，使用也十分的简单。\",\"最后请注意，我们的 lambda 表达式必须声明为 noexcept ，因为 std::barrier 要求其函数对象类型必须是不抛出异常的。即要求 std::is_nothrow_invocable_v<_Completion_function&> 为 true，见 MSVC STL。\",\"std::barrier barrier{ 1,[] {} };\",\"按照标准规定，这行代码会产生一个编译错误。因为传入的函数对象它不是 noexcept 的。不过，在 gcc 与 clang（即 libstdc++ 和 libc++）均可以通过编译，这是因为它们没有进行相应的检测，存在缺陷，为了代码的可维护性开发者应遵守标准规定，确保传入的函数对象是 noexcept 的。\"]},\"72\":{\"h\":\"总结\",\"t\":[\"在并发编程中，同步操作对于并发编程至关重要。如果没有同步，线程基本上就是独立的，因其任务之间的相关性，才可作为一个整体执行（比如第二章的并行求和）。本章讨论了多种用于同步操作的工具，包括条件变量、future、promise、package_task、信号量。同时，详细介绍了 C++ 时间库的知识，以使用并发支持库中的“限时等待”。还使用 CMake + Qt 构建了一个带有 UI 界面的示例，展示异步多线程的必要性。最后介绍了 C++20 引入的两种新的并发设施，信号量、闩与屏障。\",\"在讨论了 C++ 中的高级工具之后，现在让我们来看看底层工具：C++ 内存模型与原子操作。\",\"此设施来自微软并行模式库（PPL），它返回一个 task 类型，它的使用同样可参见文档。不过这不是我们的重点。 ↩︎\",\"注：多个线程能在不同的 shared_ptr 对象上调用所有成员函数（包含复制构造函数与复制赋值）而不附加同步，即使这些实例是同一对象的副本且共享所有权也是如此。若多个执行线程访问同一 shared_ptr 对象而不同步，且任一线程使用 shared_ptr 的非 const 成员函数，则将出现数据竞争；std::atomic<shared_ptr> 能用于避免数据竞争。文档。 ↩︎\",\"注：如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore），这就是这个类型名字的由来。 ↩︎\",\"注：如其名所示，LeastMaxValue 是最小 的最大值，而非实际 最大值。静态成员函数 max()可能产生大于 LeastMaxValue 的值。 ↩︎\",\"注：通常的实现是直接保有一个 std::atomic<std::ptrdiff_t> 私有数据成员，以保证计数修改的原子性。原子类型在我们第五章的内容会详细展开。 ↩︎\"]},\"73\":{\"h\":\"内存模型与原子操作\",\"t\":[\"内存模型定义了多线程程序中，读写操作如何在不同线程之间可见，以及这些操作在何种顺序下执行。内存模型确保程序的行为在并发环境下是可预测的。\",\"原子操作即不可分割的操作。系统的所有线程，不可能观察到原子操作完成了一半。\",\"最基础的概念就是如此，这里不再过多赘述，后续还会详细展开内存模型的问题。\"]},\"74\":{\"h\":\"原子操作\",\"t\":[\"int a = 0; void f(){ ++a; }\",\"显然，++a 是非原子操作，也就是说在多线程中可能会被另一个线程观察到只完成一半。\",\"线程 A 和线程 B 同时开始修改变量 a 的值。\",\"线程 A 对 a 执行递增操作，但还未完成。\",\"在线程 A 完成递增操作之前，线程 B 也执行了递增操作。\",\"线程 C 读取 a 的值。\",\"线程 C 到底读取到多少不确定，a 的值是多少也不确定。显然，这构成了数据竞争，出现了未定义行为。\",\"在之前的内容中，我们讲述了使用很多同步设施，如互斥量，来保护共享资源。\",\"std::mutex m; void f() { std::lock_guard<std::mutex> lc{ m }; ++a; }\",\"通过互斥量的保护，即使 ++a 本身不是原子操作，逻辑上也可视为原子操作。互斥量确保了对共享资源的读写是线程安全的，避免了数据竞争问题。\",\"不过这显然不是我们的重点。我们想要的是一种原子类型，它的所有操作都直接是原子的，不需要额外的同步设施进行保护。C++11 引入了原子类型 std::atomic，在下节我们会详细讲解。\"]},\"75\":{\"h\":\"原子类型\",\"t\":[\"标准原子类型定义在头文件 <atomic> 中。这些类型的操作都是原子的，语言定义中只有这些类型的操作是原子的，虽然也可以用互斥量来模拟原子操作（见上文）。\",\"标准原子类型的实现通常包括一个 is_lock_free() 成员函数，允许用户查询特定原子类型的操作是否是通过直接的原子指令实现（返回 true），还是通过锁来实现（返回 false）。\",\"如果一个线程写入原子对象，同时另一线程从它读取，那么行为有良好定义（数据竞争的细节见内存模型）。\",\"原子操作可以在一些时候代替互斥量，来进行同步操作，也能带来更高的性能。但是如果它的内部使用互斥量实现，那么不可能有性能的提升。\",\"在 C++17 中，所有原子类型都有一个 static constexpr 的数据成员 is_always_lock_free 。如果当前环境上的原子类型 X 是无锁类型，那么 X::is_always_lock_free 将返回 true 。例如：\",\"std::atomic<int>::is_always_lock_free // true 或 false\",\"标准库还提供了一组宏 ATOMIC_xxx_LOCK_FREE ，在编译时对各种整数原子类型是否无锁进行判断。\",\"// (C++11 起) #define ATOMIC_BOOL_LOCK_FREE /* 未指定 */ #define ATOMIC_CHAR_LOCK_FREE /* 未指定 */ #define ATOMIC_CHAR16_T_LOCK_FREE /* 未指定 */ #define ATOMIC_CHAR32_T_LOCK_FREE /* 未指定 */ #define ATOMIC_WCHAR_T_LOCK_FREE /* 未指定 */ #define ATOMIC_SHORT_LOCK_FREE /* 未指定 */ #define ATOMIC_INT_LOCK_FREE /* 未指定 */ #define ATOMIC_LONG_LOCK_FREE /* 未指定 */ #define ATOMIC_LLONG_LOCK_FREE /* 未指定 */ #define ATOMIC_POINTER_LOCK_FREE /* 未指定 */ // (C++20 起) #define ATOMIC_CHAR8_T_LOCK_FREE /* 未指定 */\",\"对于一定有锁的内建原子类型是 0；\",\"对于有时无锁的内建原子类型是 1；\",\"对于一定无锁的内建原子类型是 2。\",\"我们可以使用这些宏来对代码进行编译时的优化和检查，以确保在特定平台上原子操作的性能。例如，如果我们知道某些操作在目标平台上是无锁的，那么我们可以利用这一点进行性能优化。如果这些操作在目标平台上是有锁的，我们可能会选择其它同步机制。\",\"// 检查 std::atomic<int> 是否总是无锁 if constexpr(std::atomic<int>::is_always_lock_free) { std::cout << \\\"当前环境 std::atomic<int> 始终是无锁\\\" << std::endl; } else { std::cout << \\\"当前环境 std::atomic<int> 并不总是无锁\\\" << std::endl; } // 使用 ATOMIC_INT_LOCK_FREE 宏进行编译时检查 #if ATOMIC_INT_LOCK_FREE == 2 std::cout << \\\"int 类型的原子操作一定无锁的。\\\" << std::endl; #elif ATOMIC_INT_LOCK_FREE == 1 std::cout << \\\"int 类型的原子操作有时是无锁的。\\\" << std::endl; #else std::cout << \\\"int 类型的原子操作一定有锁的。\\\" << std::endl; #endif\",\"运行测试。\",\"如你所见，我们写了一个简单的示例，展示了如何使用 C++17 的静态数据成员 is_always_lock_free 和预处理宏来让程序执行不同的代码。\",\"因为 is_always_lock_free 是编译期常量，所以我们可以使用 C++17 引入的 constexpr if ，它可以在编译阶段进行决策，避免了运行时的判断开销，提高了性能。\",\"宏则更是简单了，最基本的预处理器判断，在预处理阶段就选择编译合适的代码。\",\"在实际应用中，如果一个类型的原子操作总是无锁的，我们可以更放心地在性能关键的代码路径中使用它。例如，在高频交易系统、实时系统或者其它需要高并发性能的场景中，无锁的原子操作可以显著减少锁的开销和竞争，提高系统的吞吐量和响应时间。\",\"另一方面，如果发现某些原子类型在目标平台上是有锁的，我们可以考虑以下优化策略：\",\"使用不同的数据结构：有时可以通过改变数据结构来避免对原子操作的依赖。\",\"减少原子操作的频率：通过批处理等技术，减少对原子操作的调用次数。\",\"使用更高效的同步机制：在一些情况下，其它同步机制（如读写锁）可能比原子操作更高效。\",\"当然，其实很多时候根本没这种性能的担忧，我们很多时候使用原子对象只是为了简单方便，比如 std::atomic<bool> 表示状态、std::atomic<int> 进行计数等。即使它们是用了锁，那也是封装好了的，起码用着方便，而不需要在代码中引入额外的互斥量来保护，更加简洁。这也是很正常的需求，各位不但要考虑程序的性能，同时也要考虑代码的简洁性、易用性。即使使用原子类型无法带来效率的提升，那也没有负提升。\",\"除了直接使用 std::atomic 模板外，也可以使用原子类型的别名。这个数量非常之多，见 MSVC STL。\",\"对于标准内建类型的别名，就是在原子类型的类型名前面加上 atomic_ 的前缀：atomic_T。不过 signed 缩写 s、unsigned 缩写 u、long long 缩写 llong。\",\"using atomic_char = atomic<char>; using atomic_schar = atomic<signed char>; using atomic_uchar = atomic<unsigned char>; using atomic_short = atomic<short>; using atomic_ushort = atomic<unsigned short>; using atomic_int = atomic<int>; using atomic_uint = atomic<unsigned int>; using atomic_long = atomic<long>; using atomic_ulong = atomic<unsigned long>; using atomic_llong = atomic<long long>; using atomic_ullong = atomic<unsigned long long>;\",\"通常 std::atomic 对象不可进行复制、移动、赋值，因为它们的复制构造与复制赋值运算符被定义为弃置的。不过可以隐式转换成对应的内置类型，因为它有转换函数。\",\"atomic(const atomic&) = delete; atomic& operator=(const atomic&) = delete; operator T() const noexcept;\",\"可以使用 load()、store()、exchange()、compare_exchange_weak() 和 compare_exchange_strong() 等成员函数对 std::atomic 进行操作。如果是整数类型的特化，还支持 ++、--、+=、-=、&=、|=、^= 、fetch_add、fetch_sub 等操作方式。在后面详细的展开使用。\",\"std::atomic 类模板不仅只能使用标准库为我们定义的特化类型，我们也完全可以自定义类型创建对应的原子对象。不过因为是通用模板，操作仅限 load()、store()、exchange()、compare_exchange_weak() 、 compare_exchange_strong()，以及一个转换函数。\",\"模板 std::atomic 可用任何满足可复制构造 (CopyConstructible)及可复制赋值 (CopyAssignable)的可平凡复制 (TriviallyCopyable)类型 T 实例化。\",\"struct trivial_type { int x{}; float y{}; trivial_type() {} trivial_type(int a, float b) : x{ a }, y{ b } {} trivial_type(const trivial_type& other) = default; trivial_type& operator=(const trivial_type& other) = default; ~trivial_type() = default; };\",\"验证自己的类型是否满足 std::atomic 要求，我们可以使用静态断言：\",\"static_assert(std::is_trivially_copyable<trivial_type>::value, \\\"\\\"); static_assert(std::is_copy_constructible<trivial_type>::value, \\\"\\\"); static_assert(std::is_move_constructible<trivial_type>::value, \\\"\\\"); static_assert(std::is_copy_assignable<trivial_type>::value, \\\"\\\"); static_assert(std::is_move_assignable<trivial_type>::value, \\\"\\\");\",\"程序能通过编译即代表满足要求。如果不满足要求，静态断言求值中第一个表达式求值为 false，则编译错误。显然我们的类型满足要求，我们可以尝试使用一下它：\",\"// 创建一个 std::atomic<trivial_type> 对象 std::atomic<trivial_type> atomic_my_type { trivial_type{ 10, 20.5f } }; // 使用 store 和 load 操作来设置和获取值 trivial_type new_value{ 30, 40.5f }; atomic_my_type.store(new_value); trivial_type loadedValue = atomic_my_type.load(); std::cout << \\\"x: \\\" << loadedValue.x << \\\", y: \\\" << loadedValue.y << std::endl; // 使用 exchange 操作 trivial_type exchanged_value = atomic_my_type.exchange(trivial_type{ 50, 60.5f }); std::cout << \\\"交换前的 x: \\\" << exchanged_value.x << \\\", 交换前的 y: \\\" << exchanged_value.y << std::endl; std::cout << \\\"交换后的 x: \\\" << atomic_my_type.load().x << \\\", 交换后的 y: \\\" << atomic_my_type.load().y << std::endl;\",\"运行测试。\",\"没有问题，不过其实我们的 trivial_type 直接改成：\",\"struct trivial_type { int x; float y; };\",\"运行测试。\",\"也是完全可以的，满足要求。先前只是为了展示一下显式写明的情况。\",\"原子类型的每个操作函数，都有一个内存序参数，这个参数可以用来指定执行顺序，在后面的内容会详细讲述，现在只需要知道操作分为三类：\",\"Store 操作（存储操作）：可选的内存序包括 memory_order_relaxed、memory_order_release、memory_order_seq_cst。\",\"Load 操作（加载操作）：可选的内存序包括 memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_seq_cst。\",\"Read-modify-write（读-改-写）操作：可选的内存序包括 memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_release、memory_order_acq_rel、memory_order_seq_cst。\",\"本节主要广泛介绍 std::atomic，而未展开具体使用。在后续章节中，我们将更详细地讨论一些版本，如 std::atomic<bool>，并介绍其成员函数和使用方法。\",\"最后强调一下：任何 std::atomic 类型，初始化不是原子操作。\"]},\"76\":{\"h\":\"\",\"t\":[\"std::atomic_flag 是最简单的原子类型，这个类型的对象可以在两个状态间切换：设置（true）和清除（false）。它很简单，通常只是用作构建一些库设施，不会单独使用或直接面向普通开发者。\",\"在 C++20 之前，std::atomic_flag 类型的对象需要以 ATOMIC_FLAG_INIT 初始化，可以确保此时对象处于 \\\"清除\\\"（false）状态。\",\"std::atomic_flag f = ATOMIC_FLAG_INIT;\",\"在 C++20 中 std::atomic_flag 的默认构造函数保证对象为“清除”（false）状态，就不再需要使用 ATOMIC_FLAG_INIT。\",\"ATOMIC_FLAG_INIT 其实并不是什么复杂的东西，它在不同的标准库实现中只是简单的初始化：在 MSVC STL 它只是一个 {}，在 libstdc++ 与 libc++ 它只是一个 { 0 }。也就是说我们可以这样初始化：\",\"std::atomic_flag f ATOMIC_FLAG_INIT; std::atomic_flag f2 = {}; std::atomic_flag f3{}; std::atomic_flag f4{ 0 };\",\"使用 ATOMIC_FLAG_INIT 宏只是为了统一，我们知道即可。\",\"当标志对象已初始化，它只能做三件事情：销毁、清除、设置。这些操作对应的函数分别是：\",\"clear() （清除）：将标志对象的状态原子地更改为清除（false）\",\"test_and_set（测试并设置）：将标志对象的状态原子地更改为设置（true），并返回它先前保有的值。\",\"销毁：对象的生命周期结束时，自动调用析构函数进行销毁操作。\",\"每个操作都可以指定内存顺序。clear() 是一个“读-改-写”操作，可以应用任何内存顺序。默认的内存顺序是 memory_order_seq_cst。例如：\",\"f.clear(std::memory_order_release); bool r = f.test_and_set();\",\"将 f 的状态原子地更改为清除（false），指明 memory_order_release 内存序。\",\"将 f 的状态原子地更改为设置（true），并返回它先前保有的值给 r。使用默认的 memory_order_seq_cst 内存序。\",\"不用着急，这里还不是详细展开聊内存序的时候。\",\"std::atomic_flag不可复制不可移动不可赋值。这不是 std::atomic_flag 特有的，而是所有原子类型共有的属性。原子类型的所有操作都是原子的，而赋值和复制涉及两个对象，破坏了操作的原子性。复制构造和复制赋值会先读取第一个对象的值，然后再写入另一个对象。对于两个独立的对象，这里实际上有两个独立的操作，合并这两个操作无法保证其原子性。因此，这些操作是不被允许的。\",\"有限的特性使得 std::atomic_flag 非常适合用作制作自旋锁。\",\"自旋锁可以理解为一种忙等锁，因为它在等待锁的过程中不会主动放弃 CPU，而是持续检查锁的状态。\",\"与此相对，std::mutex 互斥量是一种睡眠锁。当线程请求锁（lock()）而未能获取时，它会放弃 CPU 时间片，让其他线程得以执行，从而有效利用系统资源。\",\"从性能上看，自旋锁的响应更快，但是睡眠锁更加节省资源，高效。\",\"class spinlock_mutex { std::atomic_flag flag{}; public: spinlock_mutex()noexcept = default; void lock()noexcept { while (flag.test_and_set(std::memory_order_acquire)); } void unlock()noexcept { flag.clear(std::memory_order_release); } };\",\"我们可以简单的使用测试一下，它是有效的：\",\"spinlock_mutex m; void f(){ std::lock_guard<spinlock_mutex> lc{ m }; std::cout << \\\"😅😅\\\" << \\\"❤️❤️\\\\n\\\"; }\",\"运行测试。\",\"稍微聊一下原理，我们的 spinlock_mutex 对象中存储的 flag 对象在默认构造时是清除 (false) 状态。在 lock() 函数中调用 test_and_set 函数，它是原子的，只有一个线程能成功调用并将 flag 的状态原子地更改为设置 (true)，并返回它先前的值 (false)。此时，该线程成功获取了锁，退出循环。\",\"当 flag 对象的状态为设置 (true) 时，其它线程调用 test_and_set 函数会返回 true，导致它们继续在循环中自旋，无法退出。直到先前持有锁的线程调用 unlock() 函数，将 flag 对象的状态原子地更改为清除 (false) 状态。此时，等待的线程中会有一个线程成功调用 test_and_set 返回 false，然后退出循环，成功获取锁。\",\"值得注意的是，我们只是稍微的讲一下使用 std::atomic_flag 实现自旋锁。不过并不推荐各位在实践中使用它，具体可参见 Linus Torvalds 的文章。其中有一段话说得很直接：\",\"我再说一遍：不要在用户空间中使用自旋锁，除非你真的知道自己在做什么。请注意，你知道自己在做什么的可能性基本上为零。 I repeat: do not use spinlocks in user space, unless you actually know what you're doing. And be aware that the likelihood that you know what you are doing is basically nil.\",\"然后就是推荐使用 std::mutex、pthread_mutex ，比自旋好的多。\",\"std::atomic_flag 的局限性太强，甚至不能当普通的 bool 标志那样使用。一般最好使用 std::atomic<bool>，下节，我们来使用它。\"]},\"77\":{\"h\":\"\",\"t\":[\"std::atomic<bool> 是最基本的整数原子类型 ，它相较于 std::atomic_flag 提供了更加完善的布尔标志。虽然同样不可复制不可移动，但可以使用非原子的 bool 类型进行构造，初始化为 true 或 false，并且能从非原子的 bool 对象赋值给 std::atomic<bool>：\",\"std::atomic<bool> b{ true }; b = false;\",\"不过这个 operator= 不同于通常情况，赋值操作 b = false 返回一个普通的 bool 值。\",\"这个行为不仅仅适用于std::atomic<bool>，而是适用于所有std::atomic类型。\",\"如果原子变量的赋值操作返回了一个引用，那么依赖这个结果的代码需要显式地进行加载（load），以确保数据的正确性。例如：\",\"std::atomic<bool>b {true}; auto& ref = (b = false); // 假设返回 atomic 引用 bool flag = ref.load(); // 那就必须显式调用 load() 加载\",\"通过返回非原子值进行赋值，可以避免多余的加载（load）过程，得到实际存储的值。\",\"std::atomic<bool> b{ true }; bool new_value = (b = false); // new_value 将是 false\",\"使用 store 原子的替换当前对象的值，远好于 std::atomic_flag 的 clear()。test_and_set() 也可以换为更加通用常见的 exchange，它可以原子的使用新的值替换已经存储的值，并返回旧值。\",\"获取 std::atomic<bool> 的值有两种方式，调用 load() 函数，或者隐式转换。\",\"store 是一个存储操作、load 是一个加载操作、exchange 是一个“读-改-写”操作：\",\"std::atomic<bool> b; bool x = b.load(std::memory_order_acquire); b.store(true); x = b.exchange(false, std::memory_order_acq_rel);\",\"std::atomic<bool> 提供多个“读-改-写”的操作，exchange 只是其中之一。它还提供了一种存储方式：当前值与预期一致时，存储新值。\",\"这种操作叫做“比较/交换”，它的形式表现为 compare_exchange_weak() 和 compare_exchang_strong()\",\"compare_exchange_weak：尝试将原子对象的当前值与预期值进行比较[1]，如果相等则将其更新为新值并返回 true；否则，将原子对象的值加载进 expected（进行加载操作）并返回 false。此操作可能会由于某些硬件的特性而出现假失败[2]，需要在循环中重试。\",\"std::atomic<bool> flag{ false }; bool expected = false; while (!flag.compare_exchange_weak(expected, true));\",\"运行测试。\",\"返回 false 即代表出现了假失败，因此需要在循环中重试。。\",\"compare_exchange_strong：类似于 compare_exchange_weak，但不会出现假失败，因此不需要重试。适用于需要确保操作成功的场合。\",\"std::atomic<bool> flag{ false }; bool expected = false; void try_set_flag() { // 尝试将 flag 设置为 true，如果当前值为 false if (flag.compare_exchange_strong(expected, true)) { std::cout << \\\"flag 为 false，设为 true。\\\\n\\\"; } else { std::cout << \\\"flag 为 true, expected 设为 true。\\\\n\\\"; } }\",\"运行测试。\",\"假设有两个线程运行 try_set_flag 函数，那么第一个线程调用 compare_exchange_strong 将原子对象 flag 设置为 true。第二个线程调用 compare_exchange_strong，当前原子对象的值为 true，而 expected 为 false，不相等，将原子对象的值设置给 expected。此时 flag 与 expected 均为 true。\",\"与 exchange 的另一个不同是，compare_exchange_weak 和 compare_exchange_strong 允许指定成功和失败情况下的内存序。这意味着你可以根据成功或失败的情况，为原子操作指定不同的内存序。\",\"std::atomic<bool> data{ false }; bool expected = false; // 成功时的内存序为 memory_order_release，失败时的内存序为 memory_order_acquire if (data.compare_exchange_weak(expected, true, std::memory_order_release, std::memory_order_acquire)) { // 操作成功 } else { // 操作失败 }\",\"另一个简单的原子类型是特化的原子指针，即：std::atomic<T*>，下一节我们来看看它是如何工作的。\"]},\"78\":{\"h\":\"\",\"t\":[\"std::atomic<T*> 是一个原子指针类型，T 是指针所指向的对象类型。操作是针对 T 类型的指针进行的。虽然 std::atomic<T*> 不能被拷贝和移动，但它可以通过符合类型的指针进行构造和赋值。\",\"std::atomic<T*> 拥有以下成员函数：\",\"load()：以原子方式读取指针值。\",\"store()：以原子方式存储指针值。\",\"exchange()：以原子方式交换指针值。\",\"compare_exchange_weak() 和 compare_exchange_strong()：以原子方式比较并交换指针值。\",\"这些函数接受并返回的类型都是 T*。此外，std::atomic<T*> 还提供了以下操作：\",\"fetch_add：以原子方式增加指针的值。（p.fetch_add(1) 会将指针 p 向前移动一个元素，并返回操作前的指针值）\",\"fetch_sub：以原子方式减少指针的值。返回操作前的指针值。\",\"operator+= 和 operator-=：以原子方式增加或减少指针的值。返回操作前的指针值。\",\"这些操作确保在多线程环境下进行安全的指针操作，避免数据竞争和并发问题。\",\"使用示例如下：\",\"struct Foo {}; Foo array[5]{}; std::atomic<Foo*> p{ array }; // p 加 2，并返回原始值 Foo* x = p.fetch_add(2); assert(x == array); assert(p.load() == &array[2]); // p 减 1，并返回原始值 x = (p -= 1); assert(x == &array[1]); assert(p.load() == &array[1]); // 函数也允许内存序作为给定函数的参数 p.fetch_add(3, std::memory_order_release);\",\"这个特化十分简单，我们无需过多赘述。\"]},\"79\":{\"h\":\"\",\"t\":[\"在前文中，我们多次提到 std::shared_ptr：\",\"第四章中提到：多个线程能在不同的 shared_ptr 对象上调用所有成员函数[3]（包含复制构造函数与复制赋值）而不附加同步，即使这些实例是同一对象的副本且共享所有权也是如此。若多个执行线程访问同一 shared_ptr 对象而不同步，且任一线程使用 shared_ptr 的非 const 成员函数，则将出现数据竞争；std::atomic<shared_ptr> 能用于避免数据竞争。文档。\",\"一个在互联网上非常热门的八股问题是：std::shared_ptr 是不是线程安全？\",\"显然，它并不是完全线程安全的，尽管在多线程环境中有很大的保证，但这还不够。在 C++20 中，原子模板 std::atomic 引入了一个偏特化版本 std::atomic<std::shared_ptr> 允许用户原子地操纵 shared_ptr 对象。因为它是 std::atomic 的特化版本，即使我们还没有深入讲述它，也能知道它是原子类型，这意味着它的所有操作都是原子操作。\",\"若多个执行线程不同步地同时访问同一std::shared_ptr 对象，且任何这些访问使用了 shared_ptr 的非 const 成员函数，则将出现数据竞争，除非通过 std::atomic<std::shared_ptr> 的实例进行所有访问。\",\"class Data { public: Data(int value = 0) : value_(value) {} int get_value() const { return value_; } void set_value(int new_value) { value_ = new_value; } private: int value_; }; auto data = std::make_shared<Data>(); void writer(){ for (int i = 0; i < 10; ++i) { std::shared_ptr<Data> new_data = std::make_shared<Data>(i); data.swap(new_data); // 调用非 const 成员函数 std::this_thread::sleep_for(100ms); } } void reader(){ for (int i = 0; i < 10; ++i) { if (data) { std::cout << \\\"读取线程值: \\\" << data->get_value() << std::endl; } else { std::cout << \\\"没有读取到数据\\\" << std::endl; } std::this_thread::sleep_for(100ms); } } int main(){ std::thread writer_thread{ writer }; std::thread reader_thread{ reader }; writer_thread.join(); reader_thread.join(); }\",\"运行测试。\",\"以上这段代码是典型的线程不安全，它满足：\",\"多个线程不同步地同时访问同一std::shared_ptr 对象\",\"任一线程使用 shared_ptr 的非 const 成员函数\",\"那么为什么呢？为什么满足这些概念就是线程不安全呢？为了理解这些概念，首先需要了解 shared_ptr 的内部实现：\",\"shared_ptr 的通常实现只保有两个指针\",\"指向底层元素的指针（get()) 所返回的指针）\",\"指向控制块 的指针\",\"控制块是一个动态分配的对象，其中包含：\",\"指向被管理对象的指针或被管理对象本身\",\"删除器（类型擦除）\",\"分配器（类型擦除）\",\"持有被管理对象的 shared_ptr 的数量\",\"涉及被管理对象的 weak_ptr 的数量\",\"控制块是线程安全的，这意味着多个线程可以安全地操作引用计数和访问管理对象，即使这些 shared_ptr 实例是同一对象的副本且共享所有权也是如此。因此，多个线程可以安全地创建、销毁和复制 shared_ptr 对象，因为这些操作仅影响控制块中的引用计数。\",\"然而，shared_ptr 对象实例本身并不是线程安全的。shared_ptr 对象实例包含一个指向控制块的指针和一个指向底层元素的指针。这两个指针的操作在多个线程中并没有同步机制。因此，如果多个线程同时访问同一个 shared_ptr 对象实例并调用非 const 成员函数（如 reset 或 operator=），这些操作会导致对这些指针的并发修改，进而引发数据竞争。\",\"如果不是同一 shared_ptr 对象，每个线程读写的指针也不是同一个，控制块又是线程安全的，那么自然不存在数据竞争，可以安全的调用所有成员函数。\",\"使用 std::atomic<shared_ptr> 修改：\",\"std::atomic<std::shared_ptr<Data>> data = std::make_shared<Data>(); void writer() { for (int i = 0; i < 10; ++i) { std::shared_ptr<Data> new_data = std::make_shared<Data>(i); data.store(new_data); // 原子地替换所保有的值 std::this_thread::sleep_for(10ms); } } void reader() { for (int i = 0; i < 10; ++i) { if (auto sp = data.load()) { std::cout << \\\"读取线程值: \\\" << sp->get_value() << std::endl; } else { std::cout << \\\"没有读取到数据\\\" << std::endl; } std::this_thread::sleep_for(10ms); } }\",\"很显然，这是线程安全的，store 是原子操作，而 sp->get_value() 只是个读取操作。\",\"我知道，你肯定会想着：能不能调用 load() 成员函数原子地返回底层的 std::shared_ptr 再调用 swap 成员函数？\",\"可以，但是没有意义，因为 load() 成员函数返回的是底层 std::shared_ptr 的副本，也就是一个临时对象。对这个临时对象调用 swap 并不会改变 data 本身的值，因此这种操作没有实际意义，尽管这不会引发数据竞争（因为是副本）。\",\"由于我们没有对读写操作进行同步，只是确保了操作的线程安全，所以多次运行时可能会看到一些无序的打印，这是正常的。\",\"不过事实上 std::atomic<std::shared_ptr> 的功能相当有限，单看它提供的修改接口（=、store、load、exchang）就能明白。如果要操作其保护的共享指针指向的资源还是得 load() 获取底层共享指针的副本。此时再进行操作时就得考虑 std::shared_ptr 本身在多线程的支持了。\",\"在使用 std::atomic<std::shared_ptr> 的时候，我们要注意第三章中关于共享数据的一句话：\",\"切勿将受保护数据的指针或引用传递到互斥量作用域之外，不然保护将形同虚设。\",\"原子类型也有类似的问题，以下是一个例子：\",\"std::atomic<std::shared_ptr<int>> ptr = std::make_shared<int>(10); *ptr.load() = 100;\",\"调用 load() 成员函数，原子地返回底层共享指针的副本std::shared_ptr\",\"解引用，等价 *get()，返回了 int&\",\"直接修改这个引用所指向的资源。\",\"在第一步时，已经脱离了 std::atomic 的保护，第二步就获取了被保护的数据的引用，第三步进行了修改，这导致了数据竞争。当然了，这种做法非常的愚蠢，只是为了表示，所谓的线程安全，也是要靠开发者的正确使用。\",\"正确的用法如下：\",\"std::atomic<std::shared_ptr<int>> ptr = std::make_shared<int>(10); std::atomic_ref<int> ref{ *ptr.load() }; ref = 100; // 原子地赋 100 给被引用的对象\",\"通过使用 std::atomic_ref 我们得以确保在修改共享资源时保持操作的原子性，从而避免了数据竞争。\",\"最后再来稍微聊一聊提供的 wait、notify_one 、notify_all 成员函数。这并非是 std::atomic<shared_ptr> 专属，C++20 以后任何 atomic 的特化都拥有这些成员函数，使用起来也都十分的简单，我们这里用一个简单的例子为你展示一下：\",\"std::atomic<std::shared_ptr<int>> ptr = std::make_shared<int>(); void wait_for_wake_up(){ std::osyncstream{ std::cout } << \\\"线程 \\\" << std::this_thread::get_id() << \\\" 阻塞，等待更新唤醒\\\\n\\\"; // 等待 ptr 变为其它值 ptr.wait(ptr.load()); std::osyncstream{ std::cout } << \\\"线程 \\\" << std::this_thread::get_id() << \\\" 已被唤醒\\\\n\\\"; } void wake_up(){ std::this_thread::sleep_for(5s); // 更新值并唤醒 ptr.store(std::make_shared<int>(10)); ptr.notify_one(); }\"]},\"80\":{\"h\":\"内存次序\"},\"81\":{\"h\":\"前言\",\"t\":[\"事实上我们在前面就用到了不少的内存次序，只不过一直没详细展开讲解。\",\"在开始学习之前，我们需要强调一些基本的认识：\",\"内存次序是非常底层知识：对于普通开发者来说，了解内存次序并非硬性需求。如果您主要关注业务开发，可以直接跳过本节内容。如果您对内存次序感兴趣，则需要注意其复杂性和难以观察的特性，这将使学习过程具有一定挑战性。\",\"内存次序错误的使用难以察觉：即使通过多次（数以万计）运行也难以发现。这是因为许多内存次序问题是由于极端的、少见的情况下的竞争条件引起的，而这些情况很难被重现。此外，即使程序在某些平台上运行正常，也不能保证它在其他平台上也能表现良好，因为不同的 CPU 和编译器可能对内存操作的顺序有不同的处理（例如 x86 架构内存模型：Total Store Order (TSO)，是比较严格的内存模型）。因此，开发者必须依赖自己的知识和经验，以及可能的测试和调试技术，来发现和解决内存次序错误。\",\"错误难以被我们观察到的原因其实可以简单的说：\",\"CPU 与编译器不是神经病，没有好处不会闲的没事给你指令重排。\",\"编译器重排：编译器在编译代码时，为了提高性能，可以按照一定规则重新安排代码的执行顺序。例如，可以将不相关的指令重排，使得 CPU 流水线更加高效地执行指令。编译器优化需要遵守一个“如同规则（as-if rule）”，即不可改变可观察的副作用。\",\"CPU 重排：CPU 在运行程序时，也会对指令进行重排，以提高执行效率，减少等待时间。这种重排通常遵循一些硬件层面的优化规则，如内存访问的优化。\",\"你们可能还有疑问：“单线程能不能指令重排？”\",\"CPU 的指令重排必须遵循一定的规则，以确保程序的可观察副作用不受影响。对于单线程程序，CPU 会保证外部行为的一致性。对于多线程程序，需要开发者使用同步原语来显式地控制内存操作的顺序和可见性，确保多线程环境下的正确性。而标准库中提供的原子对象的原子操作，还可以设置内存次序。\",\"那有没有可能：\",\"“end 重排到 start 前面了！指令重排了！”\",\"这也就是前面说的，把 CPU 与编译器当神经病。各位写代码难道还要考虑下面这段，会不会指令重排导致先输出 end 吗？这显然不现实。\",\"print(\\\"start\\\"); // 1 print(\\\"end\\\"); // 2\",\"不禁止就是有可能，但是我们无需在乎，就算真的 CPU 将 end 重排到 start 前面了，也得在可观测行为发生前回溯了。所以我一直在强调，这些东西，我们无需在意。\",\"好了，到此，基本认识也就足够了，以上的示例更多的是泛指，知道其表达的意思就好，这些还是简单直接且符合直觉的。\"]},\"82\":{\"h\":\"可见\",\"t\":[\"可见 是 C++ 多线程并发编程中的一个重要概念，它描述了一个线程中的数据修改对其他线程的可见程度。具体来说，如果线程 A 对变量 x 进行了修改，那么其他线程 B 是否能够看到线程 A 对 x 的修改，就涉及到可见的问题。\",\"在讨论多线程的内存模型和执行顺序时，虽然经常会提到 CPU 重排、编译器优化、缓存等底层细节，但真正核心的概念是可见，而不是这些底层实现细节。\",\"C++ 标准中的可见：\",\"如果线程 A 对变量 x 进行了修改，而线程 B 能够读取到线程 A 对 x 的修改，那么我们说线程 B 能看到线程 A 对 x 的修改。也就是说，线程 A 的修改对线程 B 是可见的。\",\"C++ 标准通过内存序（memory order）来定义如何确保这种可见，而不必直接关心底层的 CPU 和编译器的具体行为。内存序提供了操作之间的顺序关系，确保即使存在 CPU 重排、编译器优化或缓存问题，线程也能正确地看到其他线程对共享数据的修改。\",\"例如，通过使用合适的内存序（如 memory_order_release 和 memory_order_acquire），可以确保线程 A 的写操作在其他线程 B 中是可见的，从而避免数据竞争问题。\",\"总结：\",\"可见 关注的是线程之间的数据一致性，而不是底层的实现细节。\",\"使用 C++ 的内存序机制可以确保数据修改的可见，而不必过多关注具体的 CPU 和编译器行为。\",\"这种描述方式可以帮助更清楚地理解和描述多线程并发编程中如何通过 C++ 标准的内存模型来确保线程之间的数据一致性，而无需太多关注底层细节。\",\"我知道各位肯定有疑问，我们大多数时候写多线程代码都从来没使用过内存序，一般都是互斥量、条件变量等高级同步设施，这没有可见性的问题吗？\",\"没有，这些设施自动确保数据的可见性。例如： std::mutex 的 unlock() 保证：\",\"此操作同步于任何后继的取得同一互斥体所有权的锁定操作。\",\"也就是 unlock()同步于lock()。\",\"“同步于”：操作 A 的完成会确保操作 B 在其之后的执行中，能够看到操作 A 所做的所有修改。\",\"也就是说：\",\"std::mutex 的 unlock() 操作同步于任何随后的 lock() 操作。这意味着，线程在调用 unlock() 时，对共享数据的修改会对之后调用 lock() 的线程可见。\"]},\"83\":{\"h\":\"\",\"t\":[\"std::memory_order 是一个枚举类型，用来指定原子操作的内存顺序，影响这些操作的行为。\",\"typedef enum memory_order { memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst } memory_order; // C++20 起则为： enum class memory_order : /* 未指明 */ { relaxed, consume, acquire, release, acq_rel, seq_cst }; inline constexpr memory_order memory_order_relaxed = memory_order::relaxed; inline constexpr memory_order memory_order_consume = memory_order::consume; inline constexpr memory_order memory_order_acquire = memory_order::acquire; inline constexpr memory_order memory_order_release = memory_order::release; inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel; inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;\",\"这 6 个常量，每一个常量都表示不同的内存次序。\",\"大体来说我们可以将它们分为三类。\",\"memory_order_relaxed 宽松定序：不是定序约束，仅对此操作要求原子性。\",\"memory_order_seq_cst 序列一致定序，这是库中所有原子操作的默认行为，也是最严格的内存次序，是绝对安全的。\",\"剩下的就是第三类。\"]},\"84\":{\"h\":\"其它概念\"},\"85\":{\"h\":\"和 的内存模型：强一致性与弱一致性\",\"t\":[\"内存模型是软件与实现之间的一种约定契约。它定义了在多线程或并发环境中，如何对内存操作的顺序和一致性进行规范，以确保程序的正确性和可靠性。\",\"C++ 标准为我们定义了 C++ 标准内存模型，使我们能够无需关心底层硬件环境就编写出跨平台的应用程序。不过，了解底层硬件架构的内存模型对扩展知识面和深入理解编程细节也非常有帮助。\",\"最经典与常见的两种 CPU 指令集架构就是：x86 与 ARM。\",\"x86 架构：是一种复杂指令集计算（CISC）架构，因其强大的性能被广泛应用于桌面电脑、笔记本电脑和服务器中。x86 架构采用的是 TSO（Total Store Order）内存一致性模型，是一种强一致性模型，简化了多线程编程中的内存同步问题（后文中会提到）。\",\"ARM 架构：是一种精简指令集计算（RISC）架构，因其高能效和低功耗特点广泛应用于移动设备、嵌入式系统和物联网设备中。ARM 架构采用的是弱序内存模型（weakly-ordered memory），允许更灵活的内存优化，但这需要程序员使用内存屏障等机制来确保正确性。\",\"这两种架构在设计理念和应用领域上存在显著差异，这也是它们在不同应用场景中表现出色的原因。\",\"如果你从事嵌入式系统或者学术研究等，可能也听说过 RISC-V 架构，它目前在国内的应用也逐渐增多。\",\"RISC-V 是一种开源的精简指令集计算（RISC）架构，旨在提供一种高效、模块化且开放的指令集。与 x86 和 ARM 架构不同，RISC-V 的设计目标是简化指令集，同时保持高度的灵活性和扩展性。它在内存模型方面也有自己独特的特性。\",\"RISC-V 采用的也是弱序内存模型（weakly-ordered memory model），这与 x86 的强一致性模型（TSO）和 ARM 的弱一致性模型有所不同。你可能会有疑问：\",\"ARM 和 RISC-V 都是弱序内存模型，为什么不同？\",\"各位一定要区分，这种强弱其实也只是一种分类而已，不同的指令集架构大多都还是有所不同的，并不会完全一样。例如： x86 的 TSO（Total Store Order）是强一致性模型的一种，但并不是所有强一致性模型都是 TSO。\"]},\"86\":{\"h\":\"宽松定序\"},\"87\":{\"h\":\"释放-获取定序\"},\"88\":{\"h\":\"释放-消费定序\"},\"89\":{\"h\":\"序列一致定序\"},\"90\":{\"h\":\"与 的关系\",\"t\":[\"注： 比较和复制是逐位的（类似 std::memcmp 和 std::memcpy）；不使用构造函数、赋值运算符或比较运算符。 ↩︎\",\"注：即使 expected 与原子对象的值相等，表现如同 *this != expected↩︎\",\"不用感到奇怪，之所以多个线程通过 shared_ptr 的副本可以调用一切成员函数，甚至包括非 const 的成员函数 operator=、reset，是因为 shared_ptr 的控制块是线程安全的。 ↩︎\"]},\"91\":{\"h\":\"协程\"},\"92\":{\"h\":\"前言\",\"t\":[\"既然是“现代” C++ 并发编程教程，怎么能不聊协程呢？\",\"C++20 引入了协程语法，新增了三个用作协程的关键字：co_await、co_yield、co_return。但并未给出标准协程库，协程库在 C++23 被引入。\",\"希望您拥有 gcc14、clang19，Visual Studio 2022 17.11。\",\"我们假设您对 C++20 的协程一无所知、假设您对协程这个概念一无所知、假设您不了解其它语言的协程实现（如 Python、java）。\",\"绝大多数人对协程基本可以说是一无所知，但是应该都听过这个名字，大概是因为这些编程语言都在新版本中引入它作为核心语言特性。\",\"这带来了许多的热度，不过这并不完全算是好事，许多的营销号一样的讲述，基本全部都是错误的。\",\"据我所知，在我在 B站发布正经 C++20 协程的教学视频之前，几乎所有打着 C++ 旗号说什么协程的，都是胡言乱语。不过也有一些不错的，如：等疾风、happyyang的百草园，都出过至少算作正经的 C++20 协程的教学视频。\",\"C++20 的协程是复杂的。\",\"不管是使用上还是概念上，引入了许多新颖的做法。\"]},\"93\":{\"h\":\"阅读须知\",\"t\":[\" 本套教程侧重点在于使用 C++ 并发支持库进行多线程编程。我们假设读者最低水平为：C++11 + STL + template，可能没有接触过 C++ 标准并发库，假设略微了解操作系统基本知识。\",\" 我们强调了模板，因为并发支持库的很多设施其实现是较为简单的，概念与使用，再结合源码讲解会更加简单直观，然而要想阅读学习源码，模板的知识必不可少。不需要模板的水平有多高，也不需要会什么元编程，但是基本的需求得能做到，得会，这里推荐一下：《现代C++模板教程》。\",\" 本教程不保证你学习之后的成果，不过依然可以自信地说：本教程在中文社区的同类型教程中是绝对的第一。事实上只需要一句话就可以表达了——伟大无需多言。\"]},\"94\":{\"h\":\"学习注意事项\",\"t\":[\" 我们的教程中常包含许多外部链接，这并非当前描述不足或者不够严谨，而是为了考虑读者的水平和可能的扩展学习需求。同时，也希望能让读者避免获取二手知识与理解，我们提供的链接基本都是较为专业的文档或官方网站。\",\" 虽然教程名为《现代 C++ 并发编程教程》，但我们也扩展涉及了许多其他知识，包括但不限于：Win32、POSIX API；MSVC STL、libstdc++、libc++ 对标准库的实现；GCC 与 MSVC 的编译器扩展，以及 Clang 对它们的兼容；使用 CMake + Qt 构建带 UI 的程序，展示多线程异步的必要性；不同架构的内存模型（例如 x86 架构内存模型：Total Store Order (TSO)，较为严格的内存模型）。\",\" 既然强调了“现代”，那自然是全方面的，具体的读者会在学习中感受到的。\",\" 另外我们的代码都会测试三大编译器 Clang、GCC、MSVC。通常都会是最新的，Clang18、GCC14。我们的教程中常常会提供 Complier Explorer 的运行测试链接以确保正确性，以及方便读者的测试与学习。如果你对此网站的使用不熟悉，可以阅读使用文档。\"]},\"95\":{\"h\":\"代码风格\",\"t\":[\" 我们的代码风格较为简洁明了，命名全部使用下划线连接，而不是驼峰命名法。花括号通常只占一行，简短的代码可以不额外占行。一般初始化时使用 {}，而非 () 或者 = 。这样简单直观，避免歧义和许多问题。#include 引入头文件时需要在尖括号或引号前后加空格。\",\"#include <iostream> struct move_only{ move_only() { std::puts(\\\"默认构造\\\"); } move_only(move_only&&)noexcept { std::puts(\\\"移动构造\\\"); } move_only& operator=(move_only&&) noexcept { std::puts(\\\"移动赋值\\\"); return *this; } move_only(const move_only&) = delete; }; int main(){ move_only m{}; char buffer[1024]{} // 全部初始化为 0 }\",\"如果是标量类型，可能考虑使用复制初始化，而非 {}，如：int n = 0;。\"]},\"96\":{\"h\":\"总结\",\"t\":[\" 本教程长期维护，接受 pr 与 issue。\",\" 好了，稍微了解了一下，我们可以开始进入正式的学习内容了。\"]},\"97\":{\"h\":\"std::thread 的构造-源码解析\",\"t\":[\"我们这单章是为了专门解释一下 C++11 引入的 std::thread 是如何构造的，是如何创建线程传递参数的，让你彻底了解这个类。\",\"我们以 MSVC 实现的 std::thread 代码进行讲解，MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 C++14，出于某些原因 C++17 的一些库（如 invoke， _v 变量模板）被向后移植到了 C++14 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。\"]},\"98\":{\"h\":\"的数据成员\",\"t\":[\"了解一个庞大的类，最简单的方式就是先看它的数据成员有什么。\",\"std::thread 只保有一个私有数据成员 _Thr：\",\"private: _Thrd_t _Thr;\",\"_Thrd_t 是一个结构体，它保有两个数据成员：\",\"using _Thrd_id_t = unsigned int; struct _Thrd_t { // thread identifier for Win32 void* _Hnd; // Win32 HANDLE _Thrd_id_t _Id; };\",\"结构很明确，这个结构体的 _Hnd 成员是指向线程的句柄，_Id 成员就是保有线程的 ID。\",\"在64 位操作系统，因为内存对齐，指针 8 ，无符号 int 4，这个结构体 _Thrd_t 就是占据 16 个字节。也就是说 sizeof(std::thread) 的结果应该为 16。\"]},\"99\":{\"h\":\"的构造函数\",\"t\":[\"std::thread 有四个构造函数，分别是：\",\"默认构造函数，构造不关联线程的新 std::thread 对象。\",\"thread() noexcept : _Thr{} {}\",\"值初始化了数据成员 _Thr ，这里的效果相当于给其成员 _Hnd 和 _Id 都进行零初始化。\",\"移动构造函数，转移线程的所有权，构造 other 关联的执行线程的 std::thread 对象。此调用后 other 不再表示执行线程失去了线程的所有权。\",\"thread(thread&& _Other) noexcept : _Thr(_STD exchange(_Other._Thr, {})) {}\",\"_STD 是一个宏，展开就是 ::std::，也就是 ::std::exchange，将 _Other._Thr 赋为 {} （也就是置空），返回 _Other._Thr 的旧值用以初始化当前对象的数据成员 _Thr。\",\"复制构造函数被定义为弃置的，std::thread 不可复制。两个 std::thread 不可表示一个线程，std::thread 对线程资源是独占所有权。\",\"thread(const thread&) = delete;\",\"构造新的 std::thread 对象并将它与执行线程关联。表示新的执行线程开始执行。\",\"template <class _Fn, class... _Args, enable_if_t<!is_same_v<_Remove_cvref_t<_Fn>, thread>, int> = 0> _NODISCARD_CTOR_THREAD explicit thread(_Fn&& _Fx, _Args&&... _Ax) { _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...); }\",\"前三个构造函数都没啥要特别聊的，非常简单，只有第四个构造函数较为复杂，且是我们本章重点，需要详细讲解。（注意 MSVC 使用标准库的内容很多时候不加 std::，脑补一下就行）\",\"如你所见，这个构造函数本身并没有做什么，它只是一个可变参数成员函数模板，增加了一些 SFINAE 进行约束我们传入的可调用对象的类型不能是 std::thread。关于这个约束你可能有问题，因为 std::thread 他并没有 operator() 的重载，不是可调用类型，这个 enable_if_t 的意义是什么呢？其实很简单，如下：\",\"struct X{ X(X&& x)noexcept{} template <class Fn, class... Args> X(Fn&& f,Args&&...args){} X(const X&) = delete; }; X x{ [] {} }; X x2{ x }; // 选择到了有参构造函数，不导致编译错误\",\"以上这段代码可以正常的通过编译。这是重载决议的事情，我们知道，std::thread 是不可复制的，这种代码自然不应该让它通过编译，选择到我们的有参构造，所以我们添加一个约束让其不能选择到我们的有参构造：\",\"template <class Fn, class... Args, std::enable_if_t<!std::is_same_v<std::remove_cvref_t<Fn>, X>, int> = 0>\",\"这样，这段代码就会正常的出现编译错误，信息如下：\",\"error C2280: “X::X(const X &)”: 尝试引用已删除的函数 note: 参见“X::X”的声明 note: “X::X(const X &)”: 已隐式删除函数\",\"也就满足了我们的要求，重载决议选择到了弃置复制构造函数产生编译错误，这也就是源码中添加约束的目的。\",\"而构造函数体中调用了一个函数 _Start，将我们构造函数的参数全部完美转发，去调用它，这个函数才是我们的重点，如下：\",\"template <class _Fn, class... _Args> void _Start(_Fn&& _Fx, _Args&&... _Ax) { using _Tuple = tuple<decay_t<_Fn>, decay_t<_Args>...>; auto _Decay_copied = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...); constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{}); _Thr._Hnd = reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id)); if (_Thr._Hnd) { // ownership transferred to the thread (void) _Decay_copied.release(); } else { // failed to start thread _Thr._Id = 0; _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN); } }\",\"它也是一个可变参数成员函数模板，接受一个可调用对象 _Fn 和一系列参数 _Args... ，这些东西用来创建一个线程。\",\"using _Tuple = tuple<decay_t<_Fn>, decay_t<_Args>...>\",\"定义了一个元组类型 _Tuple ，它包含了可调用对象和参数的类型，这里使用了 decay_t 来去除了类型的引用和 cv 限定。\",\"auto _Decay_copied = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...)\",\"使用 make_unique 创建了一个独占指针，指向的是 _Tuple 类型的对象，存储了传入的函数对象和参数的副本。\",\"constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{})\",\"调用 _Get_invoke 函数，传入 _Tuple 类型和一个参数序列的索引序列（为了遍历形参包）。这个函数用于获取一个函数指针，指向了一个静态成员函数 _Invoke，它是线程实际执行的函数。这两个函数都非常的简单，我们来看看：\",\" template <class _Tuple, size_t... _Indices> _NODISCARD static constexpr auto _Get_invoke(index_sequence<_Indices...>) noexcept { return &_Invoke<_Tuple, _Indices...>; } template <class _Tuple, size_t... _Indices> static unsigned int __stdcall _Invoke(void* _RawVals) noexcept /* terminates */ { // adapt invoke of user's callable object to _beginthreadex's thread procedure const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals)); _Tuple& _Tup = *_FnVals.get(); // avoid ADL, handle incomplete types _STD invoke(_STD move(_STD get<_Indices>(_Tup))...); _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI return 0; }\",\"_Get_invoke 函数很简单，就是接受一个元组类型，和形参包的索引，传递给 _Invoke 静态成员函数模板，实例化，获取它的函数指针。\",\"它的形参类型我们不再过多介绍，你只需要知道 index_sequence 这个东西可以用来接收一个由 make_index_sequence 创建的索引形参包，帮助我们进行遍历元组即可。示例代码。\",\"_Invoke 是重中之重，它是线程实际执行的函数，如你所见它的形参类型是 void* ，这是必须的，要符合 _beginthreadex 执行函数的类型要求。虽然是 void*，但是我可以将它转换为 _Tuple* 类型，构造一个独占智能指针，然后调用 get() 成员函数获取底层指针，解引用指针，得到元组的引用初始化_Tup 。\",\"此时，我们就可以进行调用了，使用 std::invoke + std::move（默认移动） ，这里有一个形参包展开，_STD get<_Indices>(_Tup))...，_Tup 就是 std::tuple 的引用，我们使用 std::get<> 获取元组存储的数据，需要传入一个索引，这里就用到了 _Indices。展开之后，就等于 invoke 就接受了我们构造 std::thread 传入的可调用对象，调用可调用对象的参数，invoke 就可以执行了。\",\"_Thr._Hnd = reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id))\",\"调用 _beginthreadex 函数来启动一个线程，并将线程句柄存储到 _Thr._Hnd 中。传递给线程的参数为 _Invoker_proc（一个静态函数指针，就是我们前面讲的 _Invoke）和 _Decay_copied.get()（存储了函数对象和参数的副本的指针）。\",\"if (_Thr._Hnd) {\",\"如果线程句柄 _Thr._Hnd 不为空，则表示线程已成功启动，将独占指针的所有权转移给线程。\",\"(void) _Decay_copied.release()\",\"释放独占指针的所有权，因为已经将参数传递给了线程。\",\"} else { // failed to start thread\",\"如果线程启动失败，则进入这个分支\",\"_Thr._Id = 0;\",\"将线程ID设置为0。\",\"_Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);\",\"抛出一个 C++ 错误，表示资源不可用，请再次尝试。\"]},\"100\":{\"h\":\"总结\",\"t\":[\"需要注意，libstdc++ 和 libc++ 可能不同，就比如它们 64 位环境下 sizeof(std::thread) 的结果就可能是 8。libstdc++ 的实现只保有一个 std::thread::id。参见。不过实测 gcc 不管是 win32 还是 POSIX 线程模型，线程对象的大小都是 8，宏 _GLIBCXX_HAS_GTHREADS 的值都为 1（GThread）。\",\" class thread { public: #ifdef _GLIBCXX_HAS_GTHREADS using native_handle_type = __gthread_t; #else using native_handle_type = int; #endif\",\"__gthread_t 即 void*。\",\"我们这里的源码解析涉及到的 C++ 技术很多，我们也没办法每一个都单独讲，那会显得文章很冗长，而且也不是重点。\",\"相信你也感受到了，不会模板，你阅读标准库源码，是无稽之谈，市面上很多教程教学，教导一些实现容器，过度简化了，真要去出错了去看标准库的代码，那是不现实的。不需要模板的水平有多高，也不需要会什么元编程，但是基本的需求得能做到，得会，这里推荐一下：现代C++模板教程。\",\"学习完了也不要忘记了回答最初的问题：\",\"如何做到的默认按值复制？\",\"_Start 的第一行代码展示了这一点。我们将传入的所有参数包装成一个元组类型，这些类型先经过 decay_t 处理，去除了引用与 cv 限定，自然就实现了默认复制。\",\"using _Tuple = tuple<decay_t<_Fn>, decay_t<_Args>...>;\",\"为什么需要 std::ref ？\",\"实现中将类型先经过 decay 处理，如果要传递引用，则必须用类包装一下才行，使用 std::ref 函数就会返回一个包装对象。\",\"如何支持只能移动的对象？\",\"参数通过完美转发，最终调用时使用 std::move，这在线程实际执行的函数 _Invoke 中体现出来：\",\"_STD invoke(_STD move(_STD get<_Indices>(_Tup))...);\",\"如何做到接受任意可调用对象？\",\"源码的实现很简单，主要是通过两层包装，最终将 void* 指针转换到原类型，然后使用 std::invoke 进行调用。\",\"如何创建的线程？\",\"MSVC STL 调用 Win32 API _beginthreadex 创建线程；libstdc++ 调用 __gthread_create 函数创建线程，在 Windows 上实际上就是调用 CreateThread。_beginthreadex 和 CreateThread 都是微软提供的用于创建线程的 C 风格接口，它们的主要区别在于前者依赖于 C 运行时库，而后者更适合纯 Windows API 的情况。使用 _beginthreadex 可以确保正确初始化和清理 C 运行时库资源，而 CreateThread 则适用于不依赖于 C 运行时库的环境。\",\"传递参数一节中的：“std::thread 内部会将保有的参数副本转换为右值表达式进行传递”到底是如何做到的？\",\"这就是第三个问题，差不多，无非是最后调用 std::invoke 函数之前，先 std::move 了。\"]},\"101\":{\"h\":\"std::scoped_lock 的源码实现与解析\",\"t\":[\"本单章专门介绍标准库在 C++17 引入的类模板 std::scoped_lock 的实现，让你对它再无疑问。\",\"这会涉及到不少的模板技术，这没办法，就如同我们先前聊 std::thread 的构造与源码分析最后说的：“不会模板，你阅读标准库源码，是无稽之谈”。建议学习现代C++模板教程。\",\"我们还是一样的，以 MSVC STL 实现的 std::scoped_lock 代码进行讲解，不用担心，我们也查看了 libstdc++ 、libc++的实现，并没有太多区别，更多的是一些风格上的。而且个人觉得 MSVC 的实现是最简单直观的。\"]},\"102\":{\"h\":\"的数据成员\",\"t\":[\"std::scoped_lock 是一个类模板，它有两个特化，也就是有三个版本，其中的数据成员也是不同的。并且它们都不可移动不可复制，“管理类”应该如此。\",\"主模板，是一个可变参数类模板，声明了一个类型形参包 _Mutexes，存储了一个 std::tuple，具体类型根据类型形参包决定。\",\"_EXPORT_STD template <class... _Mutexes> class _NODISCARD_LOCK scoped_lock { // class with destructor that unlocks mutexes public: explicit scoped_lock(_Mutexes&... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock _STD lock(_Mtxes...); } explicit scoped_lock(adopt_lock_t, _Mutexes&... _Mtxes) noexcept // strengthened : _MyMutexes(_Mtxes...) {} // construct but don't lock ~scoped_lock() noexcept { _STD apply([](_Mutexes&... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes); } scoped_lock(const scoped_lock&) = delete; scoped_lock& operator=(const scoped_lock&) = delete; private: tuple<_Mutexes&...> _MyMutexes; };\",\"对模板类型形参包只有一个类型情况的偏特化，是不是很熟悉，和 lock_guard 几乎没有任何区别，保有一个互斥量的引用，构造上锁，析构解锁，提供一个额外的构造函数让构造的时候不上锁。所以用 scoped_lock 替代 lock_guard 不会造成任何额外开销。\",\"template <class _Mutex> class _NODISCARD_LOCK scoped_lock<_Mutex> { public: using mutex_type = _Mutex; explicit scoped_lock(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } explicit scoped_lock(adopt_lock_t, _Mutex& _Mtx) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don't lock ~scoped_lock() noexcept { _MyMutex.unlock(); } scoped_lock(const scoped_lock&) = delete; scoped_lock& operator=(const scoped_lock&) = delete; private: _Mutex& _MyMutex; };\",\"对类型形参包为空的情况的全特化，没有数据成员。\",\"template <> class scoped_lock<> { public: explicit scoped_lock() = default; explicit scoped_lock(adopt_lock_t) noexcept /* strengthened */ {} scoped_lock(const scoped_lock&) = delete; scoped_lock& operator=(const scoped_lock&) = delete; };\",\"std::mutex m1,m2; std::scoped_lock<std::mutex> lc{ m1 }; // 匹配到偏特化版本 保有一个 std::mutex& std::scoped_lock<std::mutex, std::mutex> lc2{ m1,m2 }; // 匹配到主模板 保有一个 std::tuple<std::mutex&,std::mutex&> std::scoped_lock<> lc3; // 匹配到全特化版本 空\"]},\"103\":{\"h\":\"的构造与析构\",\"t\":[\"在上一节讲 scoped_lock 的数据成员的时候已经把这个模板类的全部源码，三个版本的代码都展示了，就不再重复。\",\"这三个版本中，只有两个版本需要介绍，也就是\",\"形参包元素数量为一的偏特化，只管理一个互斥量的。\",\"主模板，可以管理任意个数的互斥量。\",\"那这两个的共同点是什么呢？构造上锁，析构解锁。这很明显，明确这一点我们就开始讲吧。\",\"std::mutex m; void f(){ m.lock(); std::lock_guard<std::mutex> lc{ m, std::adopt_lock }; } void f2(){ m.lock(); std::scoped_lock<std::mutex>sp{ std::adopt_lock,m }; }\",\"这段代码为你展示了 std::lock_guard 和 std::scoped_lock 形参包元素数量为一的偏特化的唯一区别：调用不会上锁的构造函数的参数顺序不同。那么到此也就够了。\",\"接下来我们进入 std::scoped_lock 主模板的讲解：\",\"explicit scoped_lock(_Mutexes&... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock _STD lock(_Mtxes...); }\",\"这个构造函数做了两件事情，初始化数据成员 _MyMutexes让它保有这些互斥量的引用，以及给所有互斥量上锁，使用了 std::lock 帮助我们完成这件事情。\",\"explicit scoped_lock(adopt_lock_t, _Mutexes&... _Mtxes) noexcept // strengthened : _MyMutexes(_Mtxes...) {} // construct but don't lock\",\"这个构造函数不上锁，只是初始化数据成员 _MyMutexes让它保有这些互斥量的引用。\",\"~scoped_lock() noexcept { _STD apply([](_Mutexes&... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes); }\",\"析构函数就要稍微聊一下了，主要是用 std::apply 去遍历 std::tuple ，让元组保有的互斥量引用都进行解锁。简单来说是 std::apply 可以将元组存储的参数全部拿出，用于调用这个可变参数的可调用对象，我们就能利用折叠表达式展开形参包并对其调用 unlock()。\",\"不在乎其返回类型只用来实施它的副作用，显式转换为 (void) 也就是弃值表达式。在我们之前讲的 std::thread 源码中也有这种用法。\",\"不过你可能有疑问：“我们的标准库的那些互斥量unlock() 返回类型都是 void 呀，为什么要这样？”\",\"的确，这是个好问题，libstdc++ 和 libc++ 都没这样做，或许 MSVC STL 想着会有人设计的互斥量让它的 unlock() 返回类型不为 void，毕竟 互斥体(Mutex) 没有要求 unlock() 的返回类型。\",\"template< class F, class Tuple > constexpr decltype(auto) apply( F&& f, Tuple&& t );\",\"这个函数模板接受两个参数，一个可调用(Callable)对象 f，以及一个元组 t，用做调用 f 。我们可以自己简单实现一下它，其实不算难，这种遍历元组的方式在之前讲 std::thread 的源码的时候也提到过。\",\"template<class Callable, class Tuple, std::size_t...index> constexpr decltype(auto) Apply_impl(Callable&& obj,Tuple&& tuple,std::index_sequence<index...>){ return std::invoke(std::forward<Callable>(obj), std::get<index>(std::forward<Tuple>(tuple))...); } template<class Callable, class Tuple> constexpr decltype(auto) apply(Callable&& obj, Tuple&& tuple){ return Apply_impl(std::forward<Callable>(obj), std::forward<Tuple>(tuple), std::make_index_sequence<std::tuple_size_v<std::remove_reference_t<Tuple>>>{}); }\",\"其实就是把元组给解包了，利用了 std::index_sequence + std::make_index_sequence 然后就用 std::get 形参包展开用 std::invoke 调用可调用对象即可，非常经典的处理可变参数做法，这个非常重要，一定要会使用。\",\"举一个简单的调用例子：\",\"std::tuple<int, std::string, char> tuple{ 66,\\\"😅\\\",'c' }; ::apply([](const auto&... t) { ((std::cout << t << ' '), ...); }, tuple);\",\"运行测试。\",\"使用了折叠表达式展开形参包，打印了元组所有的元素。\"]},\"104\":{\"h\":\"总结\",\"t\":[\"如你所见，其实这很简单。至少使用与了解其设计原理是很简单的。唯一的难度或许只有那点源码，处理可变参数，这会涉及不少模板技术，既常见也通用。还是那句话：“不会模板，你阅读标准库源码，是无稽之谈”。\",\"相对于 std::thread 的源码解析，std::scoped_lock 还是简单的多。\"]},\"105\":{\"h\":\"std::async 与 std::future 源码解析\"},\"106\":{\"h\":\"前言\",\"t\":[\"和之前一样的，我们以 MSVC STL 的实现进行讲解。\",\"std::future，即未来体，是用来管理一个共享状态的类模板，用于等待关联任务的完成并获取其返回值。它自身不包含状态，需要通过如 std::async 之类的函数进行初始化。std::async 函数模板返回一个已经初始化且具有共享状态的 std::future 对象。\",\"因此，所有操作的开始应从 std::async 开始讲述。\",\"需要注意的是，它们的实现彼此之间会共用不少设施，在讲述 std::async 源码的时候，对于 std::future 的内容同样重要。\",\"MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 C++14，出于某些原因 C++17 的一些库（如 invoke， _v 变量模板）被向后移植到了 C++14 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。\",\"注意，不用感到奇怪。\"]},\"107\":{\"h\":\"\",\"t\":[\"_EXPORT_STD template <class _Fty, class... _ArgTypes> _NODISCARD_ASYNC future<_Invoke_result_t<decay_t<_Fty>, decay_t<_ArgTypes>...>> async( launch _Policy, _Fty&& _Fnarg, _ArgTypes&&... _Args) { // manages a callable object launched with supplied policy using _Ret = _Invoke_result_t<decay_t<_Fty>, decay_t<_ArgTypes>...>; using _Ptype = typename _P_arg_type<_Ret>::type; _Promise<_Ptype> _Pr( _Get_associated_state<_Ret>(_Policy, _Fake_no_copy_callable_adapter<_Fty, _ArgTypes...>( _STD forward<_Fty>(_Fnarg), _STD forward<_ArgTypes>(_Args)...))); return future<_Ret>(_From_raw_state_tag{}, _Pr._Get_state_for_future()); } _EXPORT_STD template <class _Fty, class... _ArgTypes> _NODISCARD_ASYNC future<_Invoke_result_t<decay_t<_Fty>, decay_t<_ArgTypes>...>> async( _Fty&& _Fnarg, _ArgTypes&&... _Args) { // manages a callable object launched with default policy return _STD async(launch::async | launch::deferred, _STD forward<_Fty>(_Fnarg), _STD forward<_ArgTypes>(_Args)...); }\",\"这段代码最直观的信息是，函数模板 std::async 有两个重载，其中第二个重载只是给了一个执行策略并将参数全部转发，调用第一个重载。也就是不指明执行策略的时候就会匹配到第二个重载版本。因此我们也只需要关注第二个版本了。\",\"模板参数和函数体外部信息：\",\"_EXPOPT_STD 是一个宏，当 _BUILD_STD_MODULE 宏定义且启用了 C++20 时，会被定义为 export，以便导出模块；否则它为空。\",\"_Fty 表示可调用对象的类型。\",\"_ArgTypes 是一个类型形参包，表示调用该可调用对象所需的参数类型。\",\"_NODISCARD_ASYNC 是一个宏，表示属性 [[nodiscard]]，用于标记此函数的返回值不应被忽略。\",\"函数返回类型：\",\"future<_Invoke_result_t<decay_t<_Fty>, decay_t<_ArgTypes>...>>\",\"虽然看起来复杂，但实际上是通过 _Invoke_result_t 获取可调用对象的返回类型。与标准库中的 std::invoke_result_t 基本相同。\",\"可以举一个使用 std::invoke_result_t 的例子：\",\"template<class Fty, class... ArgTypes> std::future<std::invoke_result_t<std::decay_t<Fty>,std::decay_t<ArgTypes>...>> test_fun(Fty&& f,ArgTypes&&... args){ return std::async(std::launch::async, std::forward<Fty>(f), std::forward<ArgTypes>(args)...); } auto result = test_fun([](int) {return 1; }, 1); // std::future<int>\",\"值得注意的是，所有类型在传递前都进行了 decay 处理，也就是说不存在引用类型，是默认按值传递与 std::thread 的行为一致。\",\"函数形参：\",\"async(launch _Policy, _Fty&& _Fnarg, _ArgTypes&&... _Args)\",\"launch _Policy: 表示任务的执行策略，可以是 launch::async（表示异步执行）或 launch::deferred（表示延迟执行），或者两者的组合。\",\"_Fty&& _Fnarg: 可调用对象，通过完美转发机制将其转发给实际的异步任务。\",\"_ArgTypes&&... _Args: 调用该可调用对象时所需的参数，同样通过完美转发机制进行转发。\",\"using _Ret = _Invoke_result_t<decay_t<_Fty>, decay_t<_ArgTypes>...>;\",\"using _Ptype = typename _P_arg_type<_Ret>::type;\",\"定义 _Ret 类型别名，它是使用 _ArgTypes 类型参数调用 _Fty 类型的可调用对象后得到的结果类型。也就是我们传入的可调用对象的返回类型；同样使用了 _Invoke_result_t（等价于 std::invoke_result_t ） 与 decay_t。\",\"其实 _Ptype 的定义确实在大多数情况下和 _Ret 是相同的，类模板 _P_arg_type 只是为了处理引用类型以及 void 的情况，参见 _P_arg_type 的实现：\",\"template <class _Fret> struct _P_arg_type { // type for functions returning T using type = _Fret; }; template <class _Fret> struct _P_arg_type<_Fret&> { // type for functions returning reference to T using type = _Fret*; }; template <> struct _P_arg_type<void> { // type for functions returning void using type = int; };\",\"_Ptype：处理异步任务返回值的方式类型，它在语义上强调了异步任务返回值的处理方式，具有不同的实现逻辑和使用场景。在当前我们难以直接展示它的作用，不过可以推测，这个“P” 表示的是后文将使用的 _Promise 类模板。也就是说，定义 _Ptype 是为了配合 _Promise 的使用。我们将会在后文详细探讨 _Promise 类型的内部实现，并进一步解释 _Ptype 的具体作用。\",\"_Promise<_Ptype> _Pr\",\"_Promise 类型本身不重要，很简单，关键还在于其存储的数据成员。\",\"template <class _Ty> class _Promise { public: _Promise(_Associated_state<_Ty>* _State_ptr) noexcept : _State(_State_ptr, false), _Future_retrieved(false) {} _Promise(_Promise&&) = default; _Promise& operator=(_Promise&&) = default; void _Swap(_Promise& _Other) noexcept { _State._Swap(_Other._State); _STD swap(_Future_retrieved, _Other._Future_retrieved); } const _State_manager<_Ty>& _Get_state() const noexcept { return _State; } _State_manager<_Ty>& _Get_state() noexcept { return _State; } _State_manager<_Ty>& _Get_state_for_set() { if (!_State.valid()) { _Throw_future_error2(future_errc::no_state); } return _State; } _State_manager<_Ty>& _Get_state_for_future() { if (!_State.valid()) { _Throw_future_error2(future_errc::no_state); } if (_Future_retrieved) { _Throw_future_error2(future_errc::future_already_retrieved); } _Future_retrieved = true; return _State; } bool _Is_valid() const noexcept { return _State.valid(); } bool _Is_ready() const noexcept { return _State._Is_ready(); } _Promise(const _Promise&) = delete; _Promise& operator=(const _Promise&) = delete; private: _State_manager<_Ty> _State; bool _Future_retrieved; };\",\"_Promise 类模板是对 _State_manager 类模板的包装，并增加了一个表示状态的成员 _Future_retrieved。\",\"状态成员用于跟踪 _Promise 是否已经调用过 _Get_state_for_future() 成员函数；它默认为 false，在第一次调用 _Get_state_for_future() 成员函数时被置为 true，如果二次调用，就会抛出 future_errc::future_already_retrieved 异常。\",\"这类似于 std::promise 调用 get_future() 成员函数。测试。\",\"_Promise 的构造函数接受的却不是 _State_manager 类型的对象，而是 _Associated_state 类型的指针，用来初始化数据成员 _State。\",\"_State(_State_ptr, false)\",\"这是因为实际上 _State_manager 类型的实现就是保有了 Associated_state 指针，以及一个状态成员：\",\"private: _Associated_state<_Ty>* _Assoc_state = nullptr; bool _Get_only_once = false;\",\"也可以简单理解 _State_manager 又是对 Associated_state 的包装，其中的大部分接口实际上是调用 _Assoc_state 的成员函数，如：\",\"void wait() const { // wait for signal if (!valid()) { _Throw_future_error2(future_errc::no_state); } _Assoc_state->_Wait(); }\",\"一切的重点，最终在 Associated_state 上。\",\"然而它也是最为复杂的，我们在讲 std::thread-构造源码解析 中提到过一句话：\",\"了解一个庞大的类，最简单的方式就是先看它的数据成员有什么。\",\"public: conditional_t<is_default_constructible_v<_Ty>, _Ty, _Result_holder<_Ty>> _Result; exception_ptr _Exception; mutex _Mtx; condition_variable _Cond; bool _Retrieved; int _Ready; bool _Ready_at_thread_exit; // TRANSITION, ABI bool _Has_stored_result; bool _Running;\",\"这是 Associated_state 的数据成员，其中有许多的 bool 类型的状态成员，同时最为明显重要的三个设施是：异常指针、互斥量、条件变量。\",\"根据这些数据成员我们就能很轻松的猜测出 Associated_state 模板类的作用和工作方式。\",\"异常指针：用于存储异步任务中可能发生的异常，以便在调用 future::get 时能够重新抛出异常。\",\"互斥量和条件变量：用于在异步任务和等待任务之间进行同步。当异步任务完成时，条件变量会通知等待的任务。\",\"_Associated_state 模板类负责管理异步任务的状态，包括结果的存储、异常的处理以及任务完成的通知。它是实现 std::future 和 std::promise 的核心组件之一，通过 _State_manager 和 _Promise 类模板对其进行封装和管理，提供更高级别的接口和功能。\",\"+---------------------+ | _Promise<_Ty> | |---------------------| | - _State | -----> +---------------------+ | - _Future_retrieved | | _State_manager<_Ty> | +---------------------+ |----------------------| | - _Assoc_state | -----> +-------------------------+ | - _Get_only_once | | _Associated_state<_Ty>* | +----------------------+ +-------------------------+\",\"上图是 _Promise、_State_manager、_Associated_state 之间的包含关系示意图，理解这个关系对我们后面非常重要。\",\"到此就可以了，我们不需要在此处就详细介绍这三个类，但是你需要大概的看一下，这非常重要。\",\"初始化 _Promie 对象：\",\"_Get_associated_state<_Ret>(_Policy, _Fake_no_copy_callable_adapter<_Fty, _ArgTypes...>(_STD forward<_Fty>(_Fnarg), _STD forward<_ArgTypes>(_Args)...))\",\"很明显，这是一个函数调用，将我们 std::async 的参数全部转发给它，它是重要而直观的。\",\"_Get_associated_state 函数根据启动模式（launch）来决定创建的异步任务状态对象类型：\",\"template <class _Ret, class _Fty> _Associated_state<typename _P_arg_type<_Ret>::type>* _Get_associated_state(launch _Psync, _Fty&& _Fnarg) { // construct associated asynchronous state object for the launch type switch (_Psync) { // select launch type case launch::deferred: return new _Deferred_async_state<_Ret>(_STD forward<_Fty>(_Fnarg)); case launch::async: // TRANSITION, fixed in vMajorNext, should create a new thread here default: return new _Task_async_state<_Ret>(_STD forward<_Fty>(_Fnarg)); } }\",\"_Get_associated_state 函数返回一个 _Associated_state 指针，该指针指向一个新的 _Deferred_async_state 或 _Task_async_state 对象。这两个类分别对应于异步任务的两种不同执行策略：延迟执行和异步执行。\",\"其实就是父类指针指向了子类对象，注意 _Associated_state 是有虚函数的，子类进行覆盖，这很重要。比如在后续聊 std::future 的 get() 成员函数的时候就会讲到\",\"这段代码也很好的说明在 MSVC STL 中，launch::async | launch::deferred 和 launch::async 的行为是相同的，即都是异步执行。\",\"_Task_async_state 与 _Deferred_async_state 类型\",\"template <class _Rx> class _Task_async_state : public _Packaged_state<_Rx()> template <class _Rx> class _Deferred_async_state : public _Packaged_state<_Rx()>\",\"_Task_async_state 与 _Deferred_async_state 都继承自 _Packaged_state，用于异步执行任务。它们的构造函数都接受一个函数对象，并将其转发给基类 _Packaged_state 的构造函数。\",\"_Packaged_state 类型只有一个数据成员 std::function 类型的对象 _Fn，它用来存储需要执行的异步任务，而它又继承自 _Associated_state。\",\"template <class _Ret, class... _ArgTypes> class _Packaged_state<_Ret(_ArgTypes...)> : public _Associated_state<_Ret>\",\"我们直接先看 _Task_async_state 与 _Deferred_async_state 类型的构造函数实现即可：\",\"template <class _Fty2> _Task_async_state(_Fty2&& _Fnarg) : _Mybase(_STD forward<_Fty2>(_Fnarg)) { _Task = ::Concurrency::create_task([this]() { // do it now this->_Call_immediate(); }); this->_Running = true; } template <class _Fty2> _Deferred_async_state(const _Fty2& _Fnarg) : _Packaged_state<_Rx()>(_Fnarg) {} template <class _Fty2> _Deferred_async_state(_Fty2&& _Fnarg) : _Packaged_state<_Rx()>(_STD forward<_Fty2>(_Fnarg)) {}\",\"_Task_async_state 它的数据成员：\",\"private: ::Concurrency::task<void> _Task;\",\"_Task_async_state 的实现使用到了微软自己实现的 并行模式库（PPL），简而言之 launch::async 策略并不是单纯的创建线程让任务执行，而是使用了微软的 ::Concurrency::create_task ，它从线程池中获取线程并执行任务返回包装对象。\",\"this->_Call_immediate(); 是调用 _Task_async_state 的父类 _Packaged_state 的成员函数 _Call_immediate 。\",\"_Packaged_state 有三个偏特化，_Call_immediate 自然也拥有三个不同版本，用来应对我们传入的函数对象返回类型的三种情况：\",\"返回普通类型 _Packaged_state<_Ret(_ArgTypes...)>\",\"void _Call_immediate(_ArgTypes... _Args) { _TRY_BEGIN // 调用函数对象并捕获异常 传递返回值 this->_Set_value(_Fn(_STD forward<_ArgTypes>(_Args)...), false); _CATCH_ALL // 函数对象抛出异常就记录 this->_Set_exception(_STD current_exception(), false); _CATCH_END }\",\"返回引用类型 _Packaged_state<_Ret&(_ArgTypes...)>\",\"void _Call_immediate(_ArgTypes... _Args) { _TRY_BEGIN // 调用函数对象并捕获异常 传递返回值的地址 this->_Set_value(_STD addressof(_Fn(_STD forward<_ArgTypes>(_Args)...)), false); _CATCH_ALL // 函数对象抛出异常就记录 this->_Set_exception(_STD current_exception(), false); _CATCH_END }\",\"返回 void 类型 _Packaged_state<void(_ArgTypes...)>\",\"void _Call_immediate(_ArgTypes... _Args) { // call function object _TRY_BEGIN // 调用函数对象并捕获异常 因为返回 void 不获取返回值 而是直接 _Set_value 传递一个 1 _Fn(_STD forward<_ArgTypes>(_Args)...); this->_Set_value(1, false); _CATCH_ALL // 函数对象抛出异常就记录 this->_Set_exception(_STD current_exception(), false); _CATCH_END }\",\"说白了，无非是把返回引用类型的可调用对象返回的引用获取地址传递给 _Set_value，把返回 void 类型的可调用对象传递一个 1 表示正确执行的状态给 _Set_value。\",\"_Call_immediate 则又调用了父类 _Associated_state 的成员函数（_Set_value、_set_exception），传递的可调用对象执行结果，以及可能的异常，将结果或异常存储在 _Associated_state 中。\",\"_Deferred_async_state 并不会在线程中执行任务，但它同样调用 _Call_immediate 函数执行保有的函数对象，它有一个 _Run_deferred_function 函数：\",\"void _Run_deferred_function(unique_lock<mutex>& _Lock) override { // run the deferred function _Lock.unlock(); _Packaged_state<_Rx()>::_Call_immediate(); _Lock.lock(); }\",\"然后也就和上面说的没什么区别了 。\",\"返回 std::future\",\"return future<_Ret>(_From_raw_state_tag{}, _Pr._Get_state_for_future());\",\"它选择到了 std::future 的构造函数是：\",\"future(_From_raw_state_tag, const _Mybase& _State) noexcept : _Mybase(_State, true) {}\",\"using _Mybase = _State_manager<_Ty*>;\",\"_From_raw_state_tag 是一个空类，并没有什么特殊作用，只是为了区分重载。\",\"_Get_state_for_future 代码如下：\",\"_State_manager<_Ty>& _Get_state_for_future() { if (!_State.valid()) { _Throw_future_error2(future_errc::no_state); } if (_Future_retrieved) { _Throw_future_error2(future_errc::future_already_retrieved); } _Future_retrieved = true; return _State; }\",\"检查状态，修改状态，返回底层 _State ，完成转移状态。\",\"总而言之这行代码通过调用 std::future 的特定构造函数，将 _Promise 对象中的 _State_manager 状态转移到 std::future 对象中，从而创建并返回一个 std::future 对象。这使得 std::future 可以访问并管理异步任务的状态，包括获取任务的结果或异常，并等待任务的完成。\"]},\"108\":{\"h\":\"\",\"t\":[\"先前的 std::async 的内容非常之多，希望各位开发者不要搞晕了，其实重中之重主要是那几个类，关系图如下：\",\"+---------------------+ | _Promise<_Ty> | |---------------------| | - _State | -----> +---------------------+ | - _Future_retrieved | | _State_manager<_Ty> | +---------------------+ |----------------------| | - _Assoc_state | -----> +-------------------------+ | - _Get_only_once | | _Associated_state<_Ty>* | +----------------------+ +-------------------------+\",\"_Promise、_State_manager、_Associated_state 之间的包含关系示意图。\",\"_Asscociated_state、_Packaged_state、_Task_async_state、_Deferred_async_state继承关系示意图。\",\"这其中的 _Associated_state、_State_manager 类型是我们的核心，它在后续 std::future 乃至其它并发设施都有众多使用。\",\"介绍 std::future 的源码我认为无需过多篇幅或者示例，引入过多的源码实现等等从头讲解，只会让各位开发者感觉复杂难。\",\"我们直接从它的最重要、常见的 get()、wait() 成员函数开始即可。\",\"std::future<int> future = std::async([] { return 0; }); future.get();\",\"我们先前已经详细介绍过了 std::async 返回 std::future 的步骤。以上这段代码，唯一的问题是：future.get() 做了什么？\",\"_EXPORT_STD template <class _Ty> class future : public _State_manager<_Ty> { // class that defines a non-copyable asynchronous return object that holds a value private: using _Mybase = _State_manager<_Ty>; public: static_assert(!is_array_v<_Ty> && is_object_v<_Ty> && is_destructible_v<_Ty>, \\\"T in future<T> must meet the Cpp17Destructible requirements (N4950 [futures.unique.future]/4).\\\"); future() = default; future(future&& _Other) noexcept : _Mybase(_STD move(_Other), true) {} future& operator=(future&&) = default; future(_From_raw_state_tag, const _Mybase& _State) noexcept : _Mybase(_State, true) {} _Ty get() { // block until ready then return the stored result or throw the stored exception future _Local{_STD move(*this)}; return _STD move(_Local._Get_value()); } _NODISCARD shared_future<_Ty> share() noexcept { return shared_future<_Ty>(_STD move(*this)); } future(const future&) = delete; future& operator=(const future&) = delete; };\",\"std::future 其实还有两种特化，不过整体大差不差。\",\"template <class _Ty> class future<_Ty&> : public _State_manager<_Ty*>\",\"template <> class future<void> : public _State_manager<int>\",\"也就是对返回类型为引用和 void 的情况了。其实先前已经聊过很多次了，无非就是内部的返回引用实际按指针操作，返回 void，那么也得给个 1。参见前面的 _Call_immediate 实现。\",\"可以看到 std::future 整体代码实现很少，很简单，那是因为其实现细节都在其父类 _State_manager 。然而 _State_manager 又保有一个 _Associated_state<_Ty>* 类型的成员。而 _Associated_state 又是一切的核心，之前已经详细描述过了。\",\"阅读 std::future 的源码你可能注意到了一个问题：*没有 wait()成员函数？\",\"它的定义来自于父类 _State_manager ：\",\"void wait() const { // wait for signal if (!valid()) { _Throw_future_error2(future_errc::no_state); } _Assoc_state->_Wait(); }\",\"然而这还不够，实际上还需要调用了 _Associated_state 的 wait() 成员函数：\",\"virtual void _Wait() { // wait for signal unique_lock<mutex> _Lock(_Mtx); _Maybe_run_deferred_function(_Lock); while (!_Ready) { _Cond.wait(_Lock); } }\",\"先使用锁进行保护，然后调用函数，再循环等待任务执行完毕。_Maybe_run_deferred_function：\",\"void _Maybe_run_deferred_function(unique_lock<mutex>& _Lock) { // run a deferred function if not already done if (!_Running) { // run the function _Running = true; _Run_deferred_function(_Lock); } }\",\"_Run_deferred_function 相信你不会陌生，在讲述 std::async 源码中其实已经提到了，就是解锁然后调用 _Call_immediate 罢了。\",\"void _Run_deferred_function(unique_lock<mutex>& _Lock) override { // run the deferred function _Lock.unlock(); _Packaged_state<_Rx()>::_Call_immediate(); _Lock.lock(); }\",\"_Call_immediate 就是执行我们实际传入的函数对象，先前已经提过。\",\"在 _Wait 函数中调用 _Maybe_run_deferred_function 是为了确保延迟执行（launch::deferred）的任务能够在等待前被启动并执行完毕。这样，在调用 wait 时可以正确地等待任务完成。\",\"至于下面的循环等待部分：\",\"while (!_Ready) { _Cond.wait(_Lock); }\",\"这段代码使用了条件变量、互斥量、以及一个状态对象，主要目的有两个：\",\"避免虚假唤醒： \",\"条件变量的 wait 函数在被唤醒后，会重新检查条件（即 _Ready 是否为 true），确保只有在条件满足时才会继续执行。这防止了由于虚假唤醒导致的错误行为。\",\"等待 launch::async 的任务在其它线程执行完毕： \",\"对于 launch::async 模式的任务，这段代码确保当前线程会等待任务在另一个线程中执行完毕，并接收到任务完成的信号。只有当任务完成并设置 _Ready 为 true 后，条件变量才会被通知，从而结束等待。\",\"这样，当调用 wait 函数时，可以保证无论任务是 launch::deferred 还是 launch::async 模式，当前线程都会正确地等待任务的完成信号，然后继续执行。\",\"wait() 介绍完了，那么接下来就是 get() ：\",\"// std::future<void> void get() { // block until ready then return or throw the stored exception future _Local{_STD move(*this)}; _Local._Get_value(); } // std::future<T> _Ty get() { // block until ready then return the stored result or throw the stored exception future _Local{_STD move(*this)}; return _STD move(_Local._Get_value()); } // std::future<T&> _Ty& get() { // block until ready then return the stored result or throw the stored exception future _Local{_STD move(*this)}; return *_Local._Get_value(); }\",\"在第四章的 “future 的状态变化”一节中我们也详细聊过 get() 成员函数。由于 future 本身有三个特化，get() 成员函数自然那也有三个版本，不过总体并无多大区别。\",\"它们都是将当前对象（*this）的共享状态转移给了这个局部对象 _Local，然后再去调用父类_State_manager 的成员函数 _Get_value() 获取值并返回。而局部对象 _Local 在函数结束时析构。这意味着当前对象（*this）失去共享状态，并且状态被完全销毁。\",\"_Get_value() ：\",\"_Ty& _Get_value() const { if (!valid()) { _Throw_future_error2(future_errc::no_state); } return _Assoc_state->_Get_value(_Get_only_once); }\",\"先进行一下状态判断，如果拥有共享状态则继续，调用 _Assoc_state 的成员函数 _Get_value ，传递 _Get_only_once 参数，其实就是代表这个成员函数只能调用一次，次参数是里面进行状态判断的而已。\",\"_Assoc_state 的类型是 _Associated_state<_Ty>* ，是一个指针类型，它实际会指向自己的子类对象，我们在讲 std::async 源码的时候提到了，它必然指向 _Deferred_async_state 或者 _Task_async_state。\",\"_Assoc_state->_Get_value 这其实是个多态调用，父类有这个虚函数：\",\"virtual _Ty& _Get_value(bool _Get_only_once) { unique_lock<mutex> _Lock(_Mtx); if (_Get_only_once && _Retrieved) { _Throw_future_error2(future_errc::future_already_retrieved); } if (_Exception) { _STD rethrow_exception(_Exception); } // TRANSITION: `_Retrieved` should be assigned before `_Exception` is thrown so that a `future::get` // that throws a stored exception invalidates the future (N4950 [futures.unique.future]/17) _Retrieved = true; _Maybe_run_deferred_function(_Lock); while (!_Ready) { _Cond.wait(_Lock); } if (_Exception) { _STD rethrow_exception(_Exception); } if constexpr (is_default_constructible_v<_Ty>) { return _Result; } else { return _Result._Held_value; } }\",\"但是子类 _Task_async_state 进行了重写，以 launch::async 策略创建的 future，那么实际会调用 _Task_async_state::_Get_value ：\",\"_State_type& _Get_value(bool _Get_only_once) override { // return the stored result or throw stored exception _Task.wait(); return _Mybase::_Get_value(_Get_only_once); }\",\"_Deferred_async_state 则没有进行重写，就是直接调用父类虚函数。\",\"_Task 就是 ::Concurrency::task<void> _Task;，调用 wait() 成员函数确保任务执行完毕。\",\"_Mybase::_Get_value(_Get_only_once) 其实又是回去调用父类的虚函数了。\"]},\"109\":{\"h\":\"方法详细解释\",\"t\":[\"状态检查： \",\"如果_Get_only_once为真并且结果已被检索过，则抛出future_already_retrieved异常。\",\"异常处理： \",\"如果存在存储的异常，重新抛出该异常。\",\"标记结果已被检索： \",\"将_Retrieved设置为true。\",\"执行延迟函数： \",\"调用_Maybe_run_deferred_function来运行可能的延迟任务。这个函数很简单，就是单纯的执行延时任务而已，在讲述 wait 成员函数的时候已经讲完了。\",\"等待结果就绪： \",\"如果结果尚未准备好，等待条件变量通知结果已就绪。（这里和 std::async 和 std::future 的组合无关，因为如果是 launch::async 模式创建的任务，重写的 _Get_value 是先调用了 _Task.wait(); 确保异步任务执行完毕，此处根本无需等待它）\",\"再次检查异常： \",\"再次检查是否有存储的异常，并重新抛出它。\",\"返回结果： \",\"如果_Ty是默认可构造的，返回结果_Result。\",\"否则，返回_Result._Held_value。\",\"_Result 是通过执行 _Call_immediate 函数，然后 _Call_immediate 再执行 _Set_value ，_Set_value 再执行 _Emplace_result，_Emplace_result 再执行 _Emplace_result 获取到我们执行任务的值的。以 Ty 的偏特化为例：\",\"// _Packaged_state void _Call_immediate(_ArgTypes... _Args) { _TRY_BEGIN // 调用函数对象并捕获异常 传递返回值 this->_Set_value(_Fn(_STD forward<_ArgTypes>(_Args)...), false); _CATCH_ALL // 函数对象抛出异常就记录 this->_Set_exception(_STD current_exception(), false); _CATCH_END } // _Asscoiated_state void _Set_value(const _Ty& _Val, bool _At_thread_exit) { // store a result unique_lock<mutex> _Lock(_Mtx); _Set_value_raw(_Val, &_Lock, _At_thread_exit); } void _Set_value_raw(const _Ty& _Val, unique_lock<mutex>* _Lock, bool _At_thread_exit) { // store a result while inside a locked block if (_Already_has_stored_result()) { _Throw_future_error2(future_errc::promise_already_satisfied); } _Emplace_result(_Val); _Do_notify(_Lock, _At_thread_exit); } template <class _Ty2> void _Emplace_result(_Ty2&& _Val) { // TRANSITION, incorrectly assigns _Result when _Ty is default constructible if constexpr (is_default_constructible_v<_Ty>) { _Result = _STD forward<_Ty2>(_Val); // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! } else { ::new (static_cast<void*>(_STD addressof(_Result._Held_value))) _Ty(_STD forward<_Ty2>(_Val)); _Has_stored_result = true; } }\"]},\"110\":{\"h\":\"总结\",\"t\":[\"好了，到此也就可以了。\",\"你不会期待我们将每一个成员函数都分析一遍吧？首先是没有必要，其次是篇幅限制。\",\"std::future 的继承关系让人感到头疼，但是如果耐心的看了一遍，全部搞明白了继承关系， std::async 如何创建的 std::future 也就没有问题了。\",\"其实各位不用着急完全理解，可以慢慢看，至少有许多的显著的信息，比如：\",\"sttd::future 的很多部分，如 get() 成员函数实现中，实际使用了虚函数。\",\"std::async 创建 std::future 对象中，内部其实也有父类指针指向子类对象，以及多态调用。\",\"std::async 的非延迟执行策略，使用到了自家的 PPL 库。\",\"微软的 std::async 策略实现并不符合标准，不区分 launch::async | launch::deferred 和 launch::async。\",\"std::future 内部使用到了互斥量、条件变量、异常指针等设施。\"]},\"111\":{\"h\":\"线程池\"},\"112\":{\"h\":\"前言\",\"t\":[\"我相信，已经阅读到这里的各位，不会对“线程池”这个词感到陌生。大部分开发者早就自己使用、学习，乃至实现过线程池。那不如我们先来进行一下基础的名词解释。\",\"什么叫线程池？\",\"“线程”没什么好说的，是 CPU 调度的最小单位，也是操作系统的一种抽象资源。\",\"“池”？水池装着水，线程池则是装着线程，是一种抽象的指代。\",\"抽象的来说，可以当做是一个池子中存放了一堆线程，故称作线程池。简而言之，线程池是指代一组预先创建的、可以复用的线程集合。这些线程由线程池管理，用于执行多个任务而无需频繁地创建和销毁线程。\",\"这是一个典型的线程池结构。线程池包含一个任务队列，当有新任务加入时，调度器会将任务分配给线程池中的空闲线程进行执行。线程在执行完任务后会进入休眠状态，等待调度器的下一次唤醒。当有新的任务加入队列，并且有线程处于休眠状态时，调度器会唤醒休眠的线程，并分配新的任务给它们执行。线程执行完新任务后，会再次进入休眠状态，直到有新的任务到来，调度器才可能会再次唤醒它们。\",\"图中线程1 就是被调度器分配了任务1，执行完毕后休眠，然而新任务的到来让调度器再次将它唤醒，去执行任务6，执行完毕后继续休眠。\",\"使用线程池的益处我们已经加粗了，然而这其实并不是“线程池”独有的，任何创建和销毁存在较大开销的设施，都可以进行所谓的“池化”。\",\"常见的还有：套接字连接池、数据库连接池、内存池、对象池。\",\"了解以上这些基础概念是第一步也是最后一步，随着水平的提升，对这些概念的理解也会逐渐提升。\"]},\"113\":{\"h\":\"市面上常见的线程池\",\"t\":[\"在了解了线程池的基本概念与运行逻辑后，我们不用着急就尝试实现。我们可以先来聊一聊，使用一下市面上常见的那些 C++ 线程池设施，了解它们提供的功能，接口设计的方式。\"]},\"114\":{\"h\":\"\",\"t\":[\"boost::asio::thread_pool 是 Boost.Asio 库提供的一种线程池实现。\",\"Asio 是一个跨平台的 C++ 库，用于网络和低级 I/O 编程，使用 现代C++ 方法为开发人员提供一致的异步模型。\",\"使用方法：\",\"创建线程池对象，指定或让 Asio 自动决定线程数量。\",\"提交任务：通过 boost::asio::post 函数模板提交任务到线程池中。\",\"阻塞，直到池中的线程完成任务。\",\"#include <boost/asio.hpp> #include <iostream> std::mutex m; void print_task(int n) { std::lock_guard<std::mutex> lc{ m }; std::cout << \\\"Task \\\" << n << \\\" is running on thr: \\\" << std::this_thread::get_id() << '\\\\n'; } int main() { boost::asio::thread_pool pool{ 4 }; // 创建一个包含 4 个线程的线程池 for (int i = 0; i < 10; ++i) { boost::asio::post(pool, [i] { print_task(i); }); } pool.join(); // 等待所有任务执行完成 }\",\"运行测试。\",\"创建线程池时，指定线程数量，线程池会创建对应数量的线程。\",\"使用 boost::asio::post 提交任务，任务会被添加到任务队列中。\",\"线程池中的线程会从任务队列中取出任务并执行，任务执行完毕后，线程继续取下一个任务或者休眠。\",\"调用 join 方法等待所有任务执行完毕并关闭线程池。\",\"如果我们不自己指明线程池的线程数量，那么 Asio 会根据函数 default_thread_pool_size 计算并返回一个线程池的默认线程数量。它根据系统的硬件并发能力来决定使用的线程数，通常是硬件并发能力的两倍。\",\"inline long default_thread_pool_size() { std::size_t num_threads = thread::hardware_concurrency() * 2; num_threads = num_threads == 0 ? 2 : num_threads; return static_cast<long>(num_threads); } thread_pool::thread_pool() : scheduler_(add_scheduler(new detail::scheduler(*this, 0, false))), num_threads_(detail::default_thread_pool_size())\",\"代码很简单，就是 thread::hardware_concurrency() * 2 而已，至于下面的判断是因为 std::thread::hardware_concurrency() 在某些特殊情况下可能返回 0（例如硬件并发能力无法被检测时），那那将 num_threads 设置为 2，确保线程池至少有 2 个线程。\",\"Boost.Asio 的线程池对象在析构时会自动调用相关的清理方法，但你也可以手动进行控制。\",\"thread_pool::~thread_pool() { stop(); // 停止接收新任务 join(); // 等待所有线程完成 shutdown(); // 最终清理，释放资源 }\",\"stop ：修改内部的标志位存在使得线程池能够识别何时需要停止接收新的任务，以及关闭还没开始执行的任务，然后唤醒所有线程。\",\"join() ：等待所有线程完成它们的工作，确保所有线程都已终止。\",\"shutdown() ：进行最终的清理，释放资源，确保线程池的完全清理和资源的正确释放\",\"此处可阅读部分源码，帮助理解与记忆\",\"析构函数先调用了 stop() ，然后再进行 join() 。那如果我们没有提前显式调用 join() 成员函数，可能导致一些任务没有执行，析构函数并不会等待所有任务执行完毕：\",\"boost::asio::thread_pool pool{ 4 }; for (int i = 0; i < 10; ++i) { boost::asio::post(pool, [i] { print_task(i); }); }\",\"运行测试。\",\"因为析构函数并不是阻塞直到执行完所有任务，而是先停止，再 join() 以及 shutdown()。\",\"Boost.Asio 提供的线程池使用十分简单，接口高度封装，几乎无需关心底层具体实现，易于使用。\",\"我们的操作几乎只需创建线程池对象、将任务加入线程池、在需要时调用 join()。\",\"boost::asio::thread_pool pool{4}; // 创建线程池 boost::asio::post(pool, task); // 将任务加入线程池 pool.join(); // 等待任务完成 （或者析构自动调用）\"]},\"115\":{\"h\":\"\",\"t\":[\"QThreadPool 是 Qt 提供的线程池实现，它是用来管理自家的 QThreads 的集合。\",\"#include <QCoreApplication> #include <QThreadPool> #include <QRunnable> #include <QDebug> struct MyTask : public QRunnable{ void run() override { qDebug() << \\\"🐢🐢🐢🐢🐢\\\"; } }; int main(int argc, char *argv[]){ QCoreApplication app(argc, argv); QThreadPool *threadPool = QThreadPool::globalInstance(); // 线程池最大线程数 qDebug()<< threadPool->maxThreadCount(); for (int i = 0; i < 10; ++i) { MyTask *task = new MyTask{}; threadPool->start(task); } // 当前活跃线程数 10 qDebug()<<threadPool->activeThreadCount(); app.exec(); }\",\"与 Asio.thread_pool 不同，QThreadPool 采用单例模式，通过静态成员函数 QThreadPool::globalInstance() 获取对象实例（不过也可以自己创建）。默认情况下，QThreadPool 线程池的最大线程数为当前硬件支持的并发线程数，例如在我的硬件上为 20，这点也和 Asio.thread_pool 不同。\",\"QThreadPool 依赖于 Qt 的事件循环，因此我们使用了 QCoreApplication。\",\"而将任务添加到线程池中的做法非常古老原始，我们需要自定义一个类型继承并重写虚函数 run，创建任务对象，然后将任务对象传递给线程池的 start 方法。\",\"这种方法过于原始，如果读者学过 java 相信也不会陌生。我们实现的线程池不会是如此。\",\"在 Qt6，引入了一个 start 的重载版本：\",\"template <typename Callable, QRunnable::if_callable<Callable>> void QThreadPool::start(Callable &&functionToRun, int priority) { start(QRunnable::create(std::forward<Callable>(functionToRun)), priority); }\",\"它相当于是对start 原始版本的：\",\"void start(QRunnable *runnable, int priority = 0);\",\"源码。\",\"进行的一个包装，以支持任何的可调用(Callable)类型，而无需再繁琐的继承重写 run 函数。\",\"threadPool->start([=]{ qDebug()<<QString(\\\"thread id %1\\\").arg(i); });\",\"QThradPool 还支持手动控制任务优先级。通过调用 start 成员函数，将任务传递给线程池后可以再指明执行策略。\",\"enum QThread::Priority 枚举类型表示操作系统应如何调度新创建的线程。\",\"常量\",\"值\",\"描述\",\"QThread::IdlePriority\",\"0\",\"仅在没有其他线程运行时调度。\",\"QThread::LowestPriority\",\"1\",\"调度频率低于 LowPriority。\",\"QThread::LowPriority\",\"2\",\"调度频率低于 NormalPriority。\",\"QThread::NormalPriority\",\"3\",\"操作系统的默认优先级。\",\"QThread::HighPriority\",\"4\",\"调度频率高于 NormalPriority。\",\"QThread::HighestPriority\",\"5\",\"调度频率高于 HighPriority。\",\"QThread::TimeCriticalPriority\",\"6\",\"尽可能频繁地调度。\",\"QThread::InheritPriority\",\"7\",\"使用与创建线程相同的优先级。 这是默认值。\",\"到此也就足够了，虽然还有不少接口没有介绍，不过也都没什么特别的了。\"]},\"116\":{\"h\":\"实现线程池\",\"t\":[\"实现一个普通的能够满足日常开发需求的线程池实际上非常简单，只需要不到一百行代码。\",\"“普通的能够满足日常开发需求的”\",\"其实绝大部分开发者使用线程池，只是为了不重复多次创建线程罢了。所以只需要一个提供一个外部接口，可以传入任务到任务队列，然后安排线程去执行。无非是使用条件变量、互斥量、原子标志位，这些东西，就足够编写一个满足绝大部分业务需求的线程池。\",\"我们先编写一个最基础的线程池，首先确定它的数据成员：\",\"class ThreadPool { std::mutex mutex_; std::condition_variable cv_; std::atomic<bool> stop_; std::atomic<std::size_t> num_threads_; std::queue<Task> tasks_; std::vector<std::thread> pool_; };\",\"std::mutex mutex_\",\"用于保护共享资源（如任务队列）在多线程环境中的访问，避免数据竞争。\",\"std::condition_variable cv_\",\"用于线程间的同步，允许线程等待特定条件（如新任务加入队列）并在条件满足时唤醒线程。\",\"std::atomic<bool> stop_\",\"指示线程池是否停止。\",\"std::atomic<std::size_t> num_threads_\",\"表示线程池中的线程数量。\",\"std::queue<Task> tasks_\",\"任务队列，存储等待执行的任务，任务按提交顺序执行。\",\"std::vector<std::thread> pool_\",\"线程容器，存储管理线程对象，每个线程从任务队列中获取任务并执行。\",\"标头依赖：\",\"#include <iostream> #include <thread> #include <mutex> #include <condition_variable> #include <future> #include <atomic> #include <queue> #include <vector> #include <syncstream> #include <functional>\",\"提供构造析构函数，以及一些外部接口：submit()、start()、stop()、join()，也就完成了：\",\"inline std::size_t default_thread_pool_size()noexcept { std::size_t num_threads = std::thread::hardware_concurrency() * 2; num_threads = num_threads == 0 ? 2 : num_threads; return num_threads; } class ThreadPool { public: using Task = std::packaged_task<void()>; ThreadPool(const ThreadPool&) = delete; ThreadPool& operator=(const ThreadPool&) = delete; ThreadPool(std::size_t num_thread = default_thread_pool_size()) : stop_{ false }, num_threads_{ num_thread } { start(); } ~ThreadPool() { stop(); } void stop() { stop_.store(true); cv_.notify_all(); for (auto& thread : pool_) { if (thread.joinable()) { thread.join(); } } pool_.clear(); } template<typename F, typename... Args> std::future<std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>> submit(F&& f, Args&&...args) { using RetType = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>; if (stop_.load()) { throw std::runtime_error(\\\"ThreadPool is stopped\\\"); } auto task = std::make_shared<std::packaged_task<RetType()>>( std::bind(std::forward<F>(f), std::forward<Args>(args)...)); std::future<RetType> ret = task->get_future(); { std::lock_guard<std::mutex> lc{ mutex_ }; tasks_.emplace([task] {(*task)(); }); } cv_.notify_one(); return ret; } void start() { for (std::size_t i = 0; i < num_threads_; ++i) { pool_.emplace_back([this] { while (!stop_) { Task task; { std::unique_lock<std::mutex> lc{ mutex_ }; cv_.wait(lc, [this] {return stop_ || !tasks_.empty(); }); if (tasks_.empty()) return; task = std::move(tasks_.front()); tasks_.pop(); } task(); } }); } } private: std::mutex mutex_; std::condition_variable cv_; std::atomic<bool> stop_; std::atomic<std::size_t> num_threads_; std::queue<Task> tasks_; std::vector<std::thread> pool_; };\",\"测试 demo：\",\"int main() { ThreadPool pool{ 4 }; // 创建一个有 4 个线程的线程池 std::vector<std::future<int>> futures; // future 集合，获取返回值 for (int i = 0; i < 10; ++i) { futures.emplace_back(pool.submit(print_task, i)); } for (int i = 0; i < 10; ++i) { futures.emplace_back(pool.submit(print_task2, i)); } int sum = 0; for (auto& future : futures) { sum += future.get(); // get() 成员函数 阻塞到任务执行完毕，获取返回值 } std::cout << \\\"sum: \\\" << sum << '\\\\n'; } // 析构自动 stop()\",\"可能的运行结果：\",\"Task 0 is running on thr: 6900 Task 1 is running on thr: 36304 Task 5 is running on thr: 36304 Task 3 is running on thr: 6900 Task 7 is running on thr: 6900 Task 2 is running on thr: 29376 Task 6 is running on thr: 36304 Task 4 is running on thr: 31416 🐢🐢🐢 1 🐉🐉🐉 Task 9 is running on thr: 29376 🐢🐢🐢 0 🐉🐉🐉 Task 8 is running on thr: 6900 🐢🐢🐢 2 🐉🐉🐉 🐢🐢🐢 6 🐉🐉🐉 🐢🐢🐢 4 🐉🐉🐉 🐢🐢🐢 5 🐉🐉🐉 🐢🐢🐢 3 🐉🐉🐉 🐢🐢🐢 7 🐉🐉🐉 🐢🐢🐢 8 🐉🐉🐉 🐢🐢🐢 9 🐉🐉🐉 sum: 90\",\"如果等待线程池对象调用析构函数，那么效果如同 asio::thread_pool，会先进行 stop，这可能导致一些任务无法执行。不过我们在最后循环遍历了 futures，调用 get() 成员函数，不存在这个问题。\",\"它支持任意可调用类型，当然也包括非静态成员函数。我们使用了 std::decay_t，所以参数的传递其实是按值复制，而不是引用传递，这一点和大部分库的设计一致。示例如下：\",\"struct X { void f(const int& n) const { std::osyncstream{ std::cout } << &n << '\\\\n'; } }; int main() { ThreadPool pool{ 4 }; // 创建一个有 4 个线程的线程池 X x; int n = 6; std::cout << &n << '\\\\n'; auto t = pool.submit(&X::f, &x, n); // 默认复制，地址不同 auto t2 = pool.submit(&X::f, &x, std::ref(n)); t.wait(); t2.wait(); } // 析构自动 stop()\",\"运行测试。\",\"我们的线程池的 submit 成员函数在传递参数的行为上，与先前介绍的 std::thread 和 std::async 等设施基本一致。\",\"我们稍微介绍线程池的接口：\",\"构造函数和析构函数：\",\"构造函数：初始化线程池并启动线程。\",\"析构函数：停止线程池并等待所有线程结束。\",\"外部接口：\",\"stop()：停止线程池，通知所有线程退出（不会等待所有任务执行完毕）。\",\"submit()：将任务提交到任务队列，并返回一个std::future对象用于获取任务结果以及确保任务执行完毕。\",\"start()：启动线程池，创建并启动指定数量的线程。\",\"我们并没有提供一个功能强大的所谓的“调度器”，我们只是利用条件变量和互斥量，让操作系统自行调度而已，它并不具备设置任务优先级之类的调度功能。\",\"当然，你可能还希望我们的线程池具备更多功能或改进，比如控制任务优先级、设置最大线程数量、返回当前活跃线程数等。此外，异常处理也是一个值得考虑的方面。\",\"有些功能实现起来非常简单，而有些则需要更多的思考和设计。不过，这些功能超出了本次讲解的范围。如果有兴趣，可以尝试自行优化我们提供的线程池实现，添加更多的功能。我们给出的线程池实现简单完善且直观，用来学习再好不过。\"]},\"117\":{\"h\":\"总结\",\"t\":[\"在本章中我们详细的介绍了：\",\"线程池的基本概念。\",\"市面上常见的线程池的设计与使用， boost::asio::thread_pool、QThreadPool。\",\"实现一个简易的线程池。\",\"总体而言，内容并不构成太大的难度。\",\"课后作业：自己实现一个线程池，可以参考我们给出的线程池实现增加功能，提交到 homework 文件夹中。\"]},\"118\":{\"h\":\"详细分析\",\"t\":[\"存放一些源码分析，以及一些其它非知识点，而是应用的造轮子（如线程池），或者其它扩展讲解。\"]},\"119\":{\"h\":\"\",\"t\":[\" 我们会收集捐赠者进行感谢，所以请您捐赠了可以选择备注，或者联系我，或者直接在捐赠初始记录名单中进行评论。\"]},\"120\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"121\":{\"h\":\"Image\"}},\"dirtCount\":0,\"index\":[[\"详细分析\",{\"0\":{\"118\":1}}],[\"详细介绍了\",{\"1\":{\"72\":1}}],[\"课后作业\",{\"1\":{\"117\":1}}],[\"外部接口\",{\"1\":{\"116\":1}}],[\"外部程序可能做任何事情\",{\"1\":{\"30\":1}}],[\"地址不同\",{\"1\":{\"116\":1}}],[\"集合\",{\"1\":{\"116\":1}}],[\"普通的能够满足日常开发需求的\",{\"1\":{\"116\":1}}],[\"尽可能频繁地调度\",{\"1\":{\"115\":1}}],[\"尽管这不会引发数据竞争\",{\"1\":{\"79\":1}}],[\"尽管在多线程环境中有很大的保证\",{\"1\":{\"79\":1}}],[\"尽管我们可能不了解移动构造函数的具体实现\",{\"1\":{\"55\":1}}],[\"仅在没有其他线程运行时调度\",{\"1\":{\"115\":1}}],[\"仅对此操作要求原子性\",{\"1\":{\"83\":1}}],[\"描述\",{\"1\":{\"115\":1}}],[\"常量\",{\"1\":{\"115\":1}}],[\"常见的还有\",{\"1\":{\"112\":1}}],[\"常见的\",{\"1\":{\"108\":1}}],[\"枚举类型表示操作系统应如何调度新创建的线程\",{\"1\":{\"115\":1}}],[\"采用单例模式\",{\"1\":{\"115\":1}}],[\"采用的也是弱序内存模型\",{\"1\":{\"85\":1}}],[\"易于使用\",{\"1\":{\"114\":1}}],[\"易用性\",{\"1\":{\"75\":1}}],[\"市面上常见的线程池的设计与使用\",{\"1\":{\"117\":1}}],[\"市面上常见的线程池\",{\"0\":{\"113\":1}}],[\"市面上很多教程教学\",{\"1\":{\"100\":1}}],[\"套接字连接池\",{\"1\":{\"112\":1}}],[\"独有的\",{\"1\":{\"112\":1}}],[\"独占的\",{\"1\":{\"51\":1}}],[\"图中线程1\",{\"1\":{\"112\":1}}],[\"故称作线程池\",{\"1\":{\"112\":1}}],[\"故所有\",{\"1\":{\"32\":1}}],[\"抽象的来说\",{\"1\":{\"112\":1}}],[\"水池装着水\",{\"1\":{\"112\":1}}],[\"池化\",{\"1\":{\"112\":1}}],[\"池\",{\"1\":{\"112\":1}}],[\"什么叫线程池\",{\"1\":{\"112\":1}}],[\"什么时候不该使用多线程\",{\"1\":{\"7\":1}}],[\"什么时候你该使用多线程\",{\"1\":{\"7\":1}}],[\"乃至实现过线程池\",{\"1\":{\"112\":1}}],[\"乃至其它并发设施都有众多使用\",{\"1\":{\"108\":1}}],[\"微软的\",{\"1\":{\"110\":1}}],[\"方法\",{\"1\":{\"115\":1}}],[\"方法等待所有任务执行完毕并关闭线程池\",{\"1\":{\"114\":1}}],[\"方法为开发人员提供一致的异步模型\",{\"1\":{\"114\":1}}],[\"方法详细解释\",{\"0\":{\"109\":1}}],[\"方法时\",{\"1\":{\"21\":1}}],[\"`future\",{\"1\":{\"108\":1}}],[\"`\",{\"1\":{\"108\":2}}],[\"父类有这个虚函数\",{\"1\":{\"108\":1}}],[\"整体代码实现很少\",{\"1\":{\"108\":1}}],[\"做了什么\",{\"1\":{\"108\":1}}],[\"做的一样\",{\"1\":{\"34\":1}}],[\"子类进行覆盖\",{\"1\":{\"107\":1}}],[\"延迟执行和异步执行\",{\"1\":{\"107\":1}}],[\"延时\",{\"1\":{\"15\":1}}],[\"既常见也通用\",{\"1\":{\"104\":1}}],[\"既然强调了\",{\"1\":{\"94\":1}}],[\"既然是\",{\"1\":{\"92\":1}}],[\"唯一的问题是\",{\"1\":{\"108\":1}}],[\"唯一的难度或许只有那点源码\",{\"1\":{\"104\":1}}],[\"唯一需要注意的是我们使用了\",{\"1\":{\"53\":1}}],[\"利用了\",{\"1\":{\"103\":1}}],[\"想着会有人设计的互斥量让它的\",{\"1\":{\"103\":1}}],[\"想要在线程中执行异步任务\",{\"1\":{\"53\":1}}],[\"想要解决这个问题很简单\",{\"1\":{\"14\":1}}],[\"呀\",{\"1\":{\"103\":1}}],[\"空\",{\"1\":{\"102\":1}}],[\"空才需要初始化\",{\"1\":{\"33\":1}}],[\"匹配到全特化版本\",{\"1\":{\"102\":1}}],[\"匹配到主模板\",{\"1\":{\"102\":1}}],[\"匹配到偏特化版本\",{\"1\":{\"102\":1}}],[\"匹配次数后\",{\"1\":{\"35\":1}}],[\"替代\",{\"1\":{\"102\":1}}],[\"替换了库的版本\",{\"1\":{\"36\":1}}],[\"替换了库的全局版本\",{\"1\":{\"36\":1}}],[\"替换掉\",{\"1\":{\"30\":1}}],[\"替换为\",{\"1\":{\"12\":1,\"14\":1}}],[\"差不多\",{\"1\":{\"100\":1}}],[\"风格接口\",{\"1\":{\"100\":1}}],[\"去执行任务6\",{\"1\":{\"112\":1}}],[\"去遍历\",{\"1\":{\"103\":1}}],[\"去除了引用与\",{\"1\":{\"100\":1}}],[\"去调用它\",{\"1\":{\"99\":1}}],[\"真要去出错了去看标准库的代码\",{\"1\":{\"100\":1}}],[\"教导一些实现容器\",{\"1\":{\"100\":1}}],[\"教程\",{\"1\":{\"33\":1}}],[\"技术很多\",{\"1\":{\"100\":1}}],[\"示例代码\",{\"1\":{\"99\":1}}],[\"示例如下\",{\"1\":{\"54\":1,\"116\":1}}],[\"信息如下\",{\"1\":{\"99\":1}}],[\"信号量常用于发信\",{\"1\":{\"68\":1}}],[\"信号量提供两种基本操作\",{\"1\":{\"68\":1}}],[\"信号量是一个非常轻量简单的同步设施\",{\"1\":{\"68\":1}}],[\"信号量源自操作系统\",{\"1\":{\"68\":1}}],[\"信号量\",{\"0\":{\"68\":1},\"1\":{\"46\":1,\"72\":2}}],[\"选择到我们的有参构造\",{\"1\":{\"99\":1}}],[\"选择到了有参构造函数\",{\"1\":{\"99\":1}}],[\"选择到了移动构造转移线程资源的所有权\",{\"1\":{\"16\":1}}],[\"选择到了移动构造\",{\"1\":{\"16\":1}}],[\"脑补一下就行\",{\"1\":{\"99\":1}}],[\"脑补任务\",{\"1\":{\"70\":1}}],[\"赋为\",{\"1\":{\"99\":1}}],[\"赋值运算符或比较运算符\",{\"1\":{\"90\":1}}],[\"赋值操作\",{\"1\":{\"77\":1}}],[\"赋值\",{\"1\":{\"48\":1,\"75\":1}}],[\"出于某些原因\",{\"1\":{\"97\":1,\"106\":1}}],[\"出现了未定义行为\",{\"1\":{\"74\":1}}],[\"花括号通常只占一行\",{\"1\":{\"95\":1}}],[\"命名全部使用下划线连接\",{\"1\":{\"95\":1}}],[\"命名空间内为时间段提供了一系列的类型\",{\"1\":{\"59\":1}}],[\"命名空间中的四个函数的基本用法\",{\"1\":{\"15\":1}}],[\"命名空间中的时间对象\",{\"1\":{\"15\":1}}],[\"命名空间中\",{\"1\":{\"15\":1,\"59\":1}}],[\"学习\",{\"1\":{\"112\":1}}],[\"学习完了也不要忘记了回答最初的问题\",{\"1\":{\"100\":1}}],[\"学习注意事项\",{\"0\":{\"94\":1}}],[\"学完本章后\",{\"1\":{\"23\":1}}],[\"伟大无需多言\",{\"1\":{\"93\":1}}],[\"旗号说什么协程的\",{\"1\":{\"92\":1}}],[\"据我所知\",{\"1\":{\"92\":1}}],[\"许多的营销号一样的讲述\",{\"1\":{\"92\":1}}],[\"许多系统\",{\"1\":{\"69\":1}}],[\"绝大多数人对协程基本可以说是一无所知\",{\"1\":{\"92\":1}}],[\"怎么能不聊协程呢\",{\"1\":{\"92\":1}}],[\"协程的教学视频\",{\"1\":{\"92\":1}}],[\"协程的教学视频之前\",{\"1\":{\"92\":1}}],[\"协程库在\",{\"1\":{\"92\":1}}],[\"协程\",{\"0\":{\"91\":1}}],[\"协议均可随意使用学习\",{\"1\":{\"0\":1}}],[\"旨在提供一种高效\",{\"1\":{\"85\":1}}],[\"旨在减少多处理器访问共享数据时的同步开销\",{\"1\":{\"39\":1}}],[\"嵌入式系统和物联网设备中\",{\"1\":{\"85\":1}}],[\"笔记本电脑和服务器中\",{\"1\":{\"85\":1}}],[\"架构不同\",{\"1\":{\"85\":1}}],[\"架构采用的是弱序内存模型\",{\"1\":{\"85\":1}}],[\"架构采用的是\",{\"1\":{\"85\":1}}],[\"架构\",{\"1\":{\"85\":6}}],[\"架构内存模型\",{\"1\":{\"81\":1,\"94\":1}}],[\"强一致性与弱一致性\",{\"0\":{\"85\":1}}],[\"强制的复制消除\",{\"1\":{\"16\":1}}],[\"剩下的就是第三类\",{\"1\":{\"83\":1}}],[\"剩余的会被阻塞\",{\"1\":{\"68\":1}}],[\"序列一致定序\",{\"0\":{\"89\":1},\"1\":{\"83\":1}}],[\"宽松定序\",{\"0\":{\"86\":1},\"1\":{\"83\":1}}],[\"影响这些操作的行为\",{\"1\":{\"83\":1}}],[\"缓存等底层细节\",{\"1\":{\"82\":1}}],[\"知道其表达的意思就好\",{\"1\":{\"81\":1}}],[\"吗\",{\"1\":{\"81\":1}}],[\"把返回\",{\"1\":{\"107\":1}}],[\"把\",{\"1\":{\"81\":1}}],[\"把这四种变量拿出来进行对比\",{\"1\":{\"44\":1}}],[\"重写的\",{\"1\":{\"109\":1}}],[\"重新抛出该异常\",{\"1\":{\"109\":1}}],[\"重载决议选择到了弃置复制构造函数产生编译错误\",{\"1\":{\"99\":1}}],[\"重载决议简单来说就是编译器必须要根据规则选择最合适的函数重载进行调用\",{\"1\":{\"23\":1}}],[\"重排到\",{\"1\":{\"81\":2}}],[\"重排\",{\"1\":{\"81\":1,\"82\":2}}],[\"流水线更加高效地执行指令\",{\"1\":{\"81\":1}}],[\"流保证是线程安全的\",{\"1\":{\"25\":1}}],[\"少见的情况下的竞争条件引起的\",{\"1\":{\"81\":1}}],[\"专属\",{\"1\":{\"79\":1}}],[\"持有被管理对象的\",{\"1\":{\"79\":1}}],[\"持续递增的时间流逝信息的时钟\",{\"1\":{\"58\":1}}],[\"删除器\",{\"1\":{\"79\":1}}],[\"减\",{\"1\":{\"78\":1}}],[\"减少等待时间\",{\"1\":{\"81\":1}}],[\"减少对原子操作的调用次数\",{\"1\":{\"75\":1}}],[\"减少原子操作的频率\",{\"1\":{\"75\":1}}],[\"减少当前计数\",{\"1\":{\"71\":1}}],[\"减少活跃线程数\",{\"1\":{\"71\":1}}],[\"减少的都是当前屏障计数\",{\"1\":{\"71\":1}}],[\"减少计数并等待\",{\"1\":{\"71\":2}}],[\"减少计数\",{\"1\":{\"68\":1,\"70\":2}}],[\"减少浪费的执行时间\",{\"1\":{\"47\":1}}],[\"减少错误发生\",{\"1\":{\"30\":1}}],[\"减少\",{\"1\":{\"15\":1,\"44\":1}}],[\"适用于需要确保操作成功的场合\",{\"1\":{\"77\":1}}],[\"远好于\",{\"1\":{\"77\":1}}],[\"得到元组的引用初始化\",{\"1\":{\"99\":1}}],[\"得到实际存储的值\",{\"1\":{\"77\":1}}],[\"得会\",{\"1\":{\"93\":1,\"100\":1}}],[\"得不到正确的结果\",{\"1\":{\"33\":1}}],[\"过度简化了\",{\"1\":{\"100\":1}}],[\"过程\",{\"1\":{\"77\":1}}],[\"过一会儿再来判断是否完成\",{\"1\":{\"15\":1}}],[\"know\",{\"1\":{\"76\":2}}],[\"key\",{\"1\":{\"34\":4,\"37\":3}}],[\"稍微了解了一下\",{\"1\":{\"96\":1}}],[\"稍微聊一下原理\",{\"1\":{\"76\":1}}],[\"稍微注意一下构造函数和赋值运算符的实现即可\",{\"1\":{\"18\":1}}],[\"高效\",{\"1\":{\"76\":1}}],[\"高度封装\",{\"1\":{\"9\":1}}],[\"破坏了操作的原子性\",{\"1\":{\"76\":1}}],[\"销毁和复制\",{\"1\":{\"79\":1}}],[\"销毁\",{\"1\":{\"76\":2}}],[\"清除\",{\"1\":{\"76\":4}}],[\"写\",{\"1\":{\"75\":1,\"76\":1,\"77\":2}}],[\"写入到标准输出流\",{\"1\":{\"9\":1}}],[\"满足要求\",{\"1\":{\"75\":1}}],[\"满足第二个\",{\"1\":{\"31\":1}}],[\"验证自己的类型是否满足\",{\"1\":{\"75\":1}}],[\"及可复制赋值\",{\"1\":{\"75\":1}}],[\"^=\",{\"1\":{\"75\":1}}],[\"缩写\",{\"1\":{\"75\":3}}],[\"各位一定要区分\",{\"1\":{\"85\":1}}],[\"各位写代码难道还要考虑下面这段\",{\"1\":{\"81\":1}}],[\"各位不但要考虑程序的性能\",{\"1\":{\"75\":1}}],[\"各个任务通常需要通过同步设施进行相互协调和等待\",{\"1\":{\"46\":1}}],[\"宏定义且启用了\",{\"1\":{\"107\":1}}],[\"宏\",{\"1\":{\"100\":1}}],[\"宏只是为了统一\",{\"1\":{\"76\":1}}],[\"宏则更是简单了\",{\"1\":{\"75\":1}}],[\"宏进行编译时检查\",{\"1\":{\"75\":1}}],[\"始终是无锁\",{\"1\":{\"75\":1}}],[\"检查状态\",{\"1\":{\"107\":1}}],[\"检查\",{\"1\":{\"75\":1}}],[\"检查是否已经收到停止请求\",{\"1\":{\"21\":1}}],[\"数据库连接池\",{\"1\":{\"112\":1}}],[\"数据竞争的细节见内存模型\",{\"1\":{\"75\":1}}],[\"数以万计\",{\"1\":{\"81\":1}}],[\"数组\",{\"1\":{\"50\":1}}],[\"逻辑上也可视为原子操作\",{\"1\":{\"74\":1}}],[\"读\",{\"1\":{\"75\":1,\"76\":1,\"77\":2}}],[\"读取线程值\",{\"1\":{\"79\":2}}],[\"读取\",{\"1\":{\"74\":1}}],[\"读写操作如何在不同线程之间可见\",{\"1\":{\"73\":1}}],[\"读写锁\",{\"1\":{\"34\":1}}],[\"系统的所有线程\",{\"1\":{\"73\":1}}],[\"系统上的每个\",{\"1\":{\"39\":1}}],[\"私有数据成员\",{\"1\":{\"72\":1}}],[\"称为二进制信号量\",{\"1\":{\"72\":1}}],[\"称这些表达式冲突\",{\"1\":{\"25\":1}}],[\"现在只需要知道操作分为三类\",{\"1\":{\"75\":1}}],[\"现在让我们来看看底层工具\",{\"1\":{\"72\":1}}],[\"现代c++\",{\"1\":{\"114\":1}}],[\"现代c++模板教程\",{\"1\":{\"0\":1,\"93\":1,\"100\":1}}],[\"现代c++并发编程教程\",{\"0\":{\"0\":1}}],[\"现代\",{\"1\":{\"0\":1,\"92\":1,\"94\":2}}],[\"界面的示例\",{\"1\":{\"72\":1}}],[\"界面将会卡住\",{\"1\":{\"62\":1}}],[\"界面将会卡顿\",{\"1\":{\"62\":1}}],[\"查看输出结果\",{\"1\":{\"71\":1}}],[\"活跃线程数\",{\"1\":{\"71\":1}}],[\"期待计数\",{\"1\":{\"71\":1}}],[\"效果会非常明显\",{\"1\":{\"71\":1}}],[\"效果相同\",{\"1\":{\"47\":1}}],[\"开发者必须依赖自己的知识和经验\",{\"1\":{\"81\":1}}],[\"开发者可以尝试去除\",{\"1\":{\"71\":1}}],[\"开始讲述\",{\"1\":{\"106\":1}}],[\"开始等待其它线程执行到此处\",{\"1\":{\"70\":1}}],[\"开始是线程安全\",{\"1\":{\"33\":1}}],[\"开始迭代器不断向前\",{\"1\":{\"10\":1,\"53\":1}}],[\"导致它们继续在循环中自旋\",{\"1\":{\"76\":1}}],[\"导致输出结果混乱\",{\"1\":{\"71\":1}}],[\"导致抛出异常\",{\"1\":{\"25\":1}}],[\"屏障的一个阶段就完成了\",{\"1\":{\"71\":1}}],[\"屏障也是一种古老而广泛应用的同步机制\",{\"1\":{\"69\":1}}],[\"90\",{\"1\":{\"71\":1,\"116\":1}}],[\"99\",{\"1\":{\"71\":1}}],[\"999\",{\"1\":{\"59\":2}}],[\"9\",{\"1\":{\"71\":1,\"116\":2}}],[\"98\",{\"1\":{\"71\":1}}],[\"97\",{\"1\":{\"71\":1}}],[\"96\",{\"1\":{\"71\":1}}],[\"95\",{\"1\":{\"71\":1}}],[\"94\",{\"1\":{\"71\":1}}],[\"93\",{\"1\":{\"71\":1}}],[\"92\",{\"1\":{\"71\":1}}],[\"91\",{\"1\":{\"71\":1}}],[\"轮结束\",{\"1\":{\"71\":2}}],[\"彻底退出函数\",{\"1\":{\"70\":1}}],[\"门闩\",{\"1\":{\"70\":1}}],[\"闩不能重复使用\",{\"1\":{\"69\":1}}],[\"闩\",{\"1\":{\"69\":1,\"70\":1}}],[\"闩与屏障\",{\"0\":{\"69\":1},\"1\":{\"46\":1,\"72\":1}}],[\"防止服务器过载\",{\"1\":{\"68\":1}}],[\"防止在对象为空时析构出错\",{\"1\":{\"49\":1}}],[\"明白这点\",{\"1\":{\"68\":1}}],[\"明确这一点我们就开始讲吧\",{\"1\":{\"103\":1}}],[\"明确这一点\",{\"1\":{\"53\":1}}],[\"计数的值不能小于\",{\"1\":{\"68\":1}}],[\"计算并返回一个线程池的默认线程数量\",{\"1\":{\"114\":1}}],[\"计算平方并设置值到\",{\"1\":{\"54\":1}}],[\"计算函数\",{\"1\":{\"54\":1}}],[\"计算每个线程处理的元素数量\",{\"1\":{\"10\":1,\"53\":1}}],[\"计算机中的并发有两种方式\",{\"1\":{\"5\":1}}],[\"牢记信号量的基本的概念不变\",{\"1\":{\"68\":1}}],[\"尝试引用已删除的函数\",{\"1\":{\"99\":1}}],[\"尝试将\",{\"1\":{\"77\":1}}],[\"尝试将原子对象的当前值与预期值进行比较\",{\"1\":{\"77\":1}}],[\"尝试获取信号量\",{\"1\":{\"68\":2}}],[\"尝试加锁\",{\"1\":{\"28\":1}}],[\"服务器处理并发请求的数量\",{\"1\":{\"68\":1}}],[\"服务器\",{\"1\":{\"68\":1}}],[\"发信\",{\"1\":{\"68\":1}}],[\"发送信号\",{\"1\":{\"68\":4}}],[\"好了\",{\"1\":{\"68\":1,\"81\":1,\"96\":1,\"110\":1}}],[\"好像这些任务都在同时执行\",{\"1\":{\"5\":1}}],[\"观察不同情况下\",{\"1\":{\"67\":1}}],[\"观看\",{\"1\":{\"51\":1}}],[\"毕竟\",{\"1\":{\"103\":1}}],[\"毕竟如果你不用线程\",{\"1\":{\"67\":1}}],[\"毕竟是初学\",{\"1\":{\"10\":1}}],[\"跨平台兼容性\",{\"0\":{\"66\":1}}],[\"连接信号\",{\"1\":{\"64\":1}}],[\"样式\",{\"1\":{\"64\":1}}],[\"插件后打开此项目\",{\"1\":{\"63\":1}}],[\"项目结构简单\",{\"1\":{\"63\":1}}],[\"项目使用\",{\"1\":{\"63\":1}}],[\"项目说明\",{\"0\":{\"63\":1}}],[\"按照标准规定\",{\"1\":{\"71\":1}}],[\"按钮或移动窗口\",{\"1\":{\"62\":1}}],[\"按钮并触发弹窗\",{\"1\":{\"62\":1}}],[\"按复制捕获\",{\"1\":{\"56\":1}}],[\"控件的更新操作在主线程中执行\",{\"1\":{\"62\":1}}],[\"控件\",{\"1\":{\"62\":1}}],[\"控件通常只能在创建它们的线程中进行操作\",{\"1\":{\"62\":1}}],[\"控制块又是线程安全的\",{\"1\":{\"79\":1}}],[\"控制块是线程安全的\",{\"1\":{\"79\":1}}],[\"控制块是一个动态分配的对象\",{\"1\":{\"79\":1}}],[\"控制线程等待和唤醒\",{\"1\":{\"49\":1}}],[\"控制线程的停止与退出\",{\"1\":{\"49\":1}}],[\"控制流首次经过它的声明时才会被初始化\",{\"1\":{\"43\":1}}],[\"背景介绍\",{\"0\":{\"62\":1}}],[\"带超时功能\",{\"1\":{\"60\":1}}],[\"恢复默认精度\",{\"1\":{\"60\":1}}],[\"调度频率高于\",{\"1\":{\"115\":2}}],[\"调度频率低于\",{\"1\":{\"115\":2}}],[\"调度器\",{\"1\":{\"116\":1}}],[\"调度器才可能会再次唤醒它们\",{\"1\":{\"112\":1}}],[\"调度器会唤醒休眠的线程\",{\"1\":{\"112\":1}}],[\"调度器会将任务分配给线程池中的空闲线程进行执行\",{\"1\":{\"112\":1}}],[\"调度的最小单位\",{\"1\":{\"112\":1}}],[\"调整系统时钟的精度\",{\"1\":{\"60\":1}}],[\"调用函数对象并捕获异常\",{\"1\":{\"107\":3,\"109\":1}}],[\"调用该可调用对象时所需的参数\",{\"1\":{\"107\":1}}],[\"调用第一个重载\",{\"1\":{\"107\":1}}],[\"调用可调用对象即可\",{\"1\":{\"103\":1}}],[\"调用可调用对象的参数\",{\"1\":{\"99\":1}}],[\"调用不会上锁的构造函数的参数顺序不同\",{\"1\":{\"103\":1}}],[\"调用非\",{\"1\":{\"79\":1}}],[\"调用时执行\",{\"1\":{\"52\":1,\"59\":1}}],[\"调用另一个重载版本\",{\"1\":{\"52\":1}}],[\"调用就阻塞了\",{\"1\":{\"27\":1}}],[\"调用了\",{\"1\":{\"25\":1,\"31\":1,\"52\":1}}],[\"调用是线程安全的\",{\"1\":{\"25\":1,\"71\":1}}],[\"调用和执行\",{\"1\":{\"14\":1}}],[\"调用成员函数的参数\",{\"1\":{\"14\":1}}],[\"调用析构函数\",{\"1\":{\"13\":1}}],[\"调用之前\",{\"1\":{\"12\":1}}],[\"调用\",{\"1\":{\"9\":1,\"12\":1,\"27\":1,\"32\":1,\"38\":1,\"54\":1,\"55\":3,\"71\":1,\"77\":1,\"79\":1,\"99\":2,\"100\":2,\"107\":1,\"108\":2,\"109\":1,\"114\":1,\"116\":1}}],[\"纳秒之后的时间\",{\"1\":{\"60\":1}}],[\"纳秒\",{\"1\":{\"60\":1}}],[\"千分之一秒\",{\"1\":{\"59\":1}}],[\"节拍\",{\"1\":{\"59\":1}}],[\"概念与使用\",{\"1\":{\"93\":1}}],[\"概念\",{\"1\":{\"58\":1}}],[\"概念从来不是我们的重点\",{\"1\":{\"7\":1,\"26\":1}}],[\"像\",{\"1\":{\"58\":1}}],[\"分别是\",{\"1\":{\"99\":1}}],[\"分配器\",{\"1\":{\"79\":1}}],[\"分母有默认实参\",{\"1\":{\"58\":1}}],[\"分离的线程可能还在运行\",{\"1\":{\"12\":1}}],[\"分离\",{\"1\":{\"12\":2}}],[\"周期就可以表示为\",{\"1\":{\"58\":1}}],[\"稳定时钟的主要优点在于\",{\"1\":{\"58\":1}}],[\"稳定时钟\",{\"1\":{\"58\":2}}],[\"三个版本的代码都展示了\",{\"1\":{\"103\":1}}],[\"三个枚举项分别表示三种\",{\"1\":{\"59\":1}}],[\"三个阶段稍微介绍一下\",{\"1\":{\"57\":1}}],[\"三方库进行声音播放\",{\"1\":{\"49\":1}}],[\"超时\",{\"1\":{\"59\":1,\"60\":1}}],[\"超过指定的时长或抵达指定的时间点\",{\"1\":{\"57\":1}}],[\"超线程技术被称为\",{\"1\":{\"10\":1}}],[\"超线程技术是一项硬件创新\",{\"1\":{\"10\":1}}],[\"超线程技术\",{\"1\":{\"10\":1}}],[\"处理异步任务返回值的方式类型\",{\"1\":{\"107\":1}}],[\"处理可变参数\",{\"1\":{\"104\":1}}],[\"处理\",{\"1\":{\"100\":2,\"107\":1}}],[\"处理绝对时间的函数以\",{\"1\":{\"57\":1}}],[\"处理持续时间的函数以\",{\"1\":{\"57\":1}}],[\"处理步骤\",{\"1\":{\"28\":2}}],[\"毫秒左右\",{\"1\":{\"60\":1}}],[\"毫秒触发一次中断\",{\"1\":{\"60\":1}}],[\"毫秒内变为就绪状态\",{\"1\":{\"59\":1}}],[\"毫秒\",{\"1\":{\"57\":1,\"59\":2,\"60\":3}}],[\"限定\",{\"1\":{\"99\":1,\"100\":1}}],[\"限时等待\",{\"0\":{\"57\":1},\"1\":{\"72\":1}}],[\"限制了对象\",{\"1\":{\"27\":1}}],[\"隐式转移所有权\",{\"1\":{\"56\":1}}],[\"隐式转换为了指向这个数组的指针\",{\"1\":{\"14\":1}}],[\"隐式转换为\",{\"1\":{\"14\":2}}],[\"收到数据\",{\"1\":{\"56\":4}}],[\"于是我们将与其关联的\",{\"1\":{\"56\":2}}],[\"于是就想让我们的程序也增加\",{\"1\":{\"49\":1}}],[\"参见前面的\",{\"1\":{\"108\":1}}],[\"参见前文的\",{\"1\":{\"55\":1}}],[\"参见\",{\"1\":{\"99\":1,\"100\":1,\"107\":1}}],[\"参见源码声明\",{\"1\":{\"59\":1}}],[\"参数通过完美转发\",{\"1\":{\"100\":1}}],[\"参数强制异步执行任务\",{\"1\":{\"65\":1}}],[\"参数的构造函数\",{\"1\":{\"56\":1}}],[\"参数传递的事\",{\"1\":{\"52\":1}}],[\"参数\",{\"1\":{\"30\":1,\"108\":1}}],[\"意思是信号量维护的计数最大值\",{\"1\":{\"68\":1}}],[\"意思也很简单\",{\"1\":{\"14\":1}}],[\"意味着\",{\"1\":{\"55\":1}}],[\"值初始化了数据成员\",{\"1\":{\"99\":1}}],[\"值\",{\"1\":{\"54\":2,\"77\":1,\"115\":1}}],[\"值得注意的是\",{\"1\":{\"36\":1,\"53\":1,\"76\":1,\"107\":1}}],[\"产生异常\",{\"1\":{\"54\":1}}],[\"产生线程\",{\"1\":{\"18\":1}}],[\"反之亦然\",{\"1\":{\"54\":1}}],[\"反面示例\",{\"1\":{\"30\":1}}],[\"二选一\",{\"1\":{\"54\":1}}],[\"制作任务\",{\"1\":{\"53\":1}}],[\"改\",{\"1\":{\"75\":1,\"76\":1,\"77\":2}}],[\"改成\",{\"1\":{\"53\":1}}],[\"改写一下\",{\"1\":{\"31\":1}}],[\"老老实实执行我们传递的任务\",{\"1\":{\"53\":1}}],[\"幻想还有许多耗时的代码\",{\"1\":{\"53\":1}}],[\"目标\",{\"1\":{\"53\":1}}],[\"目标线程的可取消性状态和类型决定了取消何时生效\",{\"1\":{\"21\":1}}],[\"失败时的内存序为\",{\"1\":{\"77\":1}}],[\"失败就返回\",{\"1\":{\"28\":1}}],[\"失去共享状态\",{\"1\":{\"52\":1,\"108\":1}}],[\"策略实现并不符合标准\",{\"1\":{\"110\":1}}],[\"策略创建的\",{\"1\":{\"108\":1}}],[\"策略并不是单纯的创建线程让任务执行\",{\"1\":{\"107\":1}}],[\"策略\",{\"1\":{\"52\":1}}],[\"策略为\",{\"1\":{\"38\":1}}],[\"典型情况是\",{\"1\":{\"52\":1}}],[\"惰性求值\",{\"1\":{\"52\":1}}],[\"移动\",{\"1\":{\"75\":1}}],[\"移动语义\",{\"1\":{\"55\":1}}],[\"移动赋值\",{\"1\":{\"52\":1,\"95\":1}}],[\"移动构造函数\",{\"1\":{\"99\":1}}],[\"移动构造转移线程资源的所有权到\",{\"1\":{\"16\":1}}],[\"移动构造\",{\"1\":{\"14\":1,\"52\":1,\"95\":1}}],[\"you\",{\"1\":{\"76\":4}}],[\"years\",{\"1\":{\"59\":1}}],[\"y\",{\"1\":{\"52\":5,\"75\":9}}],[\"yield\",{\"1\":{\"15\":5,\"92\":1}}],[\"异步任务执行\",{\"0\":{\"61\":1}}],[\"异步任务\",{\"1\":{\"52\":2}}],[\"异常处理也是一个值得考虑的方面\",{\"1\":{\"116\":1}}],[\"异常处理\",{\"1\":{\"109\":1}}],[\"异常的处理以及任务完成的通知\",{\"1\":{\"107\":1}}],[\"异常指针等设施\",{\"1\":{\"110\":1}}],[\"异常指针\",{\"1\":{\"107\":2}}],[\"异常之类的是例外\",{\"1\":{\"33\":1}}],[\"异常\",{\"1\":{\"33\":1,\"54\":1,\"55\":1,\"107\":1}}],[\"头文件\",{\"1\":{\"52\":1}}],[\"头文件中\",{\"1\":{\"47\":1,\"51\":1}}],[\"若多个执行线程不同步地同时访问同一std\",{\"1\":{\"79\":1}}],[\"若多个执行线程访问同一\",{\"1\":{\"72\":1,\"79\":1}}],[\"若每个线程都是通过其自身的\",{\"1\":{\"51\":1,\"56\":1}}],[\"若所有权层数为\",{\"1\":{\"35\":1}}],[\"能看到线程\",{\"1\":{\"82\":1}}],[\"能够看到操作\",{\"1\":{\"82\":1}}],[\"能够读取到线程\",{\"1\":{\"82\":1}}],[\"能够正常点击\",{\"1\":{\"62\":1}}],[\"能不能调用\",{\"1\":{\"79\":1}}],[\"能用于避免数据竞争\",{\"1\":{\"72\":1,\"79\":1}}],[\"能控制对共享资源的访问\",{\"1\":{\"68\":1}}],[\"能关联多个事件\",{\"1\":{\"51\":1}}],[\"能在任何满足可基本锁定\",{\"1\":{\"47\":1}}],[\"共享状态在经过指定的等待时间内仍未就绪\",{\"1\":{\"59\":1}}],[\"共享状态就绪\",{\"1\":{\"59\":1}}],[\"共享状态持有的函数正在延迟运行\",{\"1\":{\"59\":1}}],[\"共享状态失效\",{\"1\":{\"55\":1}}],[\"共享状态的\",{\"1\":{\"54\":2}}],[\"共享的\",{\"1\":{\"51\":1}}],[\"共享数据\",{\"0\":{\"24\":1}}],[\"车到站\",{\"1\":{\"51\":1}}],[\"玩手机等\",{\"1\":{\"51\":1}}],[\"感兴趣的话可以参考该项目\",{\"1\":{\"50\":1}}],[\"盘插拔状态变化\",{\"1\":{\"50\":1}}],[\"库提供的一种线程池实现\",{\"1\":{\"114\":1}}],[\"库\",{\"1\":{\"50\":1,\"110\":1,\"114\":1}}],[\"官网上下载的\",{\"1\":{\"50\":1}}],[\"格式的音频文件\",{\"1\":{\"50\":2}}],[\"便于使用\",{\"1\":{\"50\":1}}],[\"资源影响主程序的运行\",{\"1\":{\"49\":1}}],[\"资源获取即初始化\",{\"1\":{\"13\":1}}],[\"音频播放器\",{\"1\":{\"49\":1}}],[\"音频任务队列\",{\"1\":{\"49\":1}}],[\"继续播放下一个音频\",{\"1\":{\"49\":1}}],[\"取出后就删除元素\",{\"1\":{\"49\":1}}],[\"取决于操作系统的调度\",{\"1\":{\"14\":1}}],[\"队列\",{\"1\":{\"49\":1}}],[\"队列为空\",{\"1\":{\"48\":2}}],[\"该指针指向一个新的\",{\"1\":{\"107\":1}}],[\"该线程成功获取了锁\",{\"1\":{\"76\":1}}],[\"该线程会一直处于等待状态\",{\"1\":{\"49\":1}}],[\"该代码实现了一个简单的后台音频播放类型\",{\"1\":{\"49\":1}}],[\"该函数需要通过互斥量来保护数据一致性\",{\"1\":{\"49\":1}}],[\"向前移动一个元素\",{\"1\":{\"78\":1}}],[\"向队列添加播放任务时\",{\"1\":{\"49\":1}}],[\"向队列添加新的元素\",{\"1\":{\"49\":1}}],[\"向可调用对象传递参数很简单\",{\"1\":{\"14\":1}}],[\"语音提示\",{\"1\":{\"49\":1}}],[\"语言定义中只有这些类型的操作是原子的\",{\"1\":{\"75\":1}}],[\"语言层面也并未提供此抽象\",{\"1\":{\"39\":1}}],[\"语言层面没有进程的概念\",{\"1\":{\"3\":1}}],[\"语言特性\",{\"1\":{\"37\":1}}],[\"领导可能突然要求添加一些竞争对手产品的功能\",{\"1\":{\"49\":1}}],[\"|=\",{\"1\":{\"75\":1}}],[\"||\",{\"1\":{\"49\":1,\"116\":1}}],[\"|\",{\"1\":{\"48\":60,\"52\":3,\"107\":20,\"108\":18,\"110\":1}}],[\"初始线程有\",{\"1\":{\"71\":1}}],[\"初始状态\",{\"1\":{\"48\":1}}],[\"初始化线程池并启动线程\",{\"1\":{\"116\":1}}],[\"初始化数据成员\",{\"1\":{\"103\":1}}],[\"初始化为\",{\"1\":{\"77\":1}}],[\"初始化不是原子操作\",{\"1\":{\"75\":1}}],[\"初始化计数为\",{\"1\":{\"71\":1}}],[\"初始化严格发生一次\",{\"1\":{\"33\":1}}],[\"初始化\",{\"1\":{\"33\":2,\"76\":1,\"107\":1}}],[\"初始化函数f\",{\"1\":{\"16\":2}}],[\"消费定序\",{\"0\":{\"88\":1}}],[\"消费\",{\"1\":{\"48\":1}}],[\"生产\",{\"1\":{\"48\":1}}],[\"生产者消费者模型\",{\"1\":{\"48\":1}}],[\"生存期结束\",{\"1\":{\"12\":1}}],[\"光写好了肯定不够\",{\"1\":{\"48\":1}}],[\"交换后的\",{\"1\":{\"75\":2}}],[\"交换前的\",{\"1\":{\"75\":2}}],[\"交换\",{\"1\":{\"48\":1,\"77\":1}}],[\"交出\",{\"1\":{\"15\":1}}],[\"qcoreapplication\",{\"1\":{\"115\":2}}],[\"qdebug\",{\"1\":{\"115\":4}}],[\"qrunnable\",{\"1\":{\"115\":4}}],[\"qvboxlayout\",{\"1\":{\"64\":2}}],[\"qsizepolicy\",{\"1\":{\"64\":4}}],[\"qstring\",{\"1\":{\"64\":2}}],[\"qpushbutton\",{\"1\":{\"64\":7}}],[\"qprogressbar\",{\"1\":{\"64\":4}}],[\"qwidget\",{\"1\":{\"64\":2}}],[\"qmessagebox\",{\"1\":{\"64\":3}}],[\"qmetaobject\",{\"1\":{\"62\":5,\"64\":4,\"65\":1}}],[\"qmainwindow\",{\"1\":{\"64\":2}}],[\"q\",{\"1\":{\"48\":4,\"64\":1}}],[\"queue<task>\",{\"1\":{\"116\":3}}],[\"queue<t>\",{\"1\":{\"48\":1}}],[\"queue<std\",{\"1\":{\"49\":1}}],[\"queue<int>\",{\"1\":{\"48\":2}}],[\"queue\",{\"1\":{\"48\":12,\"49\":7}}],[\"qthradpool\",{\"1\":{\"115\":1}}],[\"qthread\",{\"1\":{\"115\":9}}],[\"qthreads\",{\"1\":{\"115\":1}}],[\"qthreadpool\",{\"1\":{\"115\":8,\"117\":1}}],[\"qt6\",{\"1\":{\"115\":1}}],[\"qt\",{\"1\":{\"46\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":2,\"72\":1,\"94\":1,\"115\":2}}],[\"基于时间段的等待都是由\",{\"1\":{\"59\":1}}],[\"基于以上思考\",{\"1\":{\"48\":1}}],[\"基本相同\",{\"1\":{\"107\":1}}],[\"基本全部都是错误的\",{\"1\":{\"92\":1}}],[\"基本认识也就足够了\",{\"1\":{\"81\":1}}],[\"基本都是多核\",{\"1\":{\"5\":1}}],[\"基本上是二者都有\",{\"1\":{\"5\":1}}],[\"基本概念与线程变量类似\",{\"1\":{\"44\":1}}],[\"基本概念\",{\"0\":{\"2\":1}}],[\"操作系统的默认优先级\",{\"1\":{\"115\":1}}],[\"操作同步于任何随后的\",{\"1\":{\"82\":1}}],[\"操作是针对\",{\"1\":{\"78\":1}}],[\"操作失败\",{\"1\":{\"77\":1}}],[\"操作成功\",{\"1\":{\"77\":1}}],[\"操作来设置和获取值\",{\"1\":{\"75\":1}}],[\"操作仅限\",{\"1\":{\"75\":1}}],[\"操作的线程将会一直阻塞\",{\"1\":{\"68\":2}}],[\"操作\",{\"1\":{\"48\":4,\"63\":1,\"68\":1,\"75\":4,\"76\":1,\"77\":1,\"82\":2}}],[\"操作时队列不为空\",{\"1\":{\"48\":1}}],[\"操作时\",{\"1\":{\"48\":2}}],[\"操作受保护的数据\",{\"1\":{\"29\":1}}],[\"虚假唤醒\",{\"1\":{\"47\":1}}],[\"②等价于\",{\"1\":{\"47\":1}}],[\"唤醒了等待在条件变量上的线程\",{\"1\":{\"47\":1}}],[\"唤醒一个等待条件变量的线程\",{\"1\":{\"47\":1}}],[\"暂停当前线程\",{\"1\":{\"47\":1}}],[\"变为其它值\",{\"1\":{\"79\":1}}],[\"变为\",{\"1\":{\"47\":2}}],[\"变量模板\",{\"1\":{\"97\":1,\"106\":1}}],[\"变量的使用是少见的\",{\"1\":{\"44\":1}}],[\"变量的概念对于系统编程和内核开发非常重要\",{\"1\":{\"39\":1}}],[\"变量的概念很好理解\",{\"1\":{\"39\":1}}],[\"变量机制\",{\"1\":{\"39\":1}}],[\"变量是为每个处理器单独分配的变量副本\",{\"1\":{\"39\":1,\"44\":1}}],[\"变量时\",{\"1\":{\"39\":1}}],[\"变量也是如此\",{\"1\":{\"39\":1}}],[\"变量\",{\"0\":{\"39\":1},\"1\":{\"37\":1,\"39\":1,\"45\":1}}],[\"版本的\",{\"1\":{\"50\":1}}],[\"版本开始通过\",{\"1\":{\"50\":1}}],[\"版本开始引入了\",{\"1\":{\"39\":1}}],[\"版更加通用但是却有更多的性能开销\",{\"1\":{\"47\":1}}],[\"休眠结束\",{\"1\":{\"70\":2}}],[\"休眠\",{\"1\":{\"47\":1}}],[\"休眠②前函数对互斥量解锁①\",{\"1\":{\"47\":1}}],[\"循环中\",{\"1\":{\"47\":1}}],[\"忙等待\",{\"1\":{\"47\":1}}],[\"估算一下地铁到达目的地的时间\",{\"1\":{\"47\":1}}],[\"构建带\",{\"1\":{\"94\":1}}],[\"构建了一个带有\",{\"1\":{\"72\":1}}],[\"构建一个项目展示多线程的必要性\",{\"1\":{\"46\":1}}],[\"构造源码解析\",{\"1\":{\"107\":1}}],[\"构造上锁\",{\"1\":{\"102\":1,\"103\":1}}],[\"构造一个独占智能指针\",{\"1\":{\"99\":1}}],[\"构造新的\",{\"1\":{\"99\":1}}],[\"构造不关联线程的新\",{\"1\":{\"99\":1}}],[\"构造不表示线程的新\",{\"1\":{\"12\":1}}],[\"构造和析构不涉及共享资源\",{\"1\":{\"36\":1}}],[\"构造都额外传递了一个\",{\"1\":{\"30\":1}}],[\"构造了一个临时对象\",{\"1\":{\"16\":1}}],[\"构造\",{\"1\":{\"16\":1,\"31\":1,\"99\":1}}],[\"构造是代表\",{\"1\":{\"14\":1}}],[\"构造参数的传递的时候会decay\",{\"1\":{\"14\":1}}],[\"构造出一个临时的\",{\"1\":{\"14\":1}}],[\"构造线程对象\",{\"1\":{\"14\":1}}],[\"构造函数和析构函数\",{\"1\":{\"116\":1}}],[\"构造函数\",{\"1\":{\"36\":1,\"116\":1}}],[\"构造函数不上锁\",{\"1\":{\"31\":2}}],[\"构造函数中初始化这个引用\",{\"1\":{\"27\":1}}],[\"构造函数中初始化副本\",{\"1\":{\"14\":1}}],[\"构造函数的源码即可\",{\"1\":{\"16\":1}}],[\"构造函数申请资源\",{\"1\":{\"13\":1}}],[\"介绍完了\",{\"1\":{\"108\":1}}],[\"介绍两种指定超时的方式\",{\"1\":{\"57\":1}}],[\"介绍\",{\"1\":{\"46\":2,\"108\":1}}],[\"介绍了一下\",{\"1\":{\"15\":1}}],[\"某类型\",{\"1\":{\"45\":1}}],[\"条件变量才会被通知\",{\"1\":{\"108\":1}}],[\"条件变量会通知等待的任务\",{\"1\":{\"107\":1}}],[\"条件变量等高级同步设施\",{\"1\":{\"82\":1}}],[\"条件变量等设施\",{\"1\":{\"45\":1}}],[\"条件变量虚假唤醒是指在使用条件变量进行线程同步时\",{\"1\":{\"47\":1}}],[\"条件变量的\",{\"1\":{\"47\":1,\"108\":1}}],[\"条件变量\",{\"1\":{\"46\":1,\"47\":1,\"48\":1,\"57\":1,\"107\":1,\"110\":1}}],[\"条件竞争\",{\"0\":{\"25\":1}}],[\"加\",{\"1\":{\"78\":1}}],[\"加载\",{\"1\":{\"77\":1}}],[\"加载操作\",{\"1\":{\"75\":1}}],[\"加深印象\",{\"1\":{\"44\":1}}],[\"加上\",{\"1\":{\"14\":1}}],[\"结构很明确\",{\"1\":{\"98\":1}}],[\"结果是两个时间点的时间差\",{\"1\":{\"60\":1}}],[\"结果将仅在明确请求时计算\",{\"1\":{\"59\":1}}],[\"结合实际使用即可\",{\"1\":{\"44\":1}}],[\"结束时释放\",{\"1\":{\"41\":1}}],[\"作函数形参\",{\"1\":{\"53\":1}}],[\"作用域结束自动释放\",{\"1\":{\"44\":1}}],[\"作为第二个参数\",{\"1\":{\"59\":1}}],[\"作为后缀\",{\"1\":{\"57\":2}}],[\"作为底层数据成员\",{\"1\":{\"18\":1}}],[\"作为\",{\"1\":{\"14\":1}}],[\"作为构造参数\",{\"1\":{\"14\":1}}],[\"作为它的可调用\",{\"1\":{\"9\":1}}],[\"非常经典的处理可变参数做法\",{\"1\":{\"103\":1}}],[\"非常简单\",{\"1\":{\"99\":1}}],[\"非常适合用作制作自旋锁\",{\"1\":{\"76\":1}}],[\"非常的直观\",{\"1\":{\"71\":1}}],[\"非局部变量\",{\"1\":{\"43\":1}}],[\"非静态成员\",{\"1\":{\"14\":1}}],[\"静态断言求值中第一个表达式求值为\",{\"1\":{\"75\":1}}],[\"静态成员函数模板\",{\"1\":{\"99\":1}}],[\"静态成员函数\",{\"1\":{\"72\":1}}],[\"静态常量判断当前时钟是否是稳定时钟\",{\"1\":{\"58\":1}}],[\"静态局部变量\",{\"1\":{\"43\":1,\"45\":1}}],[\"静态局部变量初始化在\",{\"1\":{\"33\":1}}],[\"静态局部变量初始化从\",{\"1\":{\"33\":1}}],[\"静态\",{\"1\":{\"42\":1}}],[\"拥有以下成员函数\",{\"1\":{\"78\":1}}],[\"拥有\",{\"1\":{\"42\":1,\"43\":1}}],[\"拥有两个冲突的求值的程序就有数据竞争\",{\"1\":{\"25\":1}}],[\"几乎无需关心底层具体实现\",{\"1\":{\"114\":1}}],[\"几乎无需同步\",{\"1\":{\"41\":1}}],[\"几乎没有任何区别\",{\"1\":{\"102\":1}}],[\"几乎所有打着\",{\"1\":{\"92\":1}}],[\"几乎\",{\"1\":{\"44\":1,\"45\":1}}],[\"几乎完全相同\",{\"1\":{\"27\":1}}],[\"随着水平的提升\",{\"1\":{\"112\":1}}],[\"随作用域开始分配\",{\"1\":{\"41\":1}}],[\"随意\",{\"1\":{\"1\":2}}],[\"局部变量适合临时数据\",{\"1\":{\"44\":1}}],[\"局部变量\",{\"0\":{\"41\":1}}],[\"局部对象就要逆序销毁了\",{\"1\":{\"13\":1}}],[\"局部对象\",{\"1\":{\"12\":2}}],[\"掌握这些知识不仅有助于应对面试问题\",{\"1\":{\"39\":1}}],[\"理解这个关系对我们后面非常重要\",{\"1\":{\"107\":1}}],[\"理解\",{\"1\":{\"39\":1}}],[\"增加了一些\",{\"1\":{\"99\":1}}],[\"增加计数\",{\"1\":{\"68\":1}}],[\"增加这两个功能\",{\"1\":{\"20\":1}}],[\"增进理解\",{\"1\":{\"44\":1}}],[\"增强了并行处理能力\",{\"1\":{\"39\":1}}],[\"功能\",{\"1\":{\"39\":1}}],[\"虽然还有不少接口没有介绍\",{\"1\":{\"115\":1}}],[\"虽然还没有讲\",{\"1\":{\"38\":1}}],[\"虽然看起来复杂\",{\"1\":{\"107\":1}}],[\"虽然是\",{\"1\":{\"99\":1}}],[\"虽然教程名为\",{\"1\":{\"94\":1}}],[\"虽然经常会提到\",{\"1\":{\"82\":1}}],[\"虽然同样不可复制不可移动\",{\"1\":{\"77\":1}}],[\"虽然也可以用互斥量来模拟原子操作\",{\"1\":{\"75\":1}}],[\"虽然\",{\"1\":{\"71\":1,\"78\":1}}],[\"虽然说是说有\",{\"1\":{\"68\":1}}],[\"虽然它的返回类型是\",{\"1\":{\"56\":1}}],[\"虽强调现代\",{\"1\":{\"0\":1}}],[\"默认复制\",{\"1\":{\"116\":1}}],[\"默认移动\",{\"1\":{\"99\":1}}],[\"默认的内存顺序是\",{\"1\":{\"76\":1}}],[\"默认值是\",{\"1\":{\"70\":1}}],[\"默认情况下\",{\"1\":{\"115\":1}}],[\"默认情况下精度约为\",{\"1\":{\"60\":1}}],[\"默认情况就支持\",{\"1\":{\"37\":1}}],[\"默认是根据第一个参数时钟得到的\",{\"1\":{\"60\":1}}],[\"默认构造函数\",{\"1\":{\"99\":1}}],[\"默认构造会上锁\",{\"1\":{\"31\":1}}],[\"默认构造\",{\"1\":{\"14\":1,\"16\":1,\"52\":1,\"95\":1}}],[\"两种\",{\"1\":{\"37\":1}}],[\"两个线程分别运行\",{\"1\":{\"48\":1}}],[\"两个线程需要对它们所有的互斥量做一些操作\",{\"1\":{\"30\":1}}],[\"两个线程共享一个\",{\"1\":{\"25\":1}}],[\"两个函数共享了一个锁\",{\"1\":{\"27\":1}}],[\"两个冲突的求值都是原子操作\",{\"1\":{\"25\":1}}],[\"两个求值都在同一线程上\",{\"1\":{\"25\":1}}],[\"两个\",{\"1\":{\"16\":1,\"99\":1}}],[\"机制\",{\"1\":{\"37\":1}}],[\"来决定创建的异步任务状态对象类型\",{\"1\":{\"107\":1}}],[\"来去除了类型的引用和\",{\"1\":{\"99\":1}}],[\"来定义如何确保这种可见\",{\"1\":{\"82\":1}}],[\"来发现和解决内存次序错误\",{\"1\":{\"81\":1}}],[\"来进行同步操作\",{\"1\":{\"75\":1}}],[\"来保护共享资源\",{\"1\":{\"74\":1}}],[\"来划分任务执行的工作区间\",{\"1\":{\"70\":1}}],[\"来跨线程调用主线程上的控件方法\",{\"1\":{\"62\":1}}],[\"来表示\",{\"1\":{\"60\":1}}],[\"来完成\",{\"1\":{\"59\":2}}],[\"来指定\",{\"1\":{\"58\":1}}],[\"来替代\",{\"1\":{\"56\":1}}],[\"来自\",{\"1\":{\"54\":2}}],[\"来自线程的异常\",{\"1\":{\"54\":2}}],[\"来实现线程局部存储\",{\"1\":{\"37\":1}}],[\"来管理线程局部存储\",{\"1\":{\"37\":1}}],[\"来处理这种情况\",{\"1\":{\"33\":1}}],[\"展示多线程异步的必要性\",{\"1\":{\"94\":1}}],[\"展示异步多线程的必要性\",{\"1\":{\"72\":1}}],[\"展示可以使用\",{\"1\":{\"53\":1}}],[\"展示了如何使用\",{\"1\":{\"75\":1}}],[\"展示了如何在不阻塞\",{\"1\":{\"61\":1}}],[\"展示了\",{\"1\":{\"37\":1}}],[\"展开之后\",{\"1\":{\"99\":1}}],[\"展开就是\",{\"1\":{\"99\":1}}],[\"展开\",{\"1\":{\"23\":1}}],[\"互不干扰一样\",{\"1\":{\"39\":1}}],[\"互不干扰\",{\"1\":{\"37\":1}}],[\"互斥体\",{\"1\":{\"26\":1,\"103\":1}}],[\"互斥量和条件变量\",{\"1\":{\"107\":1}}],[\"互斥量是一种睡眠锁\",{\"1\":{\"76\":1}}],[\"互斥量确保了对共享资源的读写是线程安全的\",{\"1\":{\"74\":1}}],[\"互斥量确保了同一时间不会有其它地方在操作共享资源\",{\"1\":{\"49\":1}}],[\"互斥量确保共享资源的同步\",{\"1\":{\"49\":1}}],[\"互斥量才会真正释放\",{\"1\":{\"35\":1}}],[\"互斥量只是其中一种常见的方式而已\",{\"1\":{\"33\":1}}],[\"互斥量满足互斥体\",{\"1\":{\"32\":1}}],[\"互斥量主要也就是为了保护共享数据\",{\"1\":{\"29\":1}}],[\"互斥量\",{\"1\":{\"26\":1,\"48\":1,\"107\":1,\"108\":1,\"116\":1}}],[\"广泛应用于各种编程语言\",{\"1\":{\"37\":1}}],[\"例如在我的硬件上为\",{\"1\":{\"115\":1}}],[\"例如硬件并发能力无法被检测时\",{\"1\":{\"114\":1}}],[\"例如有一个全局的指针指向了一个线程局部变量\",{\"1\":{\"45\":1}}],[\"例如前文提到的\",{\"1\":{\"45\":1}}],[\"例如\",{\"1\":{\"37\":1,\"45\":1,\"50\":1,\"58\":1,\"59\":2,\"60\":1,\"69\":1,\"70\":1,\"75\":3,\"76\":1,\"77\":1,\"81\":2,\"82\":2,\"85\":1,\"94\":1}}],[\"例如现在是\",{\"1\":{\"1\":1}}],[\"例子\",{\"1\":{\"36\":1}}],[\"存放一些源码分析\",{\"1\":{\"118\":1}}],[\"存在缺陷\",{\"1\":{\"71\":1}}],[\"存在于\",{\"1\":{\"59\":1}}],[\"存在条件竞争\",{\"1\":{\"56\":2}}],[\"存在数据竞争\",{\"1\":{\"36\":2}}],[\"存储管理线程对象\",{\"1\":{\"116\":1}}],[\"存储等待执行的任务\",{\"1\":{\"116\":1}}],[\"存储了一个\",{\"1\":{\"102\":1}}],[\"存储了函数对象和参数的副本的指针\",{\"1\":{\"99\":1}}],[\"存储了传入的函数对象和参数的副本\",{\"1\":{\"99\":1}}],[\"存储新值\",{\"1\":{\"77\":1}}],[\"存储操作\",{\"1\":{\"75\":1}}],[\"存储每个线程要执行的任务\",{\"1\":{\"53\":1}}],[\"存储每个线程的结果\",{\"1\":{\"10\":1}}],[\"存储待播放的音频文件路径\",{\"1\":{\"49\":1}}],[\"存储期\",{\"1\":{\"42\":1,\"43\":1}}],[\"存储关联线程的线程对象\",{\"1\":{\"10\":1,\"53\":1}}],[\"换句话说\",{\"1\":{\"36\":1}}],[\"换行并刷新\",{\"1\":{\"9\":1}}],[\"起则为\",{\"1\":{\"83\":1}}],[\"起码用着方便\",{\"1\":{\"75\":1}}],[\"起\",{\"1\":{\"36\":1,\"75\":2}}],[\"全部搞明白了继承关系\",{\"1\":{\"110\":1}}],[\"全部初始化为\",{\"1\":{\"95\":1}}],[\"全局二元信号量对象\",{\"1\":{\"68\":1}}],[\"全局状态\",{\"1\":{\"45\":1}}],[\"全局变量适合整个程序的共享状态\",{\"1\":{\"44\":1}}],[\"全局变量\",{\"0\":{\"42\":1},\"1\":{\"40\":1}}],[\"全局的\",{\"1\":{\"36\":1}}],[\"全局\",{\"1\":{\"36\":1}}],[\"全是\",{\"1\":{\"25\":1}}],[\"运算符\",{\"1\":{\"36\":1}}],[\"运算符的库函数实际是线程安全的\",{\"1\":{\"45\":1}}],[\"运算符的库版本\",{\"1\":{\"36\":2}}],[\"运算符的用户替换版本\",{\"1\":{\"36\":1}}],[\"运算符和\",{\"1\":{\"36\":2}}],[\"运行时库的环境\",{\"1\":{\"100\":1}}],[\"运行时库资源\",{\"1\":{\"100\":1}}],[\"运行时库\",{\"1\":{\"100\":1}}],[\"运行也难以发现\",{\"1\":{\"81\":1}}],[\"运行结果\",{\"1\":{\"15\":1,\"37\":1,\"54\":2,\"68\":1,\"70\":1}}],[\"运行代码\",{\"1\":{\"14\":2}}],[\"运行测试\",{\"1\":{\"10\":2,\"14\":1,\"18\":2,\"21\":1,\"35\":2,\"37\":2,\"47\":1,\"52\":4,\"53\":4,\"54\":1,\"55\":1,\"60\":2,\"68\":1,\"70\":1,\"71\":1,\"75\":3,\"76\":1,\"77\":2,\"79\":1,\"103\":1,\"114\":2,\"116\":1}}],[\"帮助理解与记忆\",{\"1\":{\"114\":1}}],[\"帮助我们完成这件事情\",{\"1\":{\"103\":1}}],[\"帮助我们进行遍历元组即可\",{\"1\":{\"99\":1}}],[\"帮助写出\",{\"1\":{\"30\":1}}],[\"帮我们管理\",{\"1\":{\"35\":1}}],[\"递归锁\",{\"1\":{\"45\":1}}],[\"递归调用\",{\"1\":{\"35\":1}}],[\"递归函数\",{\"1\":{\"35\":1}}],[\"规则\",{\"1\":{\"34\":1}}],[\"符合语义和设计\",{\"1\":{\"33\":1}}],[\"符合零开销原则\",{\"1\":{\"20\":1}}],[\"测试并设置\",{\"1\":{\"76\":1}}],[\"测试\",{\"1\":{\"62\":2,\"64\":2,\"107\":1,\"116\":1}}],[\"测试链接\",{\"1\":{\"33\":1,\"34\":1}}],[\"测试代码\",{\"1\":{\"12\":1,\"13\":1,\"30\":2}}],[\"次参数是里面进行状态判断的而已\",{\"1\":{\"108\":1}}],[\"次调用\",{\"1\":{\"33\":1}}],[\"次都是执行函数\",{\"1\":{\"27\":1}}],[\"第三步进行了修改\",{\"1\":{\"79\":1}}],[\"第三种方式\",{\"1\":{\"47\":1}}],[\"第四章中提到\",{\"1\":{\"79\":1}}],[\"第一轮每个数字最后一位都是\",{\"1\":{\"71\":1}}],[\"第一个模板参数用来指定使用的时钟\",{\"1\":{\"60\":1}}],[\"第一个线程等待结果并访问数据\",{\"1\":{\"56\":1}}],[\"第一个调用\",{\"1\":{\"26\":1}}],[\"第一个功能很简单\",{\"1\":{\"21\":1}}],[\"第10轮结束\",{\"1\":{\"71\":1}}],[\"第1轮结束\",{\"1\":{\"71\":1}}],[\"第9轮结束\",{\"1\":{\"71\":1}}],[\"第8轮结束\",{\"1\":{\"71\":1}}],[\"第7轮结束\",{\"1\":{\"71\":1}}],[\"第6轮结束\",{\"1\":{\"71\":1}}],[\"第5轮结束\",{\"1\":{\"71\":1}}],[\"第4轮结束\",{\"1\":{\"71\":1}}],[\"第3轮结束\",{\"1\":{\"71\":1}}],[\"第2轮结束\",{\"1\":{\"71\":1}}],[\"第二步就获取了被保护的数据的引用\",{\"1\":{\"79\":1}}],[\"第二轮每个数字最后一位都是\",{\"1\":{\"71\":1}}],[\"第二个线程调用\",{\"1\":{\"77\":1}}],[\"第二个线程等待结果并访问数据\",{\"1\":{\"56\":1}}],[\"第二个模板参数用来表示时间单位\",{\"1\":{\"60\":1}}],[\"第二个参数就是先前提到的\",{\"1\":{\"59\":1}}],[\"第二个版本只是对第一个版本的包装\",{\"1\":{\"47\":1}}],[\"第二种方法就是加个延时\",{\"1\":{\"47\":1}}],[\"第\",{\"1\":{\"33\":1}}],[\"比较和复制是逐位的\",{\"1\":{\"90\":1}}],[\"比较\",{\"1\":{\"77\":1}}],[\"比自旋好的多\",{\"1\":{\"76\":1}}],[\"比显式使用互斥量消耗的资源更少\",{\"1\":{\"33\":1}}],[\"比起锁住互斥量并显式检查指针\",{\"1\":{\"33\":1}}],[\"比如控制任务优先级\",{\"1\":{\"116\":1}}],[\"比如在后续聊\",{\"1\":{\"107\":1}}],[\"比如第二章的并行求和\",{\"1\":{\"72\":1}}],[\"比如到\",{\"1\":{\"57\":1}}],[\"比如抛出异常\",{\"1\":{\"57\":1}}],[\"比如学习现代\",{\"1\":{\"51\":1}}],[\"比如领导看到了人家的设备跑起来总是有一些播报\",{\"1\":{\"49\":1}}],[\"比如手机的地图\",{\"1\":{\"47\":1}}],[\"比如我们想要的其实是输出\",{\"1\":{\"59\":1}}],[\"比如我们要讲的互斥量\",{\"1\":{\"45\":1}}],[\"比如我的\",{\"1\":{\"10\":1}}],[\"比如互斥量或原子操作\",{\"1\":{\"36\":1}}],[\"比如异常\",{\"1\":{\"33\":1}}],[\"比如对于共享数据的初始化过程的保护\",{\"1\":{\"33\":1}}],[\"比如当函数返回std\",{\"1\":{\"32\":1}}],[\"比如前面提到的\",{\"1\":{\"32\":1}}],[\"比如保护共享数据中的\",{\"1\":{\"30\":1}}],[\"比如一个遥控汽车\",{\"1\":{\"30\":1}}],[\"比如这段代码就是典型的恶性条件竞争\",{\"1\":{\"25\":1}}],[\"比如两个线程都要往标准输出输出一段字符\",{\"1\":{\"25\":1}}],[\"比如函数结束\",{\"1\":{\"12\":1}}],[\"比如重载了\",{\"1\":{\"12\":1}}],[\"比如\",{\"1\":{\"10\":2,\"25\":1,\"30\":1,\"57\":1,\"58\":1,\"59\":1,\"75\":1,\"110\":1}}],[\"④\",{\"1\":{\"33\":1}}],[\"①\",{\"1\":{\"33\":1}}],[\"错误难以被我们观察到的原因其实可以简单的说\",{\"1\":{\"81\":1}}],[\"错误\",{\"1\":{\"33\":2,\"99\":1}}],[\"双检锁\",{\"1\":{\"33\":2}}],[\"举一个简单的调用例子\",{\"1\":{\"103\":1}}],[\"举一个使用\",{\"1\":{\"32\":1}}],[\"举个例子\",{\"1\":{\"10\":1,\"12\":1,\"51\":1}}],[\"除了直接使用\",{\"1\":{\"75\":1}}],[\"除了析构函数外的成员函数不会引起数据竞争\",{\"1\":{\"71\":1}}],[\"除了\",{\"1\":{\"50\":1,\"54\":1}}],[\"除了类成员或函数形参\",{\"1\":{\"32\":1}}],[\"除非通过\",{\"1\":{\"79\":1}}],[\"除非你真的知道自己在做什么\",{\"1\":{\"76\":1}}],[\"除非它被零初始化或常量初始化\",{\"1\":{\"43\":1}}],[\"除非我们写成\",{\"1\":{\"31\":1}}],[\"除非其中一个孩子决定让另一个先玩\",{\"1\":{\"30\":1}}],[\"除非\",{\"1\":{\"25\":1}}],[\"除非给参数\",{\"1\":{\"14\":1}}],[\"说白了\",{\"1\":{\"107\":1}}],[\"说明\",{\"1\":{\"62\":1}}],[\"说明当前的情况\",{\"1\":{\"49\":1}}],[\"说明符只能搭配变量声明和函数声明\",{\"1\":{\"32\":1}}],[\"说实话挺麻烦的\",{\"1\":{\"15\":1}}],[\"切勿被词语迷惑\",{\"1\":{\"32\":1}}],[\"切勿将受保护数据的指针或引用传递到互斥量作用域之外\",{\"1\":{\"29\":1,\"79\":1}}],[\"原始版本的\",{\"1\":{\"115\":1}}],[\"原子标志位\",{\"1\":{\"116\":1}}],[\"原子模板\",{\"1\":{\"79\":1}}],[\"原子的替换当前对象的值\",{\"1\":{\"77\":1}}],[\"原子类型也有类似的问题\",{\"1\":{\"79\":1}}],[\"原子类型的所有操作都是原子的\",{\"1\":{\"76\":1}}],[\"原子类型的每个操作函数\",{\"1\":{\"75\":1}}],[\"原子类型\",{\"0\":{\"75\":1}}],[\"原子类型在我们第五章的内容会详细展开\",{\"1\":{\"72\":1}}],[\"原子操作可以在一些时候代替互斥量\",{\"1\":{\"75\":1}}],[\"原子操作\",{\"0\":{\"74\":1}}],[\"原子操作即不可分割的操作\",{\"1\":{\"73\":1}}],[\"原子地赋\",{\"1\":{\"79\":1}}],[\"原子地返回底层共享指针的副本std\",{\"1\":{\"79\":1}}],[\"原子地替换所保有的值\",{\"1\":{\"79\":1}}],[\"原子地将期待计数减少\",{\"1\":{\"71\":1}}],[\"原子地增加计数\",{\"1\":{\"68\":1}}],[\"原子地减少计数\",{\"1\":{\"68\":1}}],[\"原来的\",{\"1\":{\"56\":1}}],[\"原来的置空\",{\"1\":{\"32\":1}}],[\"原因很简单\",{\"1\":{\"31\":1}}],[\"请再次尝试\",{\"1\":{\"99\":1}}],[\"请注意\",{\"1\":{\"76\":1}}],[\"请求\",{\"1\":{\"68\":1}}],[\"请求到达\",{\"1\":{\"68\":1}}],[\"请求线程停止\",{\"1\":{\"21\":2}}],[\"请及时清空\",{\"1\":{\"50\":2}}],[\"请更新\",{\"1\":{\"50\":1}}],[\"请添加\",{\"1\":{\"50\":5}}],[\"请无视我们省略的构造\",{\"1\":{\"48\":1}}],[\"请勿对移动语义和转移所有权抱有错误的幻想\",{\"1\":{\"32\":1}}],[\"环境也就是\",{\"1\":{\"31\":1}}],[\"内容并不构成太大的难度\",{\"1\":{\"117\":1}}],[\"内部使用到了互斥量\",{\"1\":{\"110\":1}}],[\"内部其实也有父类指针指向子类对象\",{\"1\":{\"110\":1}}],[\"内部会将保有的参数副本转换为右值表达式进行传递\",{\"1\":{\"14\":1,\"17\":1,\"52\":1,\"100\":1}}],[\"内核版本历史\",{\"1\":{\"45\":1}}],[\"内核中的时间间隔计时器默认每隔\",{\"1\":{\"60\":1}}],[\"内核中\",{\"1\":{\"39\":2}}],[\"内存池\",{\"1\":{\"112\":1}}],[\"内存一致性模型\",{\"1\":{\"85\":1}}],[\"内存次序错误的使用难以察觉\",{\"1\":{\"81\":1}}],[\"内存次序是非常底层知识\",{\"1\":{\"81\":1}}],[\"内存次序\",{\"0\":{\"80\":1}}],[\"内存序提供了操作之间的顺序关系\",{\"1\":{\"82\":1}}],[\"内存序\",{\"1\":{\"76\":2}}],[\"内存模型是软件与实现之间的一种约定契约\",{\"1\":{\"85\":1}}],[\"内存模型确保程序的行为在并发环境下是可预测的\",{\"1\":{\"73\":1}}],[\"内存模型定义了多线程程序中\",{\"1\":{\"73\":1}}],[\"内存模型与原子操作\",{\"0\":{\"73\":1},\"1\":{\"72\":1}}],[\"内存分配\",{\"1\":{\"36\":1}}],[\"内存对齐\",{\"1\":{\"31\":1}}],[\"很明显\",{\"1\":{\"107\":1}}],[\"很早之前就不支持\",{\"1\":{\"97\":1,\"106\":1}}],[\"很显然\",{\"1\":{\"79\":1}}],[\"很多时候这并不是我们想要的\",{\"1\":{\"59\":1}}],[\"很简单\",{\"1\":{\"31\":1,\"107\":1,\"108\":1}}],[\"很诡异的设计对吧\",{\"1\":{\"31\":1}}],[\"别的标准库也都有类似设计\",{\"1\":{\"31\":1}}],[\"设为\",{\"1\":{\"77\":2}}],[\"设计挺奇怪的对吧\",{\"1\":{\"31\":1}}],[\"设置最大线程数量\",{\"1\":{\"116\":1}}],[\"设置对象初始计数为\",{\"1\":{\"68\":1}}],[\"设置窗口布局为垂直布局管理器\",{\"1\":{\"64\":1}}],[\"设置布局\",{\"1\":{\"64\":1}}],[\"设置进度条文本字体\",{\"1\":{\"64\":1}}],[\"设置每个进度块的宽度\",{\"1\":{\"64\":1}}],[\"设置时钟精度为\",{\"1\":{\"60\":1}}],[\"设置时区麻烦\",{\"1\":{\"15\":1}}],[\"设置值\",{\"1\":{\"54\":1}}],[\"设置\",{\"1\":{\"47\":1,\"76\":2}}],[\"设置了一个标志位\",{\"1\":{\"47\":1}}],[\"设置条件变量为\",{\"1\":{\"47\":1}}],[\"设置为\",{\"1\":{\"31\":3,\"77\":2,\"114\":1}}],[\"设置取消点\",{\"1\":{\"23\":1}}],[\"设置要等待的时间点为当前时间点之后的5秒\",{\"1\":{\"15\":1}}],[\"了解它们提供的功能\",{\"1\":{\"113\":1}}],[\"了解以上这些基础概念是第一步也是最后一步\",{\"1\":{\"112\":1}}],[\"了解一个庞大的类\",{\"1\":{\"98\":1,\"107\":1}}],[\"了解底层硬件架构的内存模型对扩展知识面和深入理解编程细节也非常有帮助\",{\"1\":{\"85\":1}}],[\"了解内存次序并非硬性需求\",{\"1\":{\"81\":1}}],[\"了解基本构成\",{\"1\":{\"58\":1}}],[\"了解其它\",{\"1\":{\"37\":1}}],[\"了解其实现\",{\"1\":{\"17\":1}}],[\"了\",{\"1\":{\"31\":2,\"56\":1,\"66\":1,\"97\":1,\"100\":1,\"106\":1}}],[\"尤其它还可以与我们下一章要讲的条件变量一起使用\",{\"1\":{\"31\":1}}],[\"尤其是某些说法准确性也一般\",{\"1\":{\"7\":1}}],[\"灵活的锁\",{\"0\":{\"31\":1}}],[\"固定的顺序上锁就不存在问题\",{\"1\":{\"30\":1}}],[\"约束开发者的行为\",{\"1\":{\"30\":1}}],[\"程序能通过编译即代表满足要求\",{\"1\":{\"75\":1}}],[\"程序都能正常完成工作\",{\"1\":{\"30\":1}}],[\"程序老老实实执行完毕\",{\"1\":{\"25\":1}}],[\"甚至包括非\",{\"1\":{\"90\":1}}],[\"甚至不能当普通的\",{\"1\":{\"76\":1}}],[\"甚至估算错误导致坐过站\",{\"1\":{\"47\":1}}],[\"甚至难以复现\",{\"1\":{\"30\":1}}],[\"甚至深入阅读了部分的\",{\"1\":{\"24\":1}}],[\"新增了三个用作协程的关键字\",{\"1\":{\"92\":1}}],[\"新增了\",{\"1\":{\"30\":1}}],[\"哪个都没办法往下执行\",{\"1\":{\"30\":1}}],[\"往下执行需要上锁\",{\"1\":{\"30\":1}}],[\"完成转移状态\",{\"1\":{\"107\":1}}],[\"完成递增操作之前\",{\"1\":{\"74\":1}}],[\"完成并退出\",{\"1\":{\"71\":1}}],[\"完成阶段会重置计数为\",{\"1\":{\"71\":1}}],[\"完成阶段重置计数也是\",{\"1\":{\"71\":1}}],[\"完成前不开始\",{\"1\":{\"52\":1}}],[\"完成播放任务\",{\"1\":{\"49\":1}}],[\"完全独立\",{\"1\":{\"41\":1}}],[\"完全可能线程\",{\"1\":{\"30\":1}}],[\"完整代码实现\",{\"0\":{\"64\":1}}],[\"完整代码\",{\"1\":{\"34\":1}}],[\"完整代码测试\",{\"1\":{\"27\":1}}],[\"🐉🐉🐉\",{\"1\":{\"116\":10}}],[\"🐢🐢🐢\",{\"1\":{\"116\":10}}],[\"🐢🐢🐢🐢🐢\",{\"1\":{\"115\":1}}],[\"😅😅\",{\"1\":{\"76\":1}}],[\"😅\",{\"1\":{\"30\":1,\"103\":1}}],[\"😢\",{\"1\":{\"25\":1}}],[\"🤣🤣\",{\"1\":{\"32\":1}}],[\"🤣\",{\"1\":{\"30\":1}}],[\"考虑用户调用的时候将参数交换\",{\"1\":{\"30\":1}}],[\"依赖于\",{\"1\":{\"50\":1,\"115\":1}}],[\"依然会产生数据竞争\",{\"1\":{\"45\":1}}],[\"依然实际是复制\",{\"1\":{\"14\":1}}],[\"依旧会产生问题\",{\"1\":{\"30\":1}}],[\"要符合\",{\"1\":{\"99\":1}}],[\"要注意的是\",{\"1\":{\"37\":1}}],[\"要求\",{\"1\":{\"75\":1}}],[\"要求其函数对象类型必须是不抛出异常的\",{\"1\":{\"71\":1}}],[\"要求的锁上工作\",{\"1\":{\"47\":1}}],[\"要求下列函数是线程安全的\",{\"1\":{\"36\":1}}],[\"要求构造函数之前和构造函数之后都不能再次上锁\",{\"1\":{\"31\":1}}],[\"要求构造之后上锁\",{\"1\":{\"31\":1}}],[\"要求在构造之前互斥量上锁\",{\"1\":{\"31\":1}}],[\"要想调用\",{\"1\":{\"31\":1}}],[\"要么一个都不锁\",{\"1\":{\"30\":1}}],[\"要么将互斥量都上锁\",{\"1\":{\"30\":1}}],[\"要往下执行\",{\"1\":{\"30\":1}}],[\"要走\",{\"1\":{\"28\":1}}],[\"总体而言\",{\"1\":{\"117\":1}}],[\"总音频数量\",{\"1\":{\"50\":1}}],[\"总而言之这行代码通过调用\",{\"1\":{\"107\":1}}],[\"总而言之\",{\"1\":{\"36\":1,\"44\":1}}],[\"总而言之就是\",{\"1\":{\"35\":1}}],[\"总在互斥量\",{\"1\":{\"30\":1}}],[\"总结\",{\"0\":{\"7\":1,\"23\":1,\"72\":1,\"96\":1,\"100\":1,\"104\":1,\"110\":1,\"117\":1},\"1\":{\"82\":1}}],[\"问题取决于程序和系统的具体实现\",{\"1\":{\"47\":1}}],[\"问题就出现了\",{\"1\":{\"30\":1}}],[\"问题与解决\",{\"0\":{\"30\":1}}],[\"遥控器和玩具车被放在两个不同的地方\",{\"1\":{\"30\":1}}],[\"他并没有\",{\"1\":{\"99\":1}}],[\"他把自己的那个部分给另一个小孩\",{\"1\":{\"30\":1}}],[\"他就得等待另一个小孩玩完才行\",{\"1\":{\"30\":1}}],[\"他们都想玩这个玩具\",{\"1\":{\"30\":1}}],[\"试想一下\",{\"1\":{\"30\":1,\"34\":1}}],[\"死锁是多线程编程中令人相当头疼的问题\",{\"1\":{\"30\":1}}],[\"死锁\",{\"0\":{\"30\":1},\"1\":{\"30\":1,\"45\":1}}],[\"受保护的数据被传递到外部\",{\"1\":{\"29\":1}}],[\"受保护数据传递给函数\",{\"1\":{\"29\":1}}],[\"修改内部的标志位存在使得线程池能够识别何时需要停止接收新的任务\",{\"1\":{\"114\":1}}],[\"修改状态\",{\"1\":{\"107\":1}}],[\"修改指针\",{\"1\":{\"36\":1}}],[\"修改\",{\"1\":{\"30\":1,\"79\":1}}],[\"修改数据成员等\",{\"1\":{\"29\":1}}],[\"修改的\",{\"1\":{\"27\":1}}],[\"释放资源\",{\"1\":{\"114\":2}}],[\"释放独占指针的所有权\",{\"1\":{\"99\":1}}],[\"释放\",{\"0\":{\"87\":1,\"88\":1},\"1\":{\"47\":1,\"68\":3}}],[\"释放操作是线程安全\",{\"1\":{\"36\":1}}],[\"释放锁\",{\"1\":{\"28\":2}}],[\"释放所有获取的资源并执行其它必要的清理操作\",{\"1\":{\"12\":1}}],[\"模式创建的任务\",{\"1\":{\"109\":1}}],[\"模式的任务\",{\"1\":{\"108\":1}}],[\"模式\",{\"1\":{\"97\":1,\"106\":1,\"108\":1}}],[\"模块化且开放的指令集\",{\"1\":{\"85\":1}}],[\"模拟\",{\"1\":{\"68\":1}}],[\"模拟处理时间\",{\"1\":{\"68\":1}}],[\"模拟耗时操作\",{\"1\":{\"56\":2}}],[\"模拟一些计算\",{\"1\":{\"54\":1}}],[\"模拟地铁到站\",{\"1\":{\"47\":2}}],[\"模拟临界区操作\",{\"1\":{\"28\":1}}],[\"模板类负责管理异步任务的状态\",{\"1\":{\"107\":1}}],[\"模板类的作用和工作方式\",{\"1\":{\"107\":1}}],[\"模板参数和函数体外部信息\",{\"1\":{\"107\":1}}],[\"模板的知识必不可少\",{\"1\":{\"93\":1}}],[\"模板外\",{\"1\":{\"75\":1}}],[\"模板教程\",{\"1\":{\"51\":1}}],[\"模板\",{\"1\":{\"27\":1,\"75\":1}}],[\"临时量的析构函数等待\",{\"1\":{\"52\":1}}],[\"临时对象初始化\",{\"1\":{\"16\":1}}],[\"临时对象是右值表达式\",{\"1\":{\"16\":2}}],[\"临界区\",{\"1\":{\"45\":1}}],[\"临界区代码\",{\"1\":{\"28\":1}}],[\"获得信号\",{\"1\":{\"68\":4}}],[\"获得的\",{\"1\":{\"52\":1}}],[\"获得锁\",{\"1\":{\"28\":2}}],[\"获取返回值\",{\"1\":{\"116\":2}}],[\"获取对象实例\",{\"1\":{\"115\":1}}],[\"获取到我们执行任务的值的\",{\"1\":{\"109\":1}}],[\"获取值并返回\",{\"1\":{\"108\":1}}],[\"获取可调用对象的返回类型\",{\"1\":{\"107\":1}}],[\"获取元组存储的数据\",{\"1\":{\"99\":1}}],[\"获取它的函数指针\",{\"1\":{\"99\":1}}],[\"获取定序\",{\"0\":{\"87\":1}}],[\"获取底层共享指针的副本\",{\"1\":{\"79\":1}}],[\"获取当前时间\",{\"1\":{\"60\":1}}],[\"获取当前时间点\",{\"1\":{\"15\":1}}],[\"获取\",{\"1\":{\"54\":2,\"58\":1,\"77\":1}}],[\"获取任务的返回值加起来即可\",{\"1\":{\"53\":1}}],[\"获取任务返回值罢了\",{\"1\":{\"53\":1}}],[\"获取访问权\",{\"1\":{\"34\":1}}],[\"获取锁失败\",{\"1\":{\"28\":2}}],[\"获取的值自然也会是\",{\"1\":{\"10\":1}}],[\"特有的\",{\"1\":{\"76\":1}}],[\"特定的时间点则可以通过\",{\"1\":{\"58\":1}}],[\"特别是当初始化完成之后\",{\"1\":{\"33\":1}}],[\"特别是在需要保护临界区的同时\",{\"1\":{\"28\":1}}],[\"特性\",{\"1\":{\"20\":1}}],[\"添加更多的功能\",{\"1\":{\"116\":1}}],[\"添加了一个新的特性\",{\"1\":{\"27\":1}}],[\"添加元素\",{\"1\":{\"25\":1}}],[\"给被引用的对象\",{\"1\":{\"79\":1}}],[\"给两个互斥量上锁\",{\"1\":{\"30\":1}}],[\"给\",{\"1\":{\"30\":2}}],[\"给整个函数上锁\",{\"1\":{\"27\":1}}],[\"给互斥量上锁\",{\"1\":{\"26\":1,\"27\":1}}],[\"避免数据竞争\",{\"1\":{\"116\":1}}],[\"避免数据竞争和并发问题\",{\"1\":{\"78\":1}}],[\"避免虚假唤醒\",{\"1\":{\"108\":1}}],[\"避免歧义和许多问题\",{\"1\":{\"95\":1}}],[\"避免了运行时的判断开销\",{\"1\":{\"75\":1}}],[\"避免了数据竞争问题\",{\"1\":{\"74\":1}}],[\"避免了数据竞争\",{\"1\":{\"27\":1,\"39\":1}}],[\"避免除数据竞争\",{\"1\":{\"71\":1}}],[\"避免占用\",{\"1\":{\"49\":1}}],[\"避免忙等占用\",{\"1\":{\"49\":1}}],[\"避免另一线程在第一次检查后再做初始化\",{\"1\":{\"33\":1}}],[\"避免在持有锁时调用外部代码\",{\"1\":{\"30\":1}}],[\"避免嵌套锁\",{\"1\":{\"30\":1}}],[\"避免死锁的一般建议是让两个互斥量以相同的顺序上锁\",{\"1\":{\"30\":1}}],[\"避免程序被抛出的异常所终止\",{\"1\":{\"12\":1}}],[\"成为一种单次使用的屏障\",{\"1\":{\"70\":1}}],[\"成功时的内存序为\",{\"1\":{\"77\":1}}],[\"成功获取锁\",{\"1\":{\"76\":1}}],[\"成功获取信号量\",{\"1\":{\"68\":2}}],[\"成功链接上\",{\"1\":{\"32\":1}}],[\"成功调用\",{\"1\":{\"27\":1}}],[\"成员就是保有线程的\",{\"1\":{\"98\":1}}],[\"成员是指向线程的句柄\",{\"1\":{\"98\":1}}],[\"成员函数在传递参数的行为上\",{\"1\":{\"116\":1}}],[\"成员函数实现中\",{\"1\":{\"110\":1}}],[\"成员函数确保任务执行完毕\",{\"1\":{\"108\":1}}],[\"成员函数自然那也有三个版本\",{\"1\":{\"108\":1}}],[\"成员函数开始即可\",{\"1\":{\"108\":1}}],[\"成员函数返回的是底层\",{\"1\":{\"79\":1}}],[\"成员函数原子地返回底层的\",{\"1\":{\"79\":1}}],[\"成员函数获取底层指针\",{\"1\":{\"99\":1}}],[\"成员函数获取这个值\",{\"1\":{\"54\":1}}],[\"成员函数获得计次数\",{\"1\":{\"59\":1}}],[\"成员函数一样有两个重载\",{\"1\":{\"57\":1}}],[\"成员函数一样可以用来构造\",{\"1\":{\"56\":1}}],[\"成员函数只能调用一次\",{\"1\":{\"56\":1}}],[\"成员函数时被置为\",{\"1\":{\"107\":1}}],[\"成员函数时\",{\"1\":{\"55\":1}}],[\"成员函数检查\",{\"1\":{\"52\":1}}],[\"成员函数有两个版本\",{\"1\":{\"47\":1}}],[\"成员函数即可\",{\"1\":{\"32\":1}}],[\"成员函数\",{\"1\":{\"31\":2,\"52\":2,\"54\":1,\"56\":1,\"72\":1,\"75\":1,\"79\":8,\"107\":2,\"108\":3,\"114\":1,\"115\":1,\"116\":2}}],[\"成员函数的实现\",{\"1\":{\"55\":1}}],[\"成员函数的时候已经讲完了\",{\"1\":{\"109\":1}}],[\"成员函数的时候就会讲到\",{\"1\":{\"107\":1}}],[\"成员函数的时候执行任务\",{\"1\":{\"52\":1}}],[\"成员函数的时候\",{\"1\":{\"31\":1}}],[\"成员函数的代码\",{\"1\":{\"31\":1}}],[\"成员函数的\",{\"1\":{\"31\":1}}],[\"成员函数模板\",{\"1\":{\"29\":1}}],[\"成员函数指针也是可调用\",{\"1\":{\"14\":1}}],[\"成员指针不可以转换到函数指针单独使用\",{\"1\":{\"14\":1}}],[\"成员指针必须和对象一起使用\",{\"1\":{\"14\":1}}],[\"希望各位开发者不要搞晕了\",{\"1\":{\"108\":1}}],[\"希望您拥有\",{\"1\":{\"92\":1}}],[\"希望您是已经较为熟练使用模板\",{\"1\":{\"0\":1}}],[\"希望大家分清楚\",{\"1\":{\"27\":1}}],[\"包含复制构造函数与复制赋值\",{\"1\":{\"72\":1,\"79\":1}}],[\"包含以下功能\",{\"1\":{\"49\":1}}],[\"包含在其中的代码是线程安全的\",{\"1\":{\"26\":1}}],[\"包括获取任务的结果或异常\",{\"1\":{\"107\":1}}],[\"包括获取锁\",{\"1\":{\"30\":1}}],[\"包括结果的存储\",{\"1\":{\"107\":1}}],[\"包括但不限于\",{\"1\":{\"94\":1}}],[\"包括条件变量\",{\"1\":{\"72\":1}}],[\"包括支持使用\",{\"1\":{\"52\":1}}],[\"包括虚假唤醒\",{\"1\":{\"47\":1}}],[\"包括管理互斥量的管理类\",{\"1\":{\"45\":1}}],[\"包装任何可调用\",{\"1\":{\"53\":1}}],[\"包装\",{\"1\":{\"30\":1,\"53\":1}}],[\"包起来了\",{\"1\":{\"27\":1}}],[\"涉及被管理对象的\",{\"1\":{\"79\":1}}],[\"涉及读写共享资源\",{\"1\":{\"36\":1}}],[\"涉及到了对共享数据的修改\",{\"1\":{\"27\":1}}],[\"涉及共享资源的修改的代码\",{\"1\":{\"27\":1,\"31\":1}}],[\"较为严格的内存模型\",{\"1\":{\"94\":1}}],[\"较小的粒度意味着锁定的范围更小\",{\"1\":{\"27\":1}}],[\"较少\",{\"1\":{\"15\":1}}],[\"粒度\",{\"1\":{\"27\":1,\"45\":1}}],[\"离开作用域析构的时候解锁\",{\"1\":{\"27\":1}}],[\"式的管理\",{\"1\":{\"27\":1}}],[\"首先确定它的数据成员\",{\"1\":{\"116\":1}}],[\"首先是没有必要\",{\"1\":{\"110\":1}}],[\"首先需要了解\",{\"1\":{\"79\":1}}],[\"首先我们要明白\",{\"1\":{\"32\":1}}],[\"首先\",{\"1\":{\"31\":1}}],[\"首先管理类\",{\"1\":{\"27\":1}}],[\"首先顾名思义\",{\"1\":{\"27\":1}}],[\"首先要明确\",{\"1\":{\"21\":1}}],[\"简短的代码可以不额外占行\",{\"1\":{\"95\":1}}],[\"简化了多线程编程中的内存同步问题\",{\"1\":{\"85\":1}}],[\"简而言之\",{\"1\":{\"26\":1,\"29\":1,\"30\":1,\"31\":1,\"33\":1,\"52\":1,\"53\":1,\"54\":1,\"107\":1,\"112\":1}}],[\"简单来说是\",{\"1\":{\"103\":1}}],[\"简单来说也就是\",{\"1\":{\"20\":1}}],[\"简单使用一下\",{\"1\":{\"18\":1}}],[\"简单直观\",{\"1\":{\"15\":1}}],[\"简单的说就是不一定会调用析构\",{\"1\":{\"13\":1}}],[\"简单的说是\",{\"1\":{\"13\":1}}],[\"简单的测试运行的确没问题\",{\"1\":{\"12\":1}}],[\"简单点说\",{\"1\":{\"12\":1}}],[\"简单\",{\"1\":{\"0\":1}}],[\"直至提醒者通过调用\",{\"1\":{\"68\":1}}],[\"直至获得锁\",{\"1\":{\"26\":1}}],[\"直到池中的线程完成任务\",{\"1\":{\"114\":1}}],[\"直到有新的任务到来\",{\"1\":{\"112\":1}}],[\"直到先前持有锁的线程调用\",{\"1\":{\"76\":1}}],[\"直到主线程调用\",{\"1\":{\"70\":1}}],[\"直到\",{\"1\":{\"70\":1}}],[\"直到计数大于\",{\"1\":{\"68\":1}}],[\"直到对应的事件发生\",{\"1\":{\"57\":1}}],[\"直到被设置为止\",{\"1\":{\"54\":1}}],[\"直到结果可用\",{\"1\":{\"54\":1}}],[\"直到到异步任务完成\",{\"1\":{\"52\":1}}],[\"直到条件被满足\",{\"1\":{\"47\":1}}],[\"直到条件满足时被唤醒\",{\"1\":{\"47\":1}}],[\"直到线程执行\",{\"1\":{\"26\":1}}],[\"直接修改这个引用所指向的资源\",{\"1\":{\"79\":1}}],[\"直接改成\",{\"1\":{\"75\":1}}],[\"直接使用\",{\"1\":{\"71\":1}}],[\"直接执行了\",{\"1\":{\"33\":1}}],[\"直接创建临时对象即可\",{\"1\":{\"12\":1}}],[\"状态检查\",{\"1\":{\"109\":1}}],[\"状态转移到\",{\"1\":{\"107\":1}}],[\"状态成员用于跟踪\",{\"1\":{\"107\":1}}],[\"状态\",{\"1\":{\"26\":2,\"59\":1,\"76\":4}}],[\"锁定了\",{\"1\":{\"30\":2}}],[\"锁\",{\"1\":{\"26\":1,\"47\":1}}],[\"未指明\",{\"1\":{\"83\":1}}],[\"未指定\",{\"1\":{\"71\":1,\"75\":11}}],[\"未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步\",{\"1\":{\"33\":1}}],[\"未定义行为\",{\"1\":{\"25\":2}}],[\"未发布\",{\"1\":{\"21\":1}}],[\"标头依赖\",{\"1\":{\"116\":1}}],[\"标记结果已被检索\",{\"1\":{\"109\":1}}],[\"标志那样使用\",{\"1\":{\"76\":1}}],[\"标志位\",{\"1\":{\"26\":1}}],[\"标准并发库\",{\"1\":{\"93\":1}}],[\"标准内存模型\",{\"1\":{\"85\":1}}],[\"标准为我们定义了\",{\"1\":{\"85\":1}}],[\"标准通过内存序\",{\"1\":{\"82\":1}}],[\"标准中的可见\",{\"1\":{\"82\":1}}],[\"标准原子类型的实现通常包括一个\",{\"1\":{\"75\":1}}],[\"标准原子类型定义在头文件\",{\"1\":{\"75\":1}}],[\"标准\",{\"1\":{\"50\":1}}],[\"标准的内存模型来确保线程之间的数据一致性\",{\"1\":{\"82\":1}}],[\"标准的\",{\"1\":{\"37\":1}}],[\"标准输出可能交错\",{\"1\":{\"34\":1}}],[\"标准委员会也认为处理此问题很重要\",{\"1\":{\"33\":1}}],[\"标准库设施\",{\"1\":{\"97\":1,\"106\":1}}],[\"标准库还提供了一组宏\",{\"1\":{\"75\":1}}],[\"标准库还提供一个函数\",{\"1\":{\"71\":1}}],[\"标准库对其的支持却来得很晚\",{\"1\":{\"68\":1}}],[\"标准库对条件变量有两套实现\",{\"1\":{\"47\":1}}],[\"标准库增加了时间字面量\",{\"1\":{\"59\":1}}],[\"标准库在\",{\"1\":{\"59\":1}}],[\"标准库通过它定义了很多的时间类型\",{\"1\":{\"58\":1}}],[\"标准库有两种\",{\"1\":{\"51\":1}}],[\"标准库有很多办法解决这个问题\",{\"1\":{\"30\":1}}],[\"标准库将这种事件称为\",{\"1\":{\"51\":1}}],[\"标准库则没有这个烦恼了\",{\"1\":{\"47\":1}}],[\"标准库提供的一种互斥量类型\",{\"1\":{\"35\":1}}],[\"标准库自然为我们提供了\",{\"1\":{\"34\":1}}],[\"标准库引入的\",{\"1\":{\"27\":1}}],[\"标准库进行多线程编程\",{\"1\":{\"23\":1}}],[\"标准库中\",{\"1\":{\"11\":1,\"58\":2}}],[\"标量类型等都同理\",{\"1\":{\"25\":1}}],[\"另一方面\",{\"1\":{\"75\":1}}],[\"另一种是\",{\"1\":{\"57\":1}}],[\"另一种情况就是得显式使用\",{\"1\":{\"32\":1}}],[\"另一个简单的原子类型是特化的原子指针\",{\"1\":{\"77\":1}}],[\"另一个拿到了玩具车\",{\"1\":{\"30\":1}}],[\"另一个\",{\"1\":{\"25\":1}}],[\"另外我们的代码都会测试三大编译器\",{\"1\":{\"94\":1}}],[\"另外我们用的\",{\"1\":{\"59\":1}}],[\"另外你可能注意到我们使用了\",{\"1\":{\"71\":1}}],[\"另外一提\",{\"1\":{\"55\":1}}],[\"另外再聊一聊开销吧\",{\"1\":{\"31\":1}}],[\"另外提示一下\",{\"1\":{\"12\":1}}],[\"见上文\",{\"1\":{\"75\":1}}],[\"见\",{\"1\":{\"25\":2,\"50\":1,\"59\":1,\"71\":1,\"75\":1}}],[\"又是一切的核心\",{\"1\":{\"108\":1}}],[\"又是对\",{\"1\":{\"107\":1}}],[\"又保有一个\",{\"1\":{\"108\":1}}],[\"又不想线程因为等待锁而阻塞的情况下\",{\"1\":{\"28\":1}}],[\"又常被称为互斥锁\",{\"1\":{\"26\":1}}],[\"又去执行另一个线程\",{\"1\":{\"25\":1}}],[\"又或者闹钟没电了睡过站\",{\"1\":{\"47\":1}}],[\"又或者\",{\"1\":{\"25\":1}}],[\"又或者一边看电视一边吃零食\",{\"1\":{\"4\":1}}],[\"等设施基本一致\",{\"1\":{\"116\":1}}],[\"等疾风\",{\"1\":{\"92\":1}}],[\"等价\",{\"1\":{\"79\":1}}],[\"等价于\",{\"1\":{\"58\":1,\"71\":1,\"107\":1}}],[\"等成员函数对\",{\"1\":{\"75\":1}}],[\"等操作方式\",{\"1\":{\"75\":1}}],[\"等操作\",{\"1\":{\"48\":1}}],[\"等标准库设施用作同步操作\",{\"1\":{\"46\":1}}],[\"等\",{\"1\":{\"32\":1,\"60\":1}}],[\"等等\",{\"1\":{\"25\":1}}],[\"等待任务完成\",{\"1\":{\"114\":1}}],[\"等待所有线程完成它们的工作\",{\"1\":{\"114\":1}}],[\"等待所有线程完成\",{\"1\":{\"114\":1}}],[\"等待所有线程执行完毕\",{\"1\":{\"10\":1,\"53\":1}}],[\"等待所有任务执行完成\",{\"1\":{\"114\":1}}],[\"等待调度器的下一次唤醒\",{\"1\":{\"112\":1}}],[\"等待条件变量通知结果已就绪\",{\"1\":{\"109\":1}}],[\"等待条件变量满足条件\",{\"1\":{\"60\":1}}],[\"等待更新唤醒\",{\"1\":{\"79\":1}}],[\"等待的线程中会有一个线程成功调用\",{\"1\":{\"76\":1}}],[\"等待的同时也可以执行其它的任务\",{\"1\":{\"51\":1}}],[\"等待计数为\",{\"1\":{\"70\":1}}],[\"等待其它线程执行\",{\"1\":{\"70\":2}}],[\"等待结果就绪\",{\"1\":{\"109\":1}}],[\"等待结果\",{\"1\":{\"59\":1}}],[\"等待一个\",{\"1\":{\"59\":1}}],[\"等待数据中\",{\"1\":{\"56\":4}}],[\"等待音频播放完毕\",{\"1\":{\"49\":1}}],[\"等待队列中所有音乐播放完毕\",{\"1\":{\"49\":1}}],[\"等待新的任务到来\",{\"1\":{\"49\":1}}],[\"等待并判断谓词\",{\"1\":{\"47\":1}}],[\"等待\",{\"1\":{\"47\":1,\"52\":1,\"68\":3,\"70\":1,\"79\":1,\"108\":1}}],[\"等待事件或条件\",{\"0\":{\"47\":1}}],[\"等待异步任务执行完毕\",{\"1\":{\"52\":1}}],[\"等待异步任务\",{\"1\":{\"46\":1}}],[\"等待线程执行\",{\"1\":{\"54\":4}}],[\"等待线程执行结束\",{\"1\":{\"18\":1}}],[\"等待线程对象\",{\"1\":{\"9\":1}}],[\"等待到指定的时间点\",{\"1\":{\"15\":1}}],[\"恶性的条件竞争\",{\"1\":{\"25\":1}}],[\"才可作为一个整体执行\",{\"1\":{\"72\":1}}],[\"才会考虑\",{\"1\":{\"47\":1}}],[\"才会真正解锁互斥量\",{\"1\":{\"35\":1}}],[\"才会导致\",{\"1\":{\"25\":1}}],[\"才需要获取锁\",{\"1\":{\"33\":1}}],[\"才能继续往下执行\",{\"1\":{\"70\":1}}],[\"才能传递引用\",{\"1\":{\"52\":1}}],[\"才能实际应用多线程编程\",{\"1\":{\"23\":1}}],[\"才能更好的使用它\",{\"1\":{\"17\":1}}],[\"才能调用\",{\"1\":{\"12\":1}}],[\"才能进行真正的并行\",{\"1\":{\"5\":1}}],[\"从性能上看\",{\"1\":{\"76\":1}}],[\"从网络获取的数据\",{\"1\":{\"56\":2}}],[\"从线程池中获取线程并执行任务返回包装对象\",{\"1\":{\"52\":1}}],[\"从队列中取出元素\",{\"1\":{\"49\":1}}],[\"从队列中弹出元素\",{\"1\":{\"48\":2}}],[\"从\",{\"1\":{\"39\":1,\"54\":1}}],[\"从多个线程输出的单独字符可能交错\",{\"1\":{\"25\":1}}],[\"从而结束等待\",{\"1\":{\"108\":1}}],[\"从而创建并返回一个\",{\"1\":{\"107\":1}}],[\"从而避免数据竞争问题\",{\"1\":{\"82\":1}}],[\"从而避免了数据竞争\",{\"1\":{\"79\":1}}],[\"从而避免线程对象析构产生问题\",{\"1\":{\"12\":1}}],[\"从而有效利用系统资源\",{\"1\":{\"76\":1}}],[\"从而解除阻塞\",{\"1\":{\"70\":1}}],[\"从而阻塞尝试\",{\"1\":{\"68\":1}}],[\"从而在其他线程中安全地更新\",{\"1\":{\"62\":1}}],[\"从而允许主线程捕获并处理它\",{\"1\":{\"54\":1}}],[\"从而使得\",{\"1\":{\"47\":1}}],[\"从而造成死锁\",{\"1\":{\"30\":1}}],[\"从而引发未定义的结果\",{\"1\":{\"25\":1}}],[\"从而提升程序性能\",{\"1\":{\"10\":1}}],[\"❤️❤️\",{\"1\":{\"76\":1}}],[\"❤️\",{\"1\":{\"25\":1}}],[\"谁先谁后并不会有什么太大影响\",{\"1\":{\"25\":1}}],[\"保有一个\",{\"1\":{\"102\":2}}],[\"保有一个互斥量的引用\",{\"1\":{\"102\":1}}],[\"保有的数据成员\",{\"1\":{\"31\":1}}],[\"保护共享资源\",{\"1\":{\"49\":1}}],[\"保护共享数据并非必须使用互斥量\",{\"1\":{\"33\":1}}],[\"保护共享数据的初始化过程\",{\"0\":{\"33\":1},\"1\":{\"45\":1}}],[\"保护共享数据的其它方案\",{\"1\":{\"24\":1}}],[\"保护共享数据\",{\"0\":{\"29\":1},\"1\":{\"45\":1}}],[\"保护不常更新的数据结构\",{\"0\":{\"34\":1},\"1\":{\"45\":1}}],[\"保证\",{\"1\":{\"82\":1}}],[\"保证了\",{\"1\":{\"36\":1}}],[\"保证写线程的独占访问\",{\"1\":{\"34\":1}}],[\"保证线程安全的一次初始化\",{\"1\":{\"33\":1}}],[\"保证他们的执行\",{\"1\":{\"18\":1}}],[\"保证这里少一次移动构造的开销\",{\"1\":{\"16\":1}}],[\"注\",{\"1\":{\"23\":2,\"50\":1,\"72\":4,\"90\":2}}],[\"注意输出的规律\",{\"1\":{\"71\":1}}],[\"注意到了吗\",{\"1\":{\"55\":1}}],[\"注意事项\",{\"0\":{\"38\":1,\"65\":1}}],[\"注意\",{\"0\":{\"50\":1},\"1\":{\"14\":1,\"31\":1,\"60\":1,\"99\":1,\"106\":1,\"107\":1}}],[\"↩︎\",{\"1\":{\"23\":3,\"45\":6,\"72\":5,\"90\":2}}],[\"至少有许多的显著的信息\",{\"1\":{\"110\":1}}],[\"至少使用与了解其设计原理是很简单的\",{\"1\":{\"104\":1}}],[\"至少允许\",{\"1\":{\"68\":1}}],[\"至少还需要学习到使用互斥量来保护共享数据\",{\"1\":{\"23\":1}}],[\"至于下面的判断是因为\",{\"1\":{\"114\":1}}],[\"至于下面的循环等待部分\",{\"1\":{\"108\":1}}],[\"至于到底哪个函数哪个线程会先执行\",{\"1\":{\"27\":1}}],[\"至于到底哪个线程才会成功调用\",{\"1\":{\"26\":1}}],[\"至于\",{\"1\":{\"21\":1}}],[\"至于这个函数产生的异常\",{\"1\":{\"12\":1}}],[\"关系图如下\",{\"1\":{\"108\":1}}],[\"关于这个约束你可能有问题\",{\"1\":{\"99\":1}}],[\"关于提示音的播报\",{\"1\":{\"50\":1}}],[\"关注的是线程之间的数据一致性\",{\"1\":{\"82\":1}}],[\"关联\",{\"1\":{\"53\":4}}],[\"关联的执行线程的\",{\"1\":{\"99\":1}}],[\"关联的\",{\"1\":{\"21\":2}}],[\"关联的线程执行完毕\",{\"1\":{\"9\":1}}],[\"关键还在于其存储的数据成员\",{\"1\":{\"107\":1}}],[\"关键字的使用以及它的作用\",{\"1\":{\"37\":1}}],[\"关键字的使用\",{\"1\":{\"37\":1}}],[\"关键在于理解其设计与概念\",{\"1\":{\"22\":1}}],[\"已隐式删除函数\",{\"1\":{\"99\":1}}],[\"已被唤醒\",{\"1\":{\"79\":1}}],[\"已被处理\",{\"1\":{\"68\":1}}],[\"已存储值\",{\"1\":{\"54\":1}}],[\"已包含这些依赖\",{\"1\":{\"50\":1}}],[\"已请求停止\",{\"1\":{\"21\":2}}],[\"已经阅读到这里的各位\",{\"1\":{\"112\":1}}],[\"已经脱离了\",{\"1\":{\"79\":1}}],[\"已经存储值或者异常\",{\"1\":{\"54\":1}}],[\"已经没有关联线程资源\",{\"1\":{\"12\":1}}],[\"已经结束\",{\"1\":{\"12\":1}}],[\"源码中其实已经提到了\",{\"1\":{\"108\":1}}],[\"源码中也有这种用法\",{\"1\":{\"103\":1}}],[\"源码的时候提到了\",{\"1\":{\"108\":1}}],[\"源码的时候\",{\"1\":{\"106\":1}}],[\"源码的实现很简单\",{\"1\":{\"100\":1}}],[\"源码如下\",{\"1\":{\"52\":1}}],[\"源码\",{\"1\":{\"24\":1,\"115\":1}}],[\"源码一眼便可发现\",{\"1\":{\"21\":1}}],[\"源码解析详细聊过其不同标准库对其保有的成员不同\",{\"1\":{\"20\":1}}],[\"源码解析\",{\"0\":{\"97\":1,\"105\":1},\"1\":{\"14\":1,\"17\":1}}],[\"上图是\",{\"1\":{\"107\":1}}],[\"上\",{\"1\":{\"107\":1}}],[\"上实际上就是调用\",{\"1\":{\"100\":1}}],[\"上节我们学习了\",{\"1\":{\"71\":1}}],[\"上面的代码创建了一个异步任务\",{\"1\":{\"62\":1}}],[\"上面这段代码并未出现这三个函数的任何一个调用\",{\"1\":{\"21\":1}}],[\"上需要用户自行下载并安装它们\",{\"1\":{\"50\":1}}],[\"上工作的\",{\"1\":{\"47\":1}}],[\"上锁互斥量\",{\"1\":{\"47\":2}}],[\"上锁时若抛出异常\",{\"1\":{\"30\":1}}],[\"上锁了\",{\"1\":{\"30\":1}}],[\"上锁\",{\"1\":{\"30\":2}}],[\"上一节的使用互斥量也已经为各位展示了一些\",{\"1\":{\"29\":1}}],[\"上亿的话差不多\",{\"1\":{\"10\":1}}],[\"启用不稳定库功能和实验库功能\",{\"1\":{\"21\":1}}],[\"启动耗时的异步任务\",{\"1\":{\"56\":1}}],[\"启动一个线程进行计算\",{\"1\":{\"54\":1}}],[\"启动一个异步任务\",{\"1\":{\"52\":1}}],[\"启动线程池\",{\"1\":{\"116\":1}}],[\"启动线程执行\",{\"1\":{\"53\":1}}],[\"启动线程\",{\"1\":{\"12\":1,\"14\":2,\"16\":2}}],[\"启动线程后\",{\"1\":{\"12\":1}}],[\"启动新线程\",{\"0\":{\"12\":1}}],[\"截止目前\",{\"1\":{\"21\":1}}],[\"提交到\",{\"1\":{\"117\":1}}],[\"提交任务\",{\"1\":{\"114\":2}}],[\"提高系统的吞吐量和响应时间\",{\"1\":{\"75\":1}}],[\"提高了性能\",{\"1\":{\"75\":1}}],[\"提醒而非互斥\",{\"1\":{\"68\":1}}],[\"提升性能\",{\"1\":{\"39\":1}}],[\"提供构造析构函数\",{\"1\":{\"116\":1}}],[\"提供的线程池实现\",{\"1\":{\"115\":1}}],[\"提供的线程池使用十分简单\",{\"1\":{\"114\":1}}],[\"提供的线程停止功能并不同于常见的\",{\"1\":{\"21\":1}}],[\"提供更高级别的接口和功能\",{\"1\":{\"107\":1}}],[\"提供一个额外的构造函数让构造的时候不上锁\",{\"1\":{\"102\":1}}],[\"提供一个外部函数\",{\"1\":{\"49\":1}}],[\"提供多个\",{\"1\":{\"77\":1}}],[\"提供此函数的\",{\"1\":{\"30\":1}}],[\"提供了更加完善的布尔标志\",{\"1\":{\"77\":1}}],[\"提供了对屏障机制的支持\",{\"1\":{\"69\":1}}],[\"提供了两个信号量类型\",{\"1\":{\"68\":1}}],[\"提供了三个成员函数进行所谓的线程停止\",{\"1\":{\"21\":1}}],[\"提供了一种优雅地请求线程停止的方式\",{\"1\":{\"21\":1}}],[\"提示音的播放显然不能占据业务线程的资源\",{\"1\":{\"49\":1}}],[\"提示\",{\"1\":{\"0\":1,\"50\":1}}],[\"位操作系统\",{\"1\":{\"98\":1}}],[\"位环境下\",{\"1\":{\"100\":1}}],[\"位环境\",{\"1\":{\"20\":1}}],[\"位数字\",{\"1\":{\"1\":1}}],[\"先进行一下状态判断\",{\"1\":{\"108\":1}}],[\"先使用锁进行保护\",{\"1\":{\"108\":1}}],[\"先\",{\"1\":{\"100\":1}}],[\"先关联任务\",{\"1\":{\"53\":1}}],[\"先上锁了互斥量\",{\"1\":{\"31\":1}}],[\"先上锁\",{\"1\":{\"30\":2}}],[\"先锁定\",{\"1\":{\"30\":2}}],[\"先看\",{\"1\":{\"27\":1}}],[\"先执行\",{\"1\":{\"25\":1}}],[\"先执行完\",{\"1\":{\"14\":1}}],[\"先前已经提过\",{\"1\":{\"108\":1}}],[\"先前的\",{\"1\":{\"108\":1}}],[\"先前只是为了展示一下显式写明的情况\",{\"1\":{\"75\":1}}],[\"先前提到的静态成员函数\",{\"1\":{\"60\":1}}],[\"先前\",{\"1\":{\"20\":1}}],[\"字节\",{\"1\":{\"20\":1,\"31\":1}}],[\"字符串字面量具有静态存储期\",{\"1\":{\"14\":1}}],[\"字符串字面量的类型是\",{\"1\":{\"14\":1}}],[\"均为\",{\"1\":{\"77\":1}}],[\"均可以通过编译\",{\"1\":{\"71\":1}}],[\"均是如此\",{\"1\":{\"20\":1}}],[\"均会在致谢列表中铭记您的贡献\",{\"1\":{\"0\":1}}],[\"付出额外的开销\",{\"1\":{\"20\":1}}],[\"零开销原则应当很好理解\",{\"1\":{\"22\":1}}],[\"零开销原则\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"停止线程池\",{\"1\":{\"116\":1}}],[\"停止线程池并等待所有线程结束\",{\"1\":{\"116\":1}}],[\"停止接收新任务\",{\"1\":{\"114\":1}}],[\"停止状态\",{\"1\":{\"23\":1}}],[\"停止\",{\"1\":{\"19\":1}}],[\"管理类\",{\"1\":{\"27\":3,\"102\":1}}],[\"管理的一种标志\",{\"1\":{\"23\":1}}],[\"管理\",{\"1\":{\"19\":1}}],[\"管理线程对象也就是管理线程\",{\"1\":{\"18\":1}}],[\"相对于\",{\"1\":{\"104\":1}}],[\"相对于只在\",{\"1\":{\"47\":1}}],[\"相反\",{\"1\":{\"62\":1}}],[\"相比之下\",{\"1\":{\"58\":1}}],[\"相比于之前\",{\"1\":{\"53\":1}}],[\"相比于\",{\"1\":{\"19\":1}}],[\"相信也不会陌生\",{\"1\":{\"115\":1}}],[\"相信你不会陌生\",{\"1\":{\"108\":1}}],[\"相信你也感受到了\",{\"1\":{\"100\":1}}],[\"相信你注意到了\",{\"1\":{\"18\":1}}],[\"相信这个时候就已经想到了\",{\"1\":{\"34\":1}}],[\"没什么好说的\",{\"1\":{\"112\":1}}],[\"没什么规律\",{\"1\":{\"18\":1}}],[\"没办法直接转换为\",{\"1\":{\"66\":1}}],[\"没办法直接被那样传递使用\",{\"1\":{\"53\":1}}],[\"没提供直接从线程获取返回值的机制\",{\"1\":{\"52\":1}}],[\"没事找事\",{\"1\":{\"33\":1}}],[\"没有要求\",{\"1\":{\"103\":1}}],[\"没有数据成员\",{\"1\":{\"102\":1}}],[\"没有好处不会闲的没事给你指令重排\",{\"1\":{\"81\":1}}],[\"没有读取到数据\",{\"1\":{\"79\":2}}],[\"没有卡界面\",{\"1\":{\"64\":1}}],[\"没有被阻塞\",{\"1\":{\"62\":1}}],[\"没有被移动或绑定到引用\",{\"1\":{\"52\":1}}],[\"没有这么精确\",{\"1\":{\"60\":1}}],[\"没有所有权\",{\"1\":{\"52\":1}}],[\"没有所有权自然构造函数就不会上锁\",{\"1\":{\"31\":1}}],[\"没有直接对应的\",{\"1\":{\"39\":1}}],[\"没有直接管理线程的机制\",{\"1\":{\"11\":1}}],[\"没有线程工作\",{\"1\":{\"30\":1}}],[\"没有线程资源\",{\"1\":{\"16\":1}}],[\"没有关联活跃线程\",{\"1\":{\"16\":1}}],[\"没有问题\",{\"1\":{\"12\":1,\"75\":1}}],[\"没有\",{\"1\":{\"12\":1,\"14\":1,\"82\":1,\"108\":1}}],[\"则抛出future\",{\"1\":{\"109\":1}}],[\"则没有进行重写\",{\"1\":{\"108\":1}}],[\"则又调用了父类\",{\"1\":{\"107\":1}}],[\"则适用于不依赖于\",{\"1\":{\"100\":1}}],[\"则必须用类包装一下才行\",{\"1\":{\"100\":1}}],[\"则进入这个分支\",{\"1\":{\"99\":1}}],[\"则表示线程已成功启动\",{\"1\":{\"99\":1}}],[\"则需要注意其复杂性和难以观察的特性\",{\"1\":{\"81\":1}}],[\"则编译错误\",{\"1\":{\"75\":1}}],[\"则将出现数据竞争\",{\"1\":{\"72\":1,\"79\":2}}],[\"则返回\",{\"1\":{\"59\":1}}],[\"则\",{\"1\":{\"54\":1}}],[\"则可以通过编译\",{\"1\":{\"52\":1}}],[\"则是安全的\",{\"1\":{\"51\":1,\"56\":1}}],[\"则线程保持阻塞状态\",{\"1\":{\"49\":1}}],[\"则旧的线程局部变量仍然存在\",{\"1\":{\"38\":1}}],[\"则解锁互斥量\",{\"1\":{\"35\":1}}],[\"则在重抛前对任何已锁的对象调用\",{\"1\":{\"30\":1}}],[\"则要上锁\",{\"1\":{\"30\":1}}],[\"则毫无意义\",{\"1\":{\"30\":1}}],[\"则不会阻塞当前线程\",{\"1\":{\"28\":1}}],[\"则不需要最后的循环\",{\"1\":{\"18\":1}}],[\"则构造函数不会上锁\",{\"1\":{\"27\":1}}],[\"则会产生一个编译错误\",{\"1\":{\"14\":1}}],[\"退出循环\",{\"1\":{\"76\":1}}],[\"退出\",{\"1\":{\"18\":1}}],[\"~scoped\",{\"1\":{\"102\":2,\"103\":1}}],[\"~trivial\",{\"1\":{\"75\":1}}],[\"~threadpool\",{\"1\":{\"116\":1}}],[\"~thread\",{\"1\":{\"12\":1,\"13\":1,\"114\":1}}],[\"~async\",{\"1\":{\"64\":1}}],[\"~audioplayer\",{\"1\":{\"49\":1}}],[\"~x\",{\"1\":{\"38\":1}}],[\"~unique\",{\"1\":{\"31\":1}}],[\"~lock\",{\"1\":{\"27\":1}}],[\"~jthread\",{\"1\":{\"21\":1}}],[\"~joining\",{\"1\":{\"18\":1}}],[\"阅读\",{\"1\":{\"108\":1}}],[\"阅读须知\",{\"0\":{\"93\":1}}],[\"阅读了\",{\"1\":{\"18\":1}}],[\"阅读源码可以帮助我们更轻松的理解标准库设施的使用与原理\",{\"1\":{\"0\":1}}],[\"实例是同一对象的副本且共享所有权也是如此\",{\"1\":{\"79\":1}}],[\"实例化\",{\"1\":{\"75\":1,\"99\":1}}],[\"实时系统或者其它需要高并发性能的场景中\",{\"1\":{\"75\":1}}],[\"实践建议\",{\"0\":{\"67\":1}}],[\"实现一个简易的线程池\",{\"1\":{\"117\":1}}],[\"实现一个普通的能够满足日常开发需求的线程池实际上非常简单\",{\"1\":{\"116\":1}}],[\"实现线程池\",{\"0\":{\"116\":1}}],[\"实现中将类型先经过\",{\"1\":{\"100\":1}}],[\"实现中可能也是使用到了\",{\"1\":{\"97\":1,\"106\":1}}],[\"实现中都是必然在线程中执行任务\",{\"1\":{\"52\":1}}],[\"实现的\",{\"1\":{\"97\":1,\"101\":1}}],[\"实现自旋锁\",{\"1\":{\"76\":1}}],[\"实现选择的执行方式\",{\"1\":{\"52\":1}}],[\"实现异步任务的示例\",{\"1\":{\"46\":1,\"61\":1}}],[\"实现\",{\"0\":{\"18\":1},\"1\":{\"108\":1}}],[\"实际使用了虚函数\",{\"1\":{\"110\":1}}],[\"实际存储数据的队列\",{\"1\":{\"48\":1}}],[\"实际上还需要调用了\",{\"1\":{\"108\":1}}],[\"实际上就是使用条件变量了\",{\"1\":{\"47\":1}}],[\"实际上并没有按引用传递\",{\"1\":{\"14\":1}}],[\"实际需要的是一个\",{\"1\":{\"14\":1}}],[\"后文中会提到\",{\"1\":{\"85\":1}}],[\"后续还会详细展开内存模型的问题\",{\"1\":{\"73\":1}}],[\"后台执行音频任务的专用线程\",{\"1\":{\"49\":1}}],[\"后者有更高的性能优势\",{\"1\":{\"34\":1}}],[\"后\",{\"1\":{\"17\":1,\"108\":1}}],[\"后正常析构\",{\"1\":{\"16\":2}}],[\"后缀\",{\"1\":{\"1\":1,\"47\":1}}],[\"后缀名\",{\"1\":{\"1\":1}}],[\"形参包展开用\",{\"1\":{\"103\":1}}],[\"形参包元素数量为一的偏特化的唯一区别\",{\"1\":{\"103\":1}}],[\"形参包元素数量为一的偏特化\",{\"1\":{\"103\":1}}],[\"形参\",{\"1\":{\"16\":2}}],[\"具有不同的实现逻辑和使用场景\",{\"1\":{\"107\":1}}],[\"具有\",{\"1\":{\"34\":1}}],[\"具有线程资源的所有权\",{\"1\":{\"16\":1}}],[\"具体类型根据类型形参包决定\",{\"1\":{\"102\":1}}],[\"具体的读者会在学习中感受到的\",{\"1\":{\"94\":1}}],[\"具体可参见\",{\"1\":{\"76\":1}}],[\"具体来说\",{\"1\":{\"25\":1,\"49\":1,\"82\":1}}],[\"具体什么时候执行\",{\"1\":{\"14\":1}}],[\"具体如何\",{\"1\":{\"13\":1}}],[\"与先前介绍的\",{\"1\":{\"116\":1}}],[\"与标准库中的\",{\"1\":{\"107\":1}}],[\"与原子对象的值相等\",{\"1\":{\"90\":1}}],[\"与编译器当神经病\",{\"1\":{\"81\":1}}],[\"与编译器不是神经病\",{\"1\":{\"81\":1}}],[\"与此相对\",{\"1\":{\"76\":1}}],[\"与信号量类似\",{\"1\":{\"69\":1}}],[\"与屏障\",{\"1\":{\"69\":1}}],[\"与常规的\",{\"1\":{\"28\":1}}],[\"与线程\",{\"1\":{\"27\":1}}],[\"与\",{\"0\":{\"53\":1,\"90\":1,\"105\":1},\"1\":{\"16\":1,\"27\":1,\"30\":1,\"34\":1,\"35\":1,\"37\":3,\"38\":1,\"48\":3,\"52\":2,\"53\":2,\"54\":1,\"56\":1,\"57\":1,\"68\":1,\"69\":1,\"71\":1,\"76\":1,\"77\":2,\"85\":2,\"94\":1,\"96\":1,\"107\":4,\"115\":1}}],[\"与其配合使用的对象\",{\"1\":{\"14\":1}}],[\"转移线程的所有权\",{\"1\":{\"99\":1}}],[\"转移线程资源的所有权到\",{\"1\":{\"16\":1}}],[\"转移共享状态\",{\"1\":{\"56\":1}}],[\"转移\",{\"1\":{\"32\":1,\"56\":1}}],[\"转移所有权\",{\"0\":{\"16\":1}}],[\"转换为了一个右值表达式\",{\"1\":{\"16\":1}}],[\"转换为\",{\"1\":{\"14\":1}}],[\"转换为std\",{\"1\":{\"14\":1}}],[\"输出\",{\"1\":{\"71\":1}}],[\"输出语句\",{\"1\":{\"26\":1}}],[\"输出等待结束后的时间\",{\"1\":{\"15\":1}}],[\"输出等待的时间点\",{\"1\":{\"15\":1}}],[\"输出当前时间\",{\"1\":{\"15\":1}}],[\"输出的值会为\",{\"1\":{\"10\":1}}],[\"5f\",{\"1\":{\"75\":3}}],[\"59\",{\"1\":{\"71\":1}}],[\"58\",{\"1\":{\"71\":1}}],[\"57\",{\"1\":{\"71\":1}}],[\"56\",{\"1\":{\"71\":1}}],[\"55\",{\"1\":{\"71\":1}}],[\"54\",{\"1\":{\"71\":1}}],[\"53\",{\"1\":{\"71\":1}}],[\"52\",{\"1\":{\"71\":1}}],[\"51\",{\"1\":{\"71\":1}}],[\"5px\",{\"1\":{\"64\":1}}],[\"500ms\",{\"1\":{\"60\":2}}],[\"500\",{\"1\":{\"60\":3}}],[\"50\",{\"1\":{\"53\":1,\"64\":2,\"71\":1,\"75\":1}}],[\"50ms\",{\"1\":{\"49\":1}}],[\"5s\",{\"1\":{\"15\":1,\"79\":1}}],[\"5\",{\"1\":{\"15\":1,\"21\":1,\"44\":1,\"47\":3,\"48\":2,\"54\":1,\"58\":1,\"68\":1,\"70\":1,\"71\":2,\"78\":1,\"115\":1,\"116\":2}}],[\"llong\",{\"1\":{\"75\":3}}],[\"leastmaxvalue\",{\"1\":{\"68\":5,\"72\":2}}],[\"lowpriority\",{\"1\":{\"115\":2}}],[\"lowestpriority\",{\"1\":{\"115\":1}}],[\"loadedvalue\",{\"1\":{\"75\":3}}],[\"load\",{\"1\":{\"75\":7,\"77\":7,\"78\":3,\"79\":9,\"116\":1}}],[\"loop\",{\"1\":{\"60\":1}}],[\"long>\",{\"1\":{\"59\":2,\"75\":3}}],[\"long\",{\"1\":{\"59\":3,\"60\":1,\"75\":5,\"114\":1}}],[\"local\",{\"1\":{\"37\":13,\"38\":4,\"43\":1,\"55\":7,\"108\":10}}],[\"local关键字\",{\"1\":{\"37\":1}}],[\"localtime\",{\"1\":{\"15\":3,\"58\":2}}],[\"lock<>\",{\"1\":{\"102\":2}}],[\"lock<\",{\"1\":{\"102\":1}}],[\"lock<mutex>\",{\"1\":{\"47\":2,\"107\":1,\"108\":4,\"109\":2}}],[\"lock<std\",{\"1\":{\"27\":1,\"31\":5,\"32\":3,\"34\":2,\"47\":7,\"48\":2,\"49\":1,\"60\":1,\"102\":2,\"103\":1,\"116\":1}}],[\"lock2\",{\"1\":{\"30\":2,\"31\":2}}],[\"lock1\",{\"1\":{\"30\":2,\"31\":2}}],[\"lock\",{\"0\":{\"101\":1},\"1\":{\"26\":6,\"27\":35,\"28\":4,\"29\":3,\"30\":24,\"31\":43,\"32\":12,\"33\":1,\"34\":5,\"35\":9,\"45\":1,\"47\":7,\"48\":2,\"49\":4,\"74\":1,\"75\":22,\"76\":4,\"82\":2,\"101\":2,\"102\":36,\"103\":17,\"104\":1,\"107\":4,\"108\":13,\"109\":4,\"114\":1,\"116\":1}}],[\"locked\",{\"1\":{\"26\":1,\"31\":1,\"35\":2,\"109\":1}}],[\"lk\",{\"1\":{\"32\":5,\"33\":1,\"47\":6,\"48\":6,\"60\":2}}],[\"lhs\",{\"1\":{\"30\":15,\"31\":4}}],[\"lc3\",{\"1\":{\"102\":1}}],[\"lck\",{\"1\":{\"47\":9}}],[\"lc2\",{\"1\":{\"30\":2,\"102\":1}}],[\"lc1\",{\"1\":{\"30\":2}}],[\"lc\",{\"1\":{\"27\":7,\"29\":1,\"35\":1,\"74\":1,\"76\":1,\"102\":1,\"103\":1,\"114\":1,\"116\":3}}],[\"likelihood\",{\"1\":{\"76\":1}}],[\"linus\",{\"1\":{\"76\":1}}],[\"linux\",{\"1\":{\"38\":1,\"39\":1,\"45\":1,\"50\":2,\"66\":1}}],[\"lightgrey\",{\"1\":{\"64\":1}}],[\"liquidbinsufficient\",{\"1\":{\"50\":1}}],[\"liquidainsufficient\",{\"1\":{\"50\":1}}],[\"list<int>\",{\"1\":{\"27\":3}}],[\"list\",{\"1\":{\"27\":28}}],[\"lib\",{\"1\":{\"60\":1}}],[\"libopenal\",{\"1\":{\"50\":1}}],[\"libflac\",{\"1\":{\"50\":1}}],[\"library\",{\"1\":{\"21\":1}}],[\"libc++的实现\",{\"1\":{\"101\":1}}],[\"libc++\",{\"1\":{\"20\":1,\"21\":2,\"71\":1,\"76\":1,\"94\":1,\"100\":1,\"103\":1}}],[\"libstdc++\",{\"1\":{\"20\":1,\"21\":1,\"52\":1,\"71\":1,\"76\":1,\"94\":1,\"100\":3,\"101\":1,\"103\":1}}],[\"literals\",{\"1\":{\"15\":2,\"21\":2,\"59\":2,\"60\":1}}],[\"latch\",{\"1\":{\"69\":2,\"70\":13,\"71\":2}}],[\"layout\",{\"1\":{\"64\":5}}],[\"launched\",{\"1\":{\"107\":2}}],[\"launch\",{\"1\":{\"38\":2,\"52\":19,\"56\":2,\"59\":1,\"62\":1,\"64\":1,\"65\":1,\"107\":18,\"108\":6,\"109\":1,\"110\":3}}],[\"lambda\",{\"1\":{\"12\":2,\"53\":3,\"56\":2,\"65\":1,\"71\":2}}],[\"last\",{\"1\":{\"10\":5,\"53\":3}}],[\"秒最终的值是\",{\"1\":{\"59\":1}}],[\"秒一次\",{\"1\":{\"58\":1}}],[\"秒就是\",{\"1\":{\"15\":1}}],[\"秒\",{\"1\":{\"15\":1,\"21\":1,\"47\":1,\"58\":2,\"59\":2}}],[\"使我们能够无需关心底层硬件环境就编写出跨平台的应用程序\",{\"1\":{\"85\":1}}],[\"使得\",{\"1\":{\"81\":1}}],[\"使得能异步调用它\",{\"1\":{\"53\":1}}],[\"使受保护数据传递给外部\",{\"1\":{\"29\":1}}],[\"使当前线程执行停止到指定的时间点\",{\"1\":{\"15\":1}}],[\"使当前线程停止执行指定时间\",{\"1\":{\"15\":1}}],[\"使用与创建线程相同的优先级\",{\"1\":{\"115\":1}}],[\"使用方法\",{\"1\":{\"114\":1}}],[\"使用一下市面上常见的那些\",{\"1\":{\"113\":1}}],[\"使用到了自家的\",{\"1\":{\"110\":1}}],[\"使用了折叠表达式展开形参包\",{\"1\":{\"103\":1}}],[\"使用了\",{\"1\":{\"103\":1}}],[\"使用标准库的内容很多时候不加\",{\"1\":{\"99\":1}}],[\"使用起来也都十分的简单\",{\"1\":{\"79\":1}}],[\"使用示例如下\",{\"1\":{\"78\":1}}],[\"使用默认的\",{\"1\":{\"76\":1}}],[\"使用更高效的同步机制\",{\"1\":{\"75\":1}}],[\"使用不同的数据结构\",{\"1\":{\"75\":1}}],[\"使用也十分的简单\",{\"1\":{\"71\":1}}],[\"使用功能尽可能少的设施有助于开发者阅读代码理解含义\",{\"1\":{\"70\":1}}],[\"使用条件变量监控队列是否为空\",{\"1\":{\"49\":1}}],[\"使用条件变量实现后台提示音播放\",{\"0\":{\"49\":1}}],[\"使用qt+cmake\",{\"1\":{\"46\":1}}],[\"使用读写锁\",{\"1\":{\"45\":1}}],[\"使用它可以将之前使用\",{\"1\":{\"31\":1}}],[\"使用固定顺序获取锁\",{\"1\":{\"30\":1}}],[\"使用互斥量创建了一个独占锁\",{\"1\":{\"47\":1}}],[\"使用互斥量\",{\"0\":{\"26\":1}}],[\"使用互斥量保护共享数据\",{\"1\":{\"24\":1}}],[\"使用互斥量可以解决这些问题\",{\"1\":{\"18\":1}}],[\"使用我们这节实现的\",{\"1\":{\"18\":1}}],[\"使用容器管理线程对象\",{\"1\":{\"18\":1}}],[\"使用\",{\"0\":{\"51\":1,\"54\":1},\"1\":{\"10\":1,\"12\":2,\"15\":3,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":2,\"31\":2,\"33\":3,\"37\":4,\"38\":2,\"45\":1,\"47\":1,\"52\":2,\"58\":1,\"65\":1,\"66\":1,\"71\":2,\"75\":3,\"76\":1,\"77\":1,\"79\":1,\"82\":1,\"94\":1,\"99\":2,\"100\":2,\"114\":2}}],[\"使用线程池的益处我们已经加粗了\",{\"1\":{\"112\":1}}],[\"使用线程也就是代表使用\",{\"1\":{\"8\":1}}],[\"使用线程\",{\"0\":{\"8\":1},\"1\":{\"23\":1}}],[\"使用硬件提高数据处理速度时\",{\"1\":{\"6\":1}}],[\"建议学习现代c++模板教程\",{\"1\":{\"101\":1}}],[\"建议下载并运行此项目\",{\"1\":{\"67\":1}}],[\"建议不要将线程局部变量与\",{\"1\":{\"38\":1}}],[\"建议阅读std\",{\"1\":{\"30\":1}}],[\"建议你多思考\",{\"1\":{\"23\":1}}],[\"建议实现重新调度各执行线程\",{\"1\":{\"15\":1}}],[\"建议使用时间字面量\",{\"1\":{\"15\":1}}],[\"建议使用\",{\"1\":{\"12\":1,\"21\":1}}],[\"显式转换为\",{\"1\":{\"103\":1}}],[\"显式转换可以由\",{\"1\":{\"59\":1}}],[\"显式将\",{\"1\":{\"14\":1}}],[\"显而易见\",{\"1\":{\"47\":1}}],[\"显然我们的类型满足要求\",{\"1\":{\"75\":1}}],[\"显然逻辑不对\",{\"1\":{\"12\":1}}],[\"显然\",{\"1\":{\"12\":1,\"74\":2,\"79\":1}}],[\"下节\",{\"1\":{\"76\":1}}],[\"下一节我们来看看它是如何工作的\",{\"1\":{\"77\":1}}],[\"下一个阶段的计数会重置为\",{\"1\":{\"71\":1}}],[\"下一章\",{\"1\":{\"45\":1}}],[\"下可能为\",{\"1\":{\"14\":1}}],[\"下面我的\",{\"1\":{\"12\":1}}],[\"确保所有线程都已终止\",{\"1\":{\"114\":1}}],[\"确保异步任务执行完毕\",{\"1\":{\"109\":1}}],[\"确保只有在条件满足时才会继续执行\",{\"1\":{\"108\":1}}],[\"确保即使存在\",{\"1\":{\"82\":1}}],[\"确保多线程环境下的正确性\",{\"1\":{\"81\":1}}],[\"确保传入的函数对象是\",{\"1\":{\"71\":1}}],[\"确保\",{\"1\":{\"62\":1}}],[\"确保在多线程环境下的数据同步\",{\"1\":{\"47\":1}}],[\"确保全局对象的线程安全访问通常需要额外的同步措施\",{\"1\":{\"36\":1}}],[\"确保每个对象的互斥量都锁住自己要保护的区域\",{\"1\":{\"30\":1}}],[\"确保实参在按值传递时会退化\",{\"1\":{\"14\":1}}],[\"确保线程池的完全清理和资源的正确释放\",{\"1\":{\"114\":1}}],[\"确保线程池至少有\",{\"1\":{\"114\":1}}],[\"确保线程执行完成\",{\"1\":{\"13\":1}}],[\"确保线程正常执行完成\",{\"1\":{\"12\":1}}],[\"动态\",{\"1\":{\"14\":1}}],[\"被向后移植到了\",{\"1\":{\"97\":1,\"106\":1}}],[\"被引入\",{\"1\":{\"92\":1}}],[\"被清空\",{\"1\":{\"56\":1}}],[\"被移动的\",{\"1\":{\"52\":1}}],[\"被设置为\",{\"1\":{\"47\":1}}],[\"被唤醒\",{\"1\":{\"47\":1}}],[\"被称作\",{\"1\":{\"33\":1}}],[\"被\",{\"1\":{\"26\":1}}],[\"被线程对象保存\",{\"1\":{\"14\":1}}],[\"被销毁\",{\"1\":{\"12\":1}}],[\"或许\",{\"1\":{\"103\":1}}],[\"或其它成员函数也可能修改共享数据\",{\"1\":{\"45\":1}}],[\"或\",{\"1\":{\"20\":1,\"21\":1,\"25\":2,\"30\":1,\"32\":1,\"37\":1,\"48\":2,\"52\":2,\"59\":1,\"71\":1,\"72\":1,\"75\":1,\"77\":1,\"79\":1,\"107\":2}}],[\"或者直接在捐赠初始记录名单中进行评论\",{\"1\":{\"119\":1}}],[\"或者直接被称作\",{\"1\":{\"26\":1}}],[\"或者联系我\",{\"1\":{\"119\":1}}],[\"或者其它扩展讲解\",{\"1\":{\"118\":1}}],[\"或者其它软件网站将音频转换为支持的格式\",{\"1\":{\"50\":1}}],[\"或者析构自动调用\",{\"1\":{\"114\":1}}],[\"或者两者的组合\",{\"1\":{\"107\":1}}],[\"或者隐式转换\",{\"1\":{\"77\":1}}],[\"或者延迟执行可以提高性能或节省资源\",{\"1\":{\"52\":1}}],[\"或者任务已经执行完\",{\"1\":{\"52\":1}}],[\"或者报错了也会有提示音说明\",{\"1\":{\"49\":1}}],[\"或者依赖各家编译器的扩展\",{\"1\":{\"37\":1}}],[\"或者外部的\",{\"1\":{\"36\":1}}],[\"或者在同一信号处理函数中执行\",{\"1\":{\"25\":1}}],[\"或者\",{\"1\":{\"20\":1,\"59\":1,\"95\":1,\"108\":1}}],[\"或者以任何形式转换到a\",{\"1\":{\"14\":1}}],[\"或某个函数类型\",{\"1\":{\"12\":1}}],[\"x>\",{\"1\":{\"99\":1}}],[\"x2\",{\"1\":{\"99\":1}}],[\"x86\",{\"1\":{\"81\":1,\"85\":6,\"94\":1}}],[\"xxx\",{\"1\":{\"75\":1}}],[\"xx\",{\"1\":{\"48\":1}}],[\"x64\",{\"1\":{\"31\":1}}],[\"x\",{\"1\":{\"14\":15,\"30\":11,\"31\":2,\"36\":4,\"38\":10,\"45\":1,\"52\":6,\"58\":2,\"75\":11,\"77\":2,\"78\":4,\"82\":5,\"99\":19,\"116\":7}}],[\"解引用指针\",{\"1\":{\"99\":1}}],[\"解引用\",{\"1\":{\"79\":1}}],[\"解除阻塞时重置计数并调用函数对象\",{\"1\":{\"71\":1}}],[\"解除阻塞时就重置计数并调用函数对象\",{\"1\":{\"71\":1}}],[\"解决\",{\"1\":{\"51\":1}}],[\"解决方案\",{\"1\":{\"14\":1}}],[\"解决方法很简单\",{\"1\":{\"12\":1,\"47\":1}}],[\"解释这段代码最简单的方式就是直接展示标准库的源码\",{\"1\":{\"31\":1}}],[\"解释清楚\",{\"1\":{\"14\":1}}],[\"解锁并释放所有权\",{\"1\":{\"31\":1}}],[\"解锁互斥量\",{\"1\":{\"31\":1,\"35\":1,\"47\":2}}],[\"解锁\",{\"1\":{\"27\":1,\"28\":1,\"30\":3}}],[\"记住\",{\"1\":{\"14\":1}}],[\"o\",{\"1\":{\"114\":1}}],[\"override\",{\"1\":{\"107\":1,\"108\":2,\"115\":1}}],[\"of\",{\"1\":{\"99\":1}}],[\"ownership\",{\"1\":{\"99\":1}}],[\"owns\",{\"1\":{\"31\":11,\"32\":3}}],[\"osyncstream\",{\"1\":{\"71\":6,\"79\":2,\"116\":1}}],[\"or\",{\"1\":{\"55\":3,\"108\":5}}],[\"ordered\",{\"1\":{\"85\":2}}],[\"order\",{\"1\":{\"25\":1,\"75\":13,\"76\":6,\"77\":6,\"78\":1,\"81\":1,\"82\":3,\"83\":30,\"85\":2,\"94\":1}}],[\"ok\",{\"1\":{\"52\":1}}],[\"ogg\",{\"1\":{\"50\":11}}],[\"openmp\",{\"1\":{\"69\":1}}],[\"openal\",{\"1\":{\"50\":1}}],[\"openfromfile\",{\"1\":{\"49\":1}}],[\"operation\",{\"1\":{\"31\":1}}],[\"operator+=\",{\"1\":{\"78\":1}}],[\"operator<<\",{\"1\":{\"25\":1,\"71\":2}}],[\"operator=\",{\"1\":{\"13\":1,\"18\":1,\"27\":1,\"52\":1,\"75\":2,\"77\":1,\"79\":1,\"90\":1,\"95\":1,\"102\":3,\"107\":2,\"108\":2,\"116\":1}}],[\"operator\",{\"1\":{\"12\":5,\"36\":9,\"52\":1,\"53\":3,\"75\":1,\"78\":1,\"99\":1}}],[\"on\",{\"1\":{\"114\":1,\"116\":10}}],[\"one\",{\"1\":{\"47\":3,\"48\":1,\"49\":1,\"59\":6,\"79\":2,\"116\":1}}],[\"once为真并且结果已被检索过\",{\"1\":{\"109\":1}}],[\"once\",{\"1\":{\"33\":13,\"45\":1,\"107\":2,\"108\":8}}],[\"only>\",{\"1\":{\"52\":1}}],[\"only\",{\"1\":{\"14\":8,\"52\":12,\"55\":1,\"95\":9,\"107\":2,\"108\":8,\"109\":1}}],[\"occur\",{\"1\":{\"31\":1}}],[\"other\",{\"1\":{\"18\":6,\"32\":5,\"75\":2,\"99\":6,\"107\":3,\"108\":2}}],[\"object\",{\"1\":{\"30\":8,\"31\":2,\"52\":1,\"64\":1,\"99\":1,\"107\":4,\"108\":2}}],[\"obj\",{\"1\":{\"14\":2,\"103\":4}}],[\"左值引用没办法引用右值表达式\",{\"1\":{\"14\":1,\"52\":1}}],[\"呢\",{\"1\":{\"14\":1}}],[\"顾名思义\",{\"1\":{\"14\":1}}],[\"引用的就是\",{\"1\":{\"14\":2}}],[\"引用\",{\"1\":{\"14\":2,\"77\":1}}],[\"引入过多的源码实现等等从头讲解\",{\"1\":{\"108\":1}}],[\"引入头文件时需要在尖括号或引号前后加空格\",{\"1\":{\"95\":1}}],[\"引入了一个\",{\"1\":{\"115\":1}}],[\"引入了一个偏特化版本\",{\"1\":{\"79\":1}}],[\"引入了许多新颖的做法\",{\"1\":{\"92\":1}}],[\"引入了协程语法\",{\"1\":{\"92\":1}}],[\"引入了原子类型\",{\"1\":{\"74\":1}}],[\"引入了信号量\",{\"1\":{\"68\":1}}],[\"引入了thread\",{\"1\":{\"37\":1}}],[\"引入\",{\"1\":{\"10\":1,\"20\":1,\"52\":1}}],[\"引入的类模板\",{\"1\":{\"101\":1}}],[\"引入的两种新的并发设施\",{\"1\":{\"72\":1}}],[\"引入的新的同步设施\",{\"1\":{\"46\":1}}],[\"引入的一种通用互斥包装器\",{\"1\":{\"31\":1}}],[\"引入的求和算法\",{\"1\":{\"10\":1}}],[\"引入的\",{\"1\":{\"10\":1,\"12\":1,\"19\":1,\"23\":1,\"71\":1,\"75\":1,\"97\":1}}],[\"引入线程支持头文件\",{\"1\":{\"9\":1}}],[\"打印了元组所有的元素\",{\"1\":{\"103\":1}}],[\"打印函数\",{\"1\":{\"27\":1}}],[\"打印的时候\",{\"1\":{\"27\":1}}],[\"打印的是乱序的\",{\"1\":{\"18\":1}}],[\"打印的地址截然不同\",{\"1\":{\"14\":1}}],[\"打印\",{\"1\":{\"16\":2,\"21\":1,\"27\":1}}],[\"打印地址完全相同\",{\"1\":{\"14\":1}}],[\"打印日志\",{\"1\":{\"13\":1}}],[\"需要通过如\",{\"1\":{\"106\":1}}],[\"需要注意\",{\"1\":{\"100\":1}}],[\"需要注意的是\",{\"1\":{\"14\":1,\"38\":1,\"50\":1,\"55\":1,\"106\":1}}],[\"需要传入一个索引\",{\"1\":{\"99\":1}}],[\"需要传递一个\",{\"1\":{\"59\":1}}],[\"需要详细讲解\",{\"1\":{\"99\":1}}],[\"需要开发者使用同步原语来显式地控制内存操作的顺序和可见性\",{\"1\":{\"81\":1}}],[\"需要在循环中重试\",{\"1\":{\"77\":1}}],[\"需要使用异步任务来减轻主线程的压力\",{\"1\":{\"61\":1}}],[\"需要链接\",{\"1\":{\"60\":1}}],[\"需要限定线程等待的时间\",{\"1\":{\"57\":1}}],[\"需要确保没有其他线程正在执行\",{\"1\":{\"48\":1}}],[\"需要设置\",{\"1\":{\"37\":1}}],[\"需要进行额外的同步措施进行保护\",{\"1\":{\"36\":1}}],[\"需要进行回溯和重置状态\",{\"1\":{\"33\":1}}],[\"需要进行保护\",{\"1\":{\"27\":1}}],[\"需要遥控器和玩具车才能玩\",{\"1\":{\"30\":1}}],[\"需要更高的标准会进行强调\",{\"1\":{\"0\":1}}],[\"传递一个\",{\"1\":{\"107\":1}}],[\"传递返回值的地址\",{\"1\":{\"107\":1}}],[\"传递返回值\",{\"1\":{\"107\":1,\"109\":1}}],[\"传递给线程的参数为\",{\"1\":{\"99\":1}}],[\"传递给\",{\"1\":{\"99\":1}}],[\"传递给这个函数\",{\"1\":{\"14\":1}}],[\"传递\",{\"1\":{\"52\":1,\"108\":1}}],[\"传递了一个恶意的函数\",{\"1\":{\"29\":1}}],[\"传递的可调用对象执行结果\",{\"1\":{\"107\":1}}],[\"传递的\",{\"1\":{\"21\":1}}],[\"传递参数一节中的\",{\"1\":{\"17\":1,\"100\":1}}],[\"传递参数\",{\"0\":{\"14\":1},\"1\":{\"17\":1,\"70\":1}}],[\"传入的可调用对象\",{\"1\":{\"99\":1}}],[\"传入了一个谓词\",{\"1\":{\"47\":1}}],[\"传入可调用对象以及参数\",{\"1\":{\"16\":1}}],[\"传入成员函数指针\",{\"1\":{\"14\":1}}],[\"传入\",{\"1\":{\"12\":1,\"99\":1}}],[\"严格来说其实这里倒也不算\",{\"1\":{\"13\":1}}],[\"单线程能不能指令重排\",{\"1\":{\"81\":1}}],[\"单看它提供的修改接口\",{\"1\":{\"79\":1}}],[\"单次使用的线程屏障\",{\"1\":{\"69\":1,\"70\":1}}],[\"单例\",{\"1\":{\"33\":1}}],[\"单纯的做好\",{\"1\":{\"13\":1}}],[\"单核机器的任务切换\",{\"1\":{\"5\":1}}],[\"看似有一些没有使用\",{\"1\":{\"59\":1}}],[\"看到无序的输出\",{\"1\":{\"36\":1}}],[\"看到它一定打印\",{\"1\":{\"13\":1}}],[\"看起来一点问题也没有\",{\"1\":{\"29\":1}}],[\"看一遍描述就可以了\",{\"1\":{\"26\":1}}],[\"看情况分析\",{\"1\":{\"13\":1}}],[\"难以掌控\",{\"1\":{\"13\":1}}],[\"前三个构造函数都没啥要特别聊的\",{\"1\":{\"99\":1}}],[\"前面了\",{\"1\":{\"81\":2}}],[\"前面的内容也都提到了\",{\"1\":{\"36\":1}}],[\"前者可以在阶段完成之后将计数重置为构造时传递的值\",{\"1\":{\"71\":1}}],[\"前者是需要指定等待一段时间\",{\"1\":{\"57\":1}}],[\"前者支持更多的操作方式\",{\"1\":{\"34\":1}}],[\"前提是你捕获了这个异常\",{\"1\":{\"13\":1}}],[\"前言\",{\"0\":{\"3\":1,\"81\":1,\"92\":1,\"106\":1,\"112\":1}}],[\"抛出一个\",{\"1\":{\"99\":1}}],[\"抛出\",{\"1\":{\"55\":1}}],[\"抛出了一个异常\",{\"1\":{\"13\":1}}],[\"抛出异常并设置\",{\"1\":{\"54\":4}}],[\"抛出异常\",{\"1\":{\"12\":2,\"52\":1}}],[\"抛出异常的代码\",{\"1\":{\"12\":1}}],[\"析构自动\",{\"1\":{\"116\":2}}],[\"析构解锁\",{\"1\":{\"102\":1,\"103\":1}}],[\"析构同理\",{\"1\":{\"36\":1}}],[\"析构函数并不会等待所有任务执行完毕\",{\"1\":{\"114\":1}}],[\"析构函数先调用了\",{\"1\":{\"114\":1}}],[\"析构函数就要稍微聊一下了\",{\"1\":{\"103\":1}}],[\"析构函数将阻塞\",{\"1\":{\"52\":1}}],[\"析构函数\",{\"1\":{\"36\":1,\"116\":1}}],[\"析构函数不会再\",{\"1\":{\"31\":1}}],[\"析构函数中解锁\",{\"1\":{\"27\":1}}],[\"析构函数释放资源\",{\"1\":{\"13\":1}}],[\"析构\",{\"1\":{\"13\":2,\"45\":1}}],[\"gthread\",{\"1\":{\"100\":4}}],[\"gthreads\",{\"1\":{\"100\":2}}],[\"glibcxx\",{\"1\":{\"100\":2}}],[\"globalinstance\",{\"1\":{\"115\":2}}],[\"global\",{\"1\":{\"37\":5}}],[\"gen\",{\"1\":{\"68\":2}}],[\"get`\",{\"1\":{\"108\":1}}],[\"get<index>\",{\"1\":{\"103\":1}}],[\"get<>\",{\"1\":{\"99\":1}}],[\"get<\",{\"1\":{\"99\":2,\"100\":1}}],[\"getstatus\",{\"1\":{\"49\":1}}],[\"getspecific\",{\"1\":{\"37\":1}}],[\"get\",{\"1\":{\"15\":5,\"16\":1,\"18\":4,\"21\":4,\"26\":2,\"27\":1,\"32\":2,\"33\":2,\"34\":1,\"35\":2,\"50\":2,\"52\":14,\"53\":11,\"54\":8,\"55\":15,\"56\":9,\"59\":2,\"66\":1,\"79\":5,\"99\":10,\"103\":1,\"107\":20,\"108\":33,\"109\":2,\"110\":1,\"114\":1,\"116\":3}}],[\"grey\",{\"1\":{\"64\":1}}],[\"gui\",{\"1\":{\"62\":1}}],[\"guard<spinlock\",{\"1\":{\"76\":1}}],[\"guard<std\",{\"1\":{\"27\":5,\"29\":1,\"30\":8,\"33\":1,\"34\":1,\"35\":1,\"47\":1,\"48\":2,\"49\":1,\"74\":1,\"103\":1,\"114\":1,\"116\":1}}],[\"guard的区别在于\",{\"1\":{\"27\":1}}],[\"guard\",{\"1\":{\"13\":12,\"27\":16,\"29\":2,\"30\":2,\"31\":4,\"34\":1,\"35\":1,\"45\":1,\"102\":2,\"103\":1}}],[\"g\",{\"1\":{\"13\":2,\"52\":1}}],[\"gcc14\",{\"1\":{\"92\":1,\"94\":1}}],[\"gcc\",{\"1\":{\"0\":1,\"37\":6,\"38\":2,\"71\":1,\"94\":2,\"100\":1}}],[\"rx\",{\"1\":{\"107\":5,\"108\":1}}],[\"rx>\",{\"1\":{\"107\":2}}],[\"risc\",{\"1\":{\"85\":7}}],[\"rule\",{\"1\":{\"81\":1}}],[\"runnable\",{\"1\":{\"115\":1}}],[\"running\",{\"1\":{\"107\":2,\"108\":2,\"114\":1,\"116\":10}}],[\"runtime\",{\"1\":{\"33\":1,\"54\":2,\"116\":1}}],[\"run\",{\"1\":{\"14\":7,\"107\":3,\"108\":11,\"109\":1,\"115\":3}}],[\"rd\",{\"1\":{\"68\":2}}],[\"raw\",{\"1\":{\"107\":4,\"108\":1,\"109\":2}}],[\"rawvals\",{\"1\":{\"99\":2}}],[\"random\",{\"1\":{\"68\":1}}],[\"radius\",{\"1\":{\"64\":1}}],[\"ratio\",{\"1\":{\"58\":1,\"59\":7}}],[\"ratio<3600>>\",{\"1\":{\"59\":1}}],[\"ratio<60>>\",{\"1\":{\"58\":1,\"59\":1}}],[\"ratio<60>\",{\"1\":{\"58\":1}}],[\"ratio<5\",{\"1\":{\"58\":1}}],[\"ratio<12>>>\",{\"1\":{\"59\":1}}],[\"ratio<1>\",{\"1\":{\"58\":1,\"59\":2}}],[\"ratio<1>>\",{\"1\":{\"58\":1,\"59\":1}}],[\"ratio<1\",{\"1\":{\"58\":2,\"59\":1,\"60\":1}}],[\"raii\",{\"0\":{\"13\":1},\"1\":{\"13\":3,\"19\":1,\"27\":1,\"30\":1}}],[\"rhs\",{\"1\":{\"30\":15,\"31\":4}}],[\"rvo\",{\"1\":{\"16\":1}}],[\"rt\",{\"1\":{\"16\":6}}],[\"r\",{\"1\":{\"14\":6,\"53\":1,\"76\":2}}],[\"reinterpret\",{\"1\":{\"99\":2}}],[\"remove\",{\"1\":{\"99\":2,\"103\":1}}],[\"remainder\",{\"1\":{\"10\":5,\"53\":2}}],[\"re\",{\"1\":{\"76\":1}}],[\"rel\",{\"1\":{\"75\":1,\"77\":1,\"83\":4}}],[\"relaxed\",{\"1\":{\"75\":3,\"83\":5}}],[\"release\",{\"1\":{\"68\":5,\"75\":2,\"76\":3,\"77\":2,\"78\":1,\"82\":1,\"83\":4,\"99\":2}}],[\"repeat\",{\"1\":{\"76\":1}}],[\"rep\",{\"1\":{\"58\":1,\"59\":1}}],[\"requirements\",{\"1\":{\"108\":1}}],[\"requires\",{\"1\":{\"53\":1}}],[\"request\",{\"1\":{\"21\":5,\"68\":5}}],[\"requested\",{\"1\":{\"21\":2}}],[\"rettype\",{\"1\":{\"116\":1}}],[\"rethrow\",{\"1\":{\"108\":2}}],[\"retrieved设置为true\",{\"1\":{\"109\":1}}],[\"retrieved异常\",{\"1\":{\"109\":1}}],[\"retrieved`\",{\"1\":{\"108\":1}}],[\"retrieved\",{\"1\":{\"107\":14,\"108\":4}}],[\"ret>\",{\"1\":{\"52\":3,\"107\":10}}],[\"ret\",{\"1\":{\"52\":1,\"107\":9,\"116\":2}}],[\"returning\",{\"1\":{\"107\":3}}],[\"return\",{\"1\":{\"10\":2,\"12\":1,\"16\":2,\"18\":5,\"30\":3,\"31\":1,\"32\":2,\"33\":1,\"34\":1,\"36\":1,\"47\":2,\"48\":4,\"49\":2,\"52\":7,\"53\":7,\"55\":6,\"56\":3,\"59\":1,\"60\":2,\"71\":1,\"79\":1,\"92\":1,\"95\":1,\"99\":2,\"103\":2,\"107\":14,\"108\":15,\"114\":1,\"116\":4}}],[\"reader\",{\"1\":{\"79\":5}}],[\"read\",{\"1\":{\"75\":1}}],[\"ready\",{\"1\":{\"55\":3,\"59\":2,\"107\":4,\"108\":9}}],[\"reactioncupinsufficient\",{\"1\":{\"50\":1}}],[\"reagentexpired\",{\"1\":{\"50\":1}}],[\"reagentinsufficient\",{\"1\":{\"50\":1}}],[\"realloc\",{\"1\":{\"36\":1}}],[\"recursive\",{\"1\":{\"35\":12,\"45\":1}}],[\"ref<int>\",{\"1\":{\"79\":1}}],[\"reference\",{\"1\":{\"14\":5,\"103\":1,\"107\":1}}],[\"ref\",{\"1\":{\"14\":8,\"17\":1,\"27\":2,\"52\":4,\"56\":2,\"77\":2,\"79\":3,\"100\":2,\"116\":1}}],[\"result\",{\"1\":{\"52\":1,\"54\":2,\"55\":2,\"56\":2,\"60\":2,\"107\":15,\"108\":6,\"109\":15,\"116\":2}}],[\"results\",{\"1\":{\"10\":5}}],[\"res\",{\"1\":{\"48\":2}}],[\"reset\",{\"1\":{\"33\":3,\"79\":1,\"90\":1}}],[\"resource\",{\"1\":{\"13\":1,\"31\":1,\"33\":4,\"99\":2}}],[\"reduce\",{\"1\":{\"10\":1}}],[\"块中的代码抛出了异常\",{\"1\":{\"12\":1}}],[\"块中最后一行写一个\",{\"1\":{\"12\":1}}],[\"你不会期待我们将每一个成员函数都分析一遍吧\",{\"1\":{\"110\":1}}],[\"你不需要为你没有用到的\",{\"1\":{\"20\":1}}],[\"你阅读标准库源码\",{\"1\":{\"100\":1,\"101\":1,\"104\":1}}],[\"你只需要知道\",{\"1\":{\"99\":1}}],[\"你们可能还有疑问\",{\"1\":{\"81\":1}}],[\"你肯定会想着\",{\"1\":{\"79\":1}}],[\"你知道自己在做什么的可能性基本上为零\",{\"1\":{\"76\":1}}],[\"你始终在等待一件事情\",{\"1\":{\"51\":1}}],[\"你可能还希望我们的线程池具备更多功能或改进\",{\"1\":{\"116\":1}}],[\"你可能还无法在实际环境利用多线程提升程序效率\",{\"1\":{\"23\":1}}],[\"你可能会有疑问\",{\"1\":{\"85\":1}}],[\"你可能会想着再写一行\",{\"1\":{\"54\":1}}],[\"你可能会做一些别的事情打发时间\",{\"1\":{\"51\":1}}],[\"你可能对这段代码还有一些疑问\",{\"1\":{\"54\":1}}],[\"你需要考虑如何在程序运行到不同状态时添加适当的语音播报\",{\"1\":{\"49\":1}}],[\"你有一个数据结构存储了用户的设置信息\",{\"1\":{\"34\":1}}],[\"你是否感到奇怪\",{\"1\":{\"16\":1}}],[\"你是否觉得这样也可以\",{\"1\":{\"12\":1}}],[\"你简单认为reference\",{\"1\":{\"14\":1}}],[\"你要注意我们的注释\",{\"1\":{\"12\":1}}],[\"你在一个函数中构造了一个\",{\"1\":{\"12\":1}}],[\"根据这些数据成员我们就能很轻松的猜测出\",{\"1\":{\"107\":1}}],[\"根据我们的描述\",{\"1\":{\"58\":1}}],[\"根据作业情况\",{\"1\":{\"1\":1}}],[\"根本不需要最外部\",{\"1\":{\"12\":1}}],[\"由它调用\",{\"1\":{\"16\":1}}],[\"由调用方进行处理\",{\"1\":{\"12\":1}}],[\"由于我们没有对读写操作进行同步\",{\"1\":{\"79\":1}}],[\"由于无法增加计数\",{\"1\":{\"70\":1}}],[\"由于这个系统时钟的限制\",{\"1\":{\"60\":1}}],[\"由于求和不涉及数据竞争之类的问题\",{\"1\":{\"10\":1}}],[\"由于\",{\"1\":{\"10\":2,\"25\":1,\"70\":2,\"108\":1}}],[\"以支持任何的可调用\",{\"1\":{\"115\":1}}],[\"以便在调用\",{\"1\":{\"107\":1}}],[\"以便导出模块\",{\"1\":{\"107\":1}}],[\"以提高执行效率\",{\"1\":{\"81\":1}}],[\"以后任何\",{\"1\":{\"79\":1}}],[\"以原子方式增加或减少指针的值\",{\"1\":{\"78\":1}}],[\"以原子方式增加指针的值\",{\"1\":{\"78\":1}}],[\"以原子方式减少指针的值\",{\"1\":{\"78\":1}}],[\"以原子方式比较并交换指针值\",{\"1\":{\"78\":1}}],[\"以原子方式交换指针值\",{\"1\":{\"78\":1}}],[\"以原子方式存储指针值\",{\"1\":{\"78\":1}}],[\"以原子方式读取指针值\",{\"1\":{\"78\":1}}],[\"以保证计数修改的原子性\",{\"1\":{\"72\":1}}],[\"以使用并发支持库中的\",{\"1\":{\"72\":1}}],[\"以此类推\",{\"1\":{\"71\":1}}],[\"以至于我们可以在这里来再说一条概念\",{\"1\":{\"68\":1}}],[\"以加深对异步任务处理的理解\",{\"1\":{\"67\":1}}],[\"以\",{\"1\":{\"60\":1,\"101\":1,\"108\":1,\"109\":1}}],[\"以供在需要播放提示音的时候调用它\",{\"1\":{\"49\":1}}],[\"以上这段代码\",{\"1\":{\"108\":1}}],[\"以上这段代码可以正常的通过编译\",{\"1\":{\"99\":1}}],[\"以上这段代码是典型的线程不安全\",{\"1\":{\"79\":1}}],[\"以上的示例更多的是泛指\",{\"1\":{\"81\":1}}],[\"以上示例已经足够\",{\"1\":{\"48\":1}}],[\"以上代码使用的就是第二个版本\",{\"1\":{\"47\":1}}],[\"以上代码是线程安全的\",{\"1\":{\"36\":1}}],[\"以上代码\",{\"1\":{\"33\":1}}],[\"以上代码可能导致一些问题\",{\"1\":{\"14\":1}}],[\"以上代码void\",{\"1\":{\"14\":1}}],[\"以确保程序的正确性和可靠性\",{\"1\":{\"85\":1}}],[\"以确保程序的可观察副作用不受影响\",{\"1\":{\"81\":1}}],[\"以确保数据的正确性\",{\"1\":{\"77\":1}}],[\"以确保数据的一致性和正确性\",{\"1\":{\"46\":1}}],[\"以确保在特定平台上原子操作的性能\",{\"1\":{\"75\":1}}],[\"以确保在执行\",{\"1\":{\"48\":1}}],[\"以确保任务在新线程中运行\",{\"1\":{\"65\":1}}],[\"以巩固我们对条件变量的学习\",{\"1\":{\"48\":1}}],[\"以下代码示例展示了如何通过\",{\"1\":{\"62\":1}}],[\"以下是一个例子\",{\"1\":{\"79\":1}}],[\"以下是一个使用\",{\"1\":{\"61\":1}}],[\"以下是一段示例代码\",{\"1\":{\"37\":1}}],[\"以下是局部变量\",{\"1\":{\"40\":1}}],[\"以下内容不会对您构成任何的难度\",{\"1\":{\"18\":1}}],[\"以及一些其它非知识点\",{\"1\":{\"118\":1}}],[\"以及一些外部接口\",{\"1\":{\"116\":1}}],[\"以及一个状态对象\",{\"1\":{\"108\":1}}],[\"以及一个状态成员\",{\"1\":{\"107\":1}}],[\"以及一个元组\",{\"1\":{\"103\":1}}],[\"以及一个转换函数\",{\"1\":{\"75\":1}}],[\"以及关闭还没开始执行的任务\",{\"1\":{\"114\":1}}],[\"以及多态调用\",{\"1\":{\"110\":1}}],[\"以及可能的异常\",{\"1\":{\"107\":1}}],[\"以及可能的测试和调试技术\",{\"1\":{\"81\":1}}],[\"以及给所有互斥量上锁\",{\"1\":{\"103\":1}}],[\"以及方便读者的测试与学习\",{\"1\":{\"94\":1}}],[\"以及\",{\"1\":{\"94\":1,\"114\":1}}],[\"以及这些操作在何种顺序下执行\",{\"1\":{\"73\":1}}],[\"以及实现之复杂\",{\"1\":{\"58\":1}}],[\"以及支持只能移动的类型\",{\"1\":{\"52\":1}}],[\"以及传递调用参数\",{\"1\":{\"52\":1,\"53\":1}}],[\"以及特殊情况可能用到的互斥量\",{\"1\":{\"45\":1}}],[\"以及编译器扩展有助于理解历史上线程存储期的演进\",{\"1\":{\"37\":1}}],[\"以及还有很多其他的时间类型\",{\"1\":{\"15\":1}}],[\"以及线程对象正确析构\",{\"1\":{\"12\":1}}],[\"以及为什么我们要两个\",{\"1\":{\"12\":1}}],[\"以更好地利用当前硬件\",{\"1\":{\"10\":1}}],[\"接下来我们进入\",{\"1\":{\"103\":1}}],[\"接下来我们聊\",{\"1\":{\"52\":1}}],[\"接口高度封装\",{\"1\":{\"114\":1}}],[\"接口设计的方式\",{\"1\":{\"113\":1}}],[\"接口\",{\"1\":{\"66\":1}}],[\"接口的就不再介绍了\",{\"1\":{\"37\":1}}],[\"接收参数的时候直接调用\",{\"1\":{\"52\":1}}],[\"接住了\",{\"1\":{\"12\":1}}],[\"接住了异常\",{\"1\":{\"12\":1}}],[\"接受\",{\"1\":{\"96\":1}}],[\"接受一个可调用对象\",{\"1\":{\"99\":1}}],[\"接受一个整数并返回它的平方\",{\"1\":{\"54\":1}}],[\"接受一个返回\",{\"1\":{\"12\":1}}],[\"接受两个迭代器计算它们范围中对象的和\",{\"1\":{\"10\":1}}],[\"复制构造函数被定义为弃置的\",{\"1\":{\"99\":1}}],[\"复制构造和复制赋值会先读取第一个对象的值\",{\"1\":{\"76\":1}}],[\"复制赋值和复制构造定义为\",{\"1\":{\"13\":1}}],[\"复用之前\",{\"1\":{\"12\":1}}],[\"复杂的\",{\"1\":{\"0\":1}}],[\"顺带的\",{\"1\":{\"12\":1}}],[\"必然有一个线程无法成功上锁\",{\"1\":{\"28\":1}}],[\"必然余\",{\"1\":{\"10\":1}}],[\"必须等待所有线程执行到\",{\"1\":{\"70\":1}}],[\"必须等待线程\",{\"1\":{\"27\":1}}],[\"必须使用\",{\"1\":{\"52\":1}}],[\"必须使用互斥量或类似同步机制进行保护\",{\"1\":{\"51\":1}}],[\"必须和\",{\"1\":{\"35\":1}}],[\"必须得是当前对象拥有互斥量的所有权析构函数才会调用\",{\"1\":{\"31\":1}}],[\"必须同时拿到两部分才能玩\",{\"1\":{\"30\":1}}],[\"必须是当前没有所有权\",{\"1\":{\"31\":1}}],[\"必须是\",{\"1\":{\"12\":1}}],[\"必要标头\",{\"1\":{\"26\":1}}],[\"阻塞到任务执行完毕\",{\"1\":{\"116\":1}}],[\"阻塞调用会将线程挂起一段\",{\"1\":{\"57\":1}}],[\"阻塞\",{\"1\":{\"54\":1,\"79\":1,\"114\":1}}],[\"阻塞直到队列不为空\",{\"1\":{\"48\":2}}],[\"阻塞当前线程\",{\"1\":{\"47\":1}}],[\"阻塞当前线程直到线程对象关联的线程执行完毕\",{\"1\":{\"13\":1}}],[\"阻塞当前线程直至\",{\"1\":{\"12\":1}}],[\"阻塞让其线程执行完毕\",{\"1\":{\"16\":1}}],[\"阻塞什么\",{\"1\":{\"12\":1}}],[\"所做的所有修改\",{\"1\":{\"82\":1}}],[\"所返回的指针\",{\"1\":{\"79\":1}}],[\"所在的函数有异常被抛出\",{\"1\":{\"54\":1}}],[\"所有类型在传递前都进行了\",{\"1\":{\"107\":1}}],[\"所有操作的开始应从\",{\"1\":{\"106\":1}}],[\"所有原子类型都有一个\",{\"1\":{\"75\":1}}],[\"所有界面与设置均通过代码控制\",{\"1\":{\"63\":1}}],[\"所有元素已被弹出\",{\"1\":{\"48\":1}}],[\"所有具有线程局部存储期的非局部变量的初始化\",{\"1\":{\"43\":1}}],[\"所有权才会得到释放\",{\"1\":{\"35\":1}}],[\"所有权\",{\"1\":{\"32\":1}}],[\"所有权也可以在函数内部传递\",{\"1\":{\"16\":1}}],[\"所谓的线程安全\",{\"1\":{\"79\":1}}],[\"所谓的线程停止只是一种基于用户代码的控制机制\",{\"1\":{\"21\":1}}],[\"所谓的在不同作用域传递互斥量\",{\"1\":{\"32\":2}}],[\"所关联的线程正常的执行完毕以及线程对象的正常析构\",{\"1\":{\"13\":1}}],[\"所标识的线程结束其执行\",{\"1\":{\"12\":1}}],[\"所以请您捐赠了可以选择备注\",{\"1\":{\"119\":1}}],[\"所以参数的传递其实是按值复制\",{\"1\":{\"116\":1}}],[\"所以只需要一个提供一个外部接口\",{\"1\":{\"116\":1}}],[\"所以只对元素个数大于\",{\"1\":{\"10\":1}}],[\"所以用\",{\"1\":{\"102\":1}}],[\"所以即使是\",{\"1\":{\"97\":1,\"106\":1}}],[\"所以我一直在强调\",{\"1\":{\"81\":1}}],[\"所以我们添加一个约束让其不能选择到我们的有参构造\",{\"1\":{\"99\":1}}],[\"所以我们使用了\",{\"1\":{\"54\":1}}],[\"所以我们可以使用\",{\"1\":{\"52\":1,\"75\":1}}],[\"所以我们不额外提及\",{\"1\":{\"45\":1}}],[\"所以我们能写出如下代码\",{\"1\":{\"31\":1}}],[\"所以我们前面的代码可以改写为\",{\"1\":{\"30\":1}}],[\"所以我们甚至可以在刚讲完\",{\"1\":{\"10\":1}}],[\"所以多次运行时可能会看到一些无序的打印\",{\"1\":{\"79\":1}}],[\"所以很直观\",{\"1\":{\"67\":1}}],[\"所以假设有类型\",{\"1\":{\"60\":1}}],[\"所以你需要注意移动\",{\"1\":{\"55\":1}}],[\"所以执行新任务是否创建新线程\",{\"1\":{\"52\":1}}],[\"所以如果不使用\",{\"1\":{\"52\":1}}],[\"所以如果你好好学习了上一章\",{\"1\":{\"24\":1}}],[\"所以通常首选std\",{\"1\":{\"47\":1}}],[\"所以增加了\",{\"1\":{\"47\":1}}],[\"所以以上代码存在问题\",{\"1\":{\"56\":1}}],[\"所以以上代码可以随意更换这两个互斥量\",{\"1\":{\"34\":1}}],[\"所以以下函数在多线程运行是线程安全的\",{\"1\":{\"36\":1}}],[\"所以提供了std\",{\"1\":{\"35\":1}}],[\"所以依然必须得使用互斥量进行保护\",{\"1\":{\"34\":1}}],[\"所以为了效率\",{\"1\":{\"34\":1}}],[\"所以标准库提供了\",{\"1\":{\"33\":1}}],[\"所以要特别注意互斥量的生存期\",{\"1\":{\"32\":1}}],[\"所以调用者可以在这个锁保护的范围内执行代码\",{\"1\":{\"32\":1}}],[\"所以正常的用法其实是\",{\"1\":{\"31\":1}}],[\"所以抛出异常\",{\"1\":{\"31\":1}}],[\"所以\",{\"1\":{\"31\":1,\"58\":1}}],[\"所以可以直接传递给\",{\"1\":{\"31\":1}}],[\"所以可称作\",{\"1\":{\"16\":1}}],[\"所以没办法确定外部要做什么\",{\"1\":{\"30\":1}}],[\"所以后的\",{\"1\":{\"30\":1}}],[\"所以死锁\",{\"1\":{\"30\":1}}],[\"所以在等待\",{\"1\":{\"30\":1}}],[\"所以在本教程中\",{\"1\":{\"3\":1}}],[\"所以有的时候你可能会看到一些这样的代码\",{\"1\":{\"27\":1}}],[\"所以有两次移动构造\",{\"1\":{\"14\":1}}],[\"所以完全有可能函数\",{\"1\":{\"14\":1}}],[\"所以产生编译错误\",{\"1\":{\"14\":1}}],[\"所以总而言之\",{\"1\":{\"12\":1}}],[\"所以这个线程只处理平均数量的元素\",{\"1\":{\"10\":1}}],[\"所以这个线程会多分配一个元素\",{\"1\":{\"10\":1}}],[\"所以还定义了一个对象\",{\"1\":{\"10\":1}}],[\"认为这样可以确保被分离的线程在这里阻塞执行完\",{\"1\":{\"12\":1}}],[\"之间的包含关系示意图\",{\"1\":{\"107\":1,\"108\":1}}],[\"之类的函数进行初始化\",{\"1\":{\"106\":1}}],[\"之类的环境\",{\"1\":{\"66\":1}}],[\"之类的就行\",{\"1\":{\"15\":1}}],[\"之所以多个线程通过\",{\"1\":{\"90\":1}}],[\"之所以说\",{\"1\":{\"45\":1}}],[\"之所以说是\",{\"1\":{\"45\":1}}],[\"之所以我们看着抽象是因为这里的形参是无名的\",{\"1\":{\"12\":1}}],[\"之前已经详细描述过了\",{\"1\":{\"108\":1}}],[\"之前的例子中我们一直使用\",{\"1\":{\"56\":1}}],[\"之前\",{\"1\":{\"53\":1,\"76\":1}}],[\"之前呢\",{\"1\":{\"37\":1}}],[\"之前锁住互斥量\",{\"1\":{\"30\":1}}],[\"之后重置期待计数为构造中指定的值\",{\"1\":{\"71\":1}}],[\"之后通过\",{\"1\":{\"54\":1}}],[\"之后\",{\"1\":{\"12\":1}}],[\"应该如此\",{\"1\":{\"102\":1}}],[\"应该在所有场景中使用\",{\"1\":{\"12\":1}}],[\"应该也会提到\",{\"1\":{\"10\":1}}],[\"因其高能效和低功耗特点广泛应用于移动设备\",{\"1\":{\"85\":1}}],[\"因其强大的性能被广泛应用于桌面电脑\",{\"1\":{\"85\":1}}],[\"因其任务之间的相关性\",{\"1\":{\"72\":1}}],[\"因此我们使用了\",{\"1\":{\"115\":1}}],[\"因此我们也只需要关注第二个版本了\",{\"1\":{\"107\":1}}],[\"因此这种操作没有实际意义\",{\"1\":{\"79\":1}}],[\"因此不需要重试\",{\"1\":{\"77\":1}}],[\"因此需要在循环中重试\",{\"1\":{\"77\":1}}],[\"因此在某些情况下可能不适合对时间间隔进行精确测量\",{\"1\":{\"58\":1}}],[\"因此适用于需要保持时间顺序和不受系统时间变化影响的应用场景\",{\"1\":{\"58\":1}}],[\"因此一个周期为\",{\"1\":{\"58\":1}}],[\"因此它们不会共享同一个对象\",{\"1\":{\"36\":1}}],[\"因此就会产生条件竞争\",{\"1\":{\"33\":1}}],[\"因此有更好的性能和更少的竞争\",{\"1\":{\"27\":1}}],[\"因此当多个线程同时访问并修改\",{\"1\":{\"25\":1}}],[\"因此\",{\"1\":{\"12\":1,\"13\":1,\"36\":1,\"38\":1,\"48\":1,\"49\":1,\"60\":1,\"61\":1,\"76\":1,\"79\":2,\"81\":1,\"106\":1}}],[\"因为析构函数并不是阻塞直到执行完所有任务\",{\"1\":{\"114\":1}}],[\"因为如果是\",{\"1\":{\"109\":1}}],[\"因为返回\",{\"1\":{\"107\":1}}],[\"因为已经将参数传递给了线程\",{\"1\":{\"99\":1}}],[\"因为内存对齐\",{\"1\":{\"98\":1}}],[\"因为并发支持库的很多设施其实现是较为简单的\",{\"1\":{\"93\":1}}],[\"因为不同的\",{\"1\":{\"81\":1}}],[\"因为不见得你能教会他们\",{\"1\":{\"33\":1}}],[\"因为是副本\",{\"1\":{\"79\":1}}],[\"因为是线程池\",{\"1\":{\"52\":1}}],[\"因为这些操作仅影响控制块中的引用计数\",{\"1\":{\"79\":1}}],[\"因为它是\",{\"1\":{\"79\":1}}],[\"因为它在等待锁的过程中不会主动放弃\",{\"1\":{\"76\":1}}],[\"因为它有转换函数\",{\"1\":{\"75\":1}}],[\"因为它们的复制构造与复制赋值运算符被定义为弃置的\",{\"1\":{\"75\":1}}],[\"因为它们是线程不安全的\",{\"1\":{\"62\":1}}],[\"因为它们都在等待对方释放互斥量\",{\"1\":{\"30\":1}}],[\"因为传入的函数对象它不是\",{\"1\":{\"71\":1}}],[\"因为我们分配给每个线程的输出任务就是如此\",{\"1\":{\"71\":1}}],[\"因为我们的函数中的参数是引用\",{\"1\":{\"14\":1}}],[\"因为只有三个线程能成功调用\",{\"1\":{\"68\":1}}],[\"因为有\",{\"1\":{\"67\":1}}],[\"因为有潜在的条件竞争\",{\"1\":{\"33\":1}}],[\"因为一分钟等于\",{\"1\":{\"58\":1}}],[\"因为无限期地等待事件发生可能会导致性能下降或资源浪费\",{\"1\":{\"57\":1}}],[\"因为移动操作标志着所有权的转移\",{\"1\":{\"55\":1}}],[\"因为临时对象的生存期就在这一行\",{\"1\":{\"52\":1}}],[\"因为修改函数和等待函数共用一个互斥量\",{\"1\":{\"47\":1}}],[\"因为线程被线程池复用\",{\"1\":{\"38\":1}}],[\"因为线程变量\",{\"1\":{\"38\":1}}],[\"因为异常代表操作失败\",{\"1\":{\"33\":1}}],[\"因为对象还没构造\",{\"1\":{\"33\":1}}],[\"因为代码是外部提供的\",{\"1\":{\"30\":1}}],[\"因为在大部分时间里\",{\"1\":{\"30\":1}}],[\"因为前面已经使用了\",{\"1\":{\"30\":1}}],[\"因为互斥量上锁顺序不同\",{\"1\":{\"30\":1}}],[\"因为你要是不抛出\",{\"1\":{\"12\":1}}],[\"因为程序员必须确保所有创建的线程正常退出\",{\"1\":{\"12\":1}}],[\"因为\",{\"1\":{\"12\":1,\"13\":1,\"31\":2,\"36\":1,\"53\":1,\"71\":1,\"75\":1,\"79\":1,\"99\":1}}],[\"因为要执行的任务非常之多\",{\"1\":{\"5\":1}}],[\"放弃线程的所有权不是一种选择\",{\"1\":{\"12\":1}}],[\"放弃了对线程资源的所有权\",{\"1\":{\"12\":1}}],[\"通知所有线程退出\",{\"1\":{\"116\":1}}],[\"通知线程新的音频\",{\"1\":{\"49\":1}}],[\"通知播放线程执行任务\",{\"1\":{\"49\":1}}],[\"通知等待的线程\",{\"1\":{\"47\":1}}],[\"通过静态成员函数\",{\"1\":{\"115\":1}}],[\"通过\",{\"1\":{\"107\":1,\"114\":1}}],[\"通过完美转发机制将其转发给实际的异步任务\",{\"1\":{\"107\":1}}],[\"通过使用合适的内存序\",{\"1\":{\"82\":1}}],[\"通过使用\",{\"1\":{\"79\":1}}],[\"通过返回非原子值进行赋值\",{\"1\":{\"77\":1}}],[\"通过批处理等技术\",{\"1\":{\"75\":1}}],[\"通过互斥量的保护\",{\"1\":{\"74\":1}}],[\"通过这种方式\",{\"1\":{\"68\":1}}],[\"通过初始化该信号量为\",{\"1\":{\"68\":1}}],[\"通过实际操作理解代码效果\",{\"1\":{\"67\":1}}],[\"通过显示的线程\",{\"1\":{\"65\":1}}],[\"通过条件变量和互斥量确保播放线程\",{\"1\":{\"49\":1}}],[\"通过另一线程触发等待事件的机制是最基本的唤醒方式\",{\"1\":{\"47\":1}}],[\"通过函数\",{\"1\":{\"37\":1}}],[\"通过调用\",{\"1\":{\"21\":1,\"70\":1,\"115\":1}}],[\"通过该对象来管理线程\",{\"1\":{\"11\":1}}],[\"通常是硬件并发能力的两倍\",{\"1\":{\"114\":1}}],[\"通常都会是最新的\",{\"1\":{\"94\":1}}],[\"通常只是用作构建一些库设施\",{\"1\":{\"76\":1}}],[\"通常的实现是直接保有一个\",{\"1\":{\"72\":1}}],[\"通常用于简单直接的需求\",{\"1\":{\"70\":1}}],[\"通常用于描述锁定的范围大小\",{\"1\":{\"27\":1}}],[\"通常情况下\",{\"1\":{\"57\":1}}],[\"通常它有更好的性能\",{\"1\":{\"68\":1}}],[\"通常它会和\",{\"1\":{\"53\":1}}],[\"通常它比裸调用\",{\"1\":{\"30\":1}}],[\"通常其本身也是线程安全的\",{\"1\":{\"45\":1}}],[\"通常会使用同步机制\",{\"1\":{\"45\":1}}],[\"通常\",{\"1\":{\"44\":1,\"45\":1,\"75\":1}}],[\"通常建议优先\",{\"1\":{\"31\":1}}],[\"通常说某个特定的线程正持有这个锁\",{\"1\":{\"26\":1}}],[\"通常需要线程执行的函数中有一些系统调用\",{\"1\":{\"23\":1}}],[\"通常占\",{\"1\":{\"20\":1}}],[\"通常非常不推荐使用\",{\"1\":{\"12\":1}}],[\"正确的用法如下\",{\"1\":{\"79\":1}}],[\"正在执行\",{\"1\":{\"62\":1,\"64\":1}}],[\"正在延迟执行\",{\"1\":{\"59\":1}}],[\"正常情况会保证传入的可调用对象只调用一次\",{\"1\":{\"33\":1}}],[\"正常\",{\"1\":{\"31\":1}}],[\"正常上锁\",{\"1\":{\"31\":1}}],[\"正常析构\",{\"1\":{\"12\":1,\"16\":2}}],[\"正是通过\",{\"1\":{\"9\":1}}],[\"正是任务切换使得这些后台任务可以运行\",{\"1\":{\"5\":1}}],[\"造成未定义行为\",{\"1\":{\"12\":1}}],[\"访问悬空引用\",{\"1\":{\"12\":1}}],[\"用做调用\",{\"1\":{\"103\":1}}],[\"用了就没事\",{\"1\":{\"67\":1}}],[\"用户非要做这些事情也是防不住的\",{\"1\":{\"29\":1}}],[\"用来学习再好不过\",{\"1\":{\"116\":1}}],[\"用来应对我们传入的函数对象返回类型的三种情况\",{\"1\":{\"107\":1}}],[\"用来初始化数据成员\",{\"1\":{\"107\":1}}],[\"用来指定原子操作的内存顺序\",{\"1\":{\"83\":1}}],[\"用来引用互斥量\",{\"1\":{\"27\":1}}],[\"用来管理互斥量的上锁与解锁\",{\"1\":{\"27\":1}}],[\"用来计算\",{\"1\":{\"10\":1}}],[\"用一段对比代码为你直观的展示互斥量的作用\",{\"1\":{\"26\":1}}],[\"用于网络和低级\",{\"1\":{\"114\":1}}],[\"用于执行多个任务而无需频繁地创建和销毁线程\",{\"1\":{\"112\":1}}],[\"用于异步执行任务\",{\"1\":{\"107\":1}}],[\"用于在异步任务和等待任务之间进行同步\",{\"1\":{\"107\":1}}],[\"用于在队列为空时等待\",{\"1\":{\"48\":1}}],[\"用于标记此函数的返回值不应被忽略\",{\"1\":{\"107\":1}}],[\"用于等待关联任务的完成并获取其返回值\",{\"1\":{\"106\":1}}],[\"用于指示当前线程中抛出的异常\",{\"1\":{\"54\":1}}],[\"用于存储异步任务中可能发生的异常\",{\"1\":{\"107\":1}}],[\"用于存储计算结果\",{\"1\":{\"54\":1}}],[\"用于存储一个值或一个异常\",{\"1\":{\"54\":1}}],[\"用于获取返回值\",{\"1\":{\"53\":1}}],[\"用于监测\",{\"1\":{\"50\":1}}],[\"用于计数\",{\"1\":{\"50\":1}}],[\"用于加载和播放音频文件\",{\"1\":{\"49\":1}}],[\"用于保护共享资源\",{\"1\":{\"116\":1}}],[\"用于保护共享数据的访问\",{\"1\":{\"47\":1}}],[\"用于保护队列操作的独占访问\",{\"1\":{\"48\":1}}],[\"用于线程间的同步\",{\"1\":{\"47\":1,\"116\":1}}],[\"用于声明具有线程存储期的对象\",{\"1\":{\"37\":1}}],[\"用于搭配\",{\"1\":{\"33\":1}}],[\"用于通知线程应该停止执行\",{\"1\":{\"23\":1}}],[\"用于调用这个可变参数的可调用对象\",{\"1\":{\"103\":1}}],[\"用于调用\",{\"1\":{\"12\":1}}],[\"执行延迟函数\",{\"1\":{\"109\":1}}],[\"执行函数的类型要求\",{\"1\":{\"99\":1}}],[\"执行递增操作\",{\"1\":{\"74\":1}}],[\"执行传递的\",{\"1\":{\"53\":1}}],[\"执行策略毫无区别\",{\"1\":{\"52\":1}}],[\"执行的过程\",{\"1\":{\"49\":1}}],[\"执行的时候\",{\"1\":{\"30\":2}}],[\"执行一些任务\",{\"1\":{\"32\":1}}],[\"执行多少次\",{\"1\":{\"27\":1}}],[\"执行多个任务\",{\"1\":{\"5\":1}}],[\"执行完任务\",{\"1\":{\"70\":1}}],[\"执行完里面的代码\",{\"1\":{\"27\":1}}],[\"执行完毕后继续休眠\",{\"1\":{\"112\":1}}],[\"执行完毕后休眠\",{\"1\":{\"112\":1}}],[\"执行完毕\",{\"1\":{\"13\":1}}],[\"执行我们的\",{\"1\":{\"26\":1}}],[\"执行了一半\",{\"1\":{\"25\":2}}],[\"执行\",{\"1\":{\"12\":1,\"30\":2,\"53\":1}}],[\"执行什么呢\",{\"1\":{\"12\":1}}],[\"执行任务\",{\"1\":{\"12\":1}}],[\"主模板的讲解\",{\"1\":{\"103\":1}}],[\"主模板\",{\"1\":{\"102\":1,\"103\":1}}],[\"主\",{\"1\":{\"68\":4}}],[\"主要目的有两个\",{\"1\":{\"108\":1}}],[\"主要是用\",{\"1\":{\"103\":1}}],[\"主要是通过两层包装\",{\"1\":{\"100\":1}}],[\"主要是复杂性和需求\",{\"1\":{\"31\":1}}],[\"主要的内容就是我们上面讲的类模板\",{\"1\":{\"59\":1}}],[\"主要的难度其实在于对\",{\"1\":{\"10\":1}}],[\"主要在于类型之多\",{\"1\":{\"58\":1}}],[\"主要用于内核开发和追求极致性能的高并发场景\",{\"1\":{\"44\":1}}],[\"主线程用于处理\",{\"1\":{\"61\":1}}],[\"主线程延时\",{\"1\":{\"15\":1}}],[\"主线程不等待\",{\"1\":{\"12\":1}}],[\"主线程\",{\"1\":{\"12\":1}}],[\"可调用对象\",{\"1\":{\"107\":1}}],[\"可见\",{\"0\":{\"82\":1},\"1\":{\"82\":2}}],[\"可选的内存序包括\",{\"1\":{\"75\":3}}],[\"可用任何满足可复制构造\",{\"1\":{\"75\":1}}],[\"可复用的线程屏障\",{\"1\":{\"69\":1}}],[\"可能导致一些任务没有执行\",{\"1\":{\"114\":1}}],[\"可能导致许多问题\",{\"1\":{\"25\":1}}],[\"可能不同\",{\"1\":{\"100\":1}}],[\"可能不是最大\",{\"1\":{\"68\":1}}],[\"可能考虑使用复制初始化\",{\"1\":{\"95\":1}}],[\"可能没有接触过\",{\"1\":{\"93\":1}}],[\"可能也听说过\",{\"1\":{\"85\":1}}],[\"可能比原子操作更高效\",{\"1\":{\"75\":1}}],[\"可能产生大于\",{\"1\":{\"72\":1}}],[\"可能就无法直接猜测其意图\",{\"1\":{\"70\":1}}],[\"可能有多个线程都需要耗时的异步任务的返回值\",{\"1\":{\"56\":1}}],[\"可能有多个线程都需要此任务的返回值\",{\"1\":{\"56\":1}}],[\"可能影响业务正常的执行任务的流程\",{\"1\":{\"49\":1}}],[\"可能别的翻译单元\",{\"1\":{\"32\":1}}],[\"可能的运行结果是\",{\"1\":{\"48\":1}}],[\"可能的运行结果\",{\"1\":{\"28\":1,\"71\":1,\"116\":1}}],[\"可能会导致数据竞争\",{\"1\":{\"25\":1}}],[\"可能会发生未定义的行为\",{\"1\":{\"25\":1}}],[\"可能会有一些难以理解的地方\",{\"1\":{\"23\":1}}],[\"可能抛出异常\",{\"1\":{\"13\":1}}],[\"可能悬空引用\",{\"1\":{\"12\":1}}],[\"可以参考我们给出的线程池实现增加功能\",{\"1\":{\"117\":1}}],[\"可以传入任务到任务队列\",{\"1\":{\"116\":1}}],[\"可以传递给\",{\"1\":{\"14\":1}}],[\"可以复用的线程集合\",{\"1\":{\"112\":1}}],[\"可以当做是一个池子中存放了一堆线程\",{\"1\":{\"112\":1}}],[\"可以慢慢看\",{\"1\":{\"110\":1}}],[\"可以保证无论任务是\",{\"1\":{\"108\":1}}],[\"可以访问并管理异步任务的状态\",{\"1\":{\"107\":1}}],[\"可以是\",{\"1\":{\"107\":1}}],[\"可以举一个使用\",{\"1\":{\"107\":1}}],[\"可以管理任意个数的互斥量\",{\"1\":{\"103\":1}}],[\"可以阅读使用文档\",{\"1\":{\"94\":1}}],[\"可以确保正确初始化和清理\",{\"1\":{\"100\":1}}],[\"可以确保线程\",{\"1\":{\"82\":1}}],[\"可以确保此时对象处于\",{\"1\":{\"76\":1}}],[\"可以按照一定规则重新安排代码的执行顺序\",{\"1\":{\"81\":1}}],[\"可以\",{\"1\":{\"79\":1}}],[\"可以安全的调用所有成员函数\",{\"1\":{\"79\":1}}],[\"可以避免多余的加载\",{\"1\":{\"77\":1}}],[\"可以应用任何内存顺序\",{\"1\":{\"76\":1}}],[\"可以用来控制在需要的时候\",{\"1\":{\"71\":1}}],[\"可以用来划分任务执行的工作区间\",{\"1\":{\"70\":1}}],[\"可以改变重置的计数值\",{\"1\":{\"71\":1}}],[\"可以改为\",{\"1\":{\"56\":1}}],[\"可以有效控制\",{\"1\":{\"68\":1}}],[\"可以尝试自行优化我们提供的线程池实现\",{\"1\":{\"116\":1}}],[\"可以尝试修改代码\",{\"1\":{\"67\":1}}],[\"可以尝试将函数的第一行与最后一行注释掉以验证这一点\",{\"1\":{\"62\":1}}],[\"可以验证这一点\",{\"1\":{\"65\":1}}],[\"可以直接跳过本节内容\",{\"1\":{\"81\":1}}],[\"可以直接安装\",{\"1\":{\"63\":1}}],[\"可以直接隐式转换\",{\"1\":{\"59\":1}}],[\"可以减去一个时间点\",{\"1\":{\"60\":1}}],[\"可以对两个时间段进行加减乘除\",{\"1\":{\"59\":1}}],[\"可以将元组存储的参数全部拿出\",{\"1\":{\"103\":1}}],[\"可以将不相关的指令重排\",{\"1\":{\"81\":1}}],[\"可以将时间点转换为\",{\"1\":{\"58\":1}}],[\"可以将所有\",{\"1\":{\"30\":1}}],[\"可以选择是否传递一个谓词\",{\"1\":{\"57\":1}}],[\"可以考虑使用下文提到的\",{\"1\":{\"55\":1}}],[\"可以看到\",{\"1\":{\"108\":1}}],[\"可以看出\",{\"1\":{\"55\":1}}],[\"可以看一下时间\",{\"1\":{\"47\":1}}],[\"可以很清楚地理解\",{\"1\":{\"55\":1}}],[\"可以执行后续的操作\",{\"1\":{\"47\":1}}],[\"可以下车了\",{\"1\":{\"47\":1}}],[\"可以获取互斥量的所有权\",{\"1\":{\"32\":1}}],[\"可以利用各种类来进行传递\",{\"1\":{\"32\":1}}],[\"可以在没有被互斥量保护的情况下调用\",{\"1\":{\"29\":1}}],[\"可以根据传入的参数自行推导\",{\"1\":{\"27\":1}}],[\"可以说已经比较了解了\",{\"1\":{\"24\":1}}],[\"可以添加\",{\"1\":{\"21\":1}}],[\"可以再回过头来问问自己是否能够回答这些问题\",{\"1\":{\"17\":1}}],[\"可以观看视频\",{\"1\":{\"14\":1}}],[\"可以隐式转换为被包装对象的引用\",{\"1\":{\"14\":1}}],[\"可以通过\",{\"1\":{\"58\":1}}],[\"可以通过编译\",{\"1\":{\"14\":2,\"52\":1}}],[\"可以通过支付宝赞助白老师\",{\"1\":{\"0\":1}}],[\"可以防止编译器隐式生成\",{\"1\":{\"13\":1}}],[\"可以简化代码并避免引入不必要的局部对象\",{\"1\":{\"12\":1}}],[\"可以使用\",{\"1\":{\"10\":1,\"30\":1,\"34\":1,\"75\":1}}],[\"可以指代线程\",{\"1\":{\"8\":1}}],[\"可以先学习\",{\"1\":{\"0\":1}}],[\"为原子操作指定不同的内存序\",{\"1\":{\"77\":1}}],[\"为就绪为止\",{\"1\":{\"52\":1}}],[\"为队列添加元素\",{\"1\":{\"49\":1}}],[\"为例\",{\"1\":{\"31\":1,\"60\":1}}],[\"为了遍历形参包\",{\"1\":{\"99\":1}}],[\"为了提高性能\",{\"1\":{\"81\":1}}],[\"为了提高代码的可读性\",{\"1\":{\"50\":1}}],[\"为了理解这些概念\",{\"1\":{\"79\":1}}],[\"为了代码的可维护性开发者应遵守标准规定\",{\"1\":{\"71\":1}}],[\"为了防止服务器过载\",{\"1\":{\"68\":1}}],[\"为了避免每次都手动添加路径\",{\"1\":{\"50\":1}}],[\"为了不影响程序的流畅执行\",{\"1\":{\"49\":1}}],[\"为了实现一个线程安全的队列\",{\"1\":{\"48\":1}}],[\"为了保证数据交换的正确性\",{\"1\":{\"30\":1}}],[\"为了观测运行我们可以为\",{\"1\":{\"48\":1}}],[\"为了观测\",{\"1\":{\"13\":1}}],[\"为什么要这样\",{\"1\":{\"103\":1}}],[\"为什么不同\",{\"1\":{\"85\":1}}],[\"为什么满足这些概念就是线程不安全呢\",{\"1\":{\"79\":1}}],[\"为什么\",{\"1\":{\"20\":1}}],[\"为什么需要\",{\"1\":{\"17\":1,\"100\":1}}],[\"为什么还要\",{\"1\":{\"12\":1}}],[\"为\",{\"1\":{\"12\":3,\"20\":1,\"31\":2,\"47\":1,\"68\":1,\"71\":2,\"77\":3,\"108\":1}}],[\"为其处理器引入了全新的\",{\"1\":{\"10\":1}}],[\"此调用后\",{\"1\":{\"99\":1}}],[\"此操作同步于任何后继的取得同一互斥体所有权的锁定操作\",{\"1\":{\"82\":1}}],[\"此操作可能会由于某些硬件的特性而出现假失败\",{\"1\":{\"77\":1}}],[\"此设施来自微软并行模式库\",{\"1\":{\"72\":1}}],[\"此处可阅读部分源码\",{\"1\":{\"114\":1}}],[\"此处根本无需等待它\",{\"1\":{\"109\":1}}],[\"此处是确保输出流在多线程环境中同步\",{\"1\":{\"71\":1}}],[\"此处延时三秒可以方便测试\",{\"1\":{\"68\":1}}],[\"此处获取返回值\",{\"1\":{\"53\":1}}],[\"此处执行任务\",{\"1\":{\"53\":1}}],[\"此处存放作业\",{\"0\":{\"1\":1}}],[\"此策略表示由实现选择到底是否创建线程执行异步任务\",{\"1\":{\"52\":1}}],[\"此外\",{\"1\":{\"50\":1,\"69\":1,\"78\":1,\"81\":1,\"116\":1}}],[\"此线程对\",{\"1\":{\"35\":1}}],[\"此方式也在单例中多见\",{\"1\":{\"33\":1}}],[\"此时再进行操作时就得考虑\",{\"1\":{\"79\":1}}],[\"此时就需要使用\",{\"1\":{\"56\":1}}],[\"此时线程\",{\"1\":{\"27\":1}}],[\"此时线程函数还持有函数局部对象的指针或引用\",{\"1\":{\"12\":1}}],[\"此时可以判断操作是否完成\",{\"1\":{\"15\":1}}],[\"此时我们的\",{\"1\":{\"12\":1}}],[\"此时分离的子线程可能没有执行完毕\",{\"1\":{\"12\":1}}],[\"此时\",{\"1\":{\"12\":1,\"14\":2,\"16\":1,\"25\":1,\"49\":1,\"76\":2,\"77\":1,\"99\":1}}],[\"允许线程等待特定条件\",{\"1\":{\"116\":1}}],[\"允许更灵活的内存优化\",{\"1\":{\"85\":1}}],[\"允许用户原子地操纵\",{\"1\":{\"79\":1}}],[\"允许用户查询特定原子类型的操作是否是通过直接的原子指令实现\",{\"1\":{\"75\":1}}],[\"允许指定成功和失败情况下的内存序\",{\"1\":{\"77\":1}}],[\"允许任何数量的线程阻塞直至期待数量的线程到达\",{\"1\":{\"69\":1}}],[\"允许检查是否有停止请求\",{\"1\":{\"21\":1}}],[\"允许从外部请求线程停止\",{\"1\":{\"21\":1}}],[\"允许其他操作没有价值\",{\"1\":{\"13\":1}}],[\"允许此线程独立的运行\",{\"1\":{\"12\":1}}],[\"允许在每个内核上运行多个线程\",{\"1\":{\"10\":1}}],[\"drop\",{\"1\":{\"71\":6}}],[\"dis\",{\"1\":{\"68\":2}}],[\"distribution<>\",{\"1\":{\"68\":1}}],[\"distance\",{\"1\":{\"10\":6,\"53\":5}}],[\"divide<years\",{\"1\":{\"59\":1}}],[\"days\",{\"1\":{\"59\":3}}],[\"date\",{\"1\":{\"30\":1}}],[\"data\",{\"1\":{\"18\":2,\"29\":14,\"32\":3,\"34\":4,\"48\":13,\"56\":22,\"77\":2,\"79\":14}}],[\"dll\",{\"1\":{\"32\":1}}],[\"d\",{\"1\":{\"29\":2}}],[\"doing\",{\"1\":{\"76\":2}}],[\"down\",{\"1\":{\"70\":4}}],[\"done\",{\"1\":{\"60\":2,\"108\":1}}],[\"don\",{\"1\":{\"27\":1,\"31\":1,\"102\":2,\"103\":1}}],[\"do\",{\"1\":{\"18\":3,\"29\":3,\"76\":1,\"99\":1,\"107\":1,\"109\":1}}],[\"duration>\",{\"1\":{\"60\":1}}],[\"duration<>\",{\"1\":{\"59\":1,\"60\":1}}],[\"duration<double>>\",{\"1\":{\"59\":1}}],[\"duration<double>\",{\"1\":{\"59\":3}}],[\"duration<long\",{\"1\":{\"59\":5,\"60\":1}}],[\"duration<int\",{\"1\":{\"58\":1,\"59\":6}}],[\"duration\",{\"1\":{\"15\":1,\"57\":1,\"58\":2,\"59\":9,\"60\":3}}],[\"demo\",{\"1\":{\"116\":1}}],[\"destructible\",{\"1\":{\"108\":1}}],[\"destructor\",{\"1\":{\"27\":1,\"102\":1}}],[\"device\",{\"1\":{\"68\":1}}],[\"dev\",{\"1\":{\"50\":2}}],[\"detail\",{\"1\":{\"114\":2}}],[\"detach\",{\"1\":{\"12\":12,\"13\":1,\"14\":3,\"18\":2}}],[\"detectioncompleted\",{\"1\":{\"50\":1}}],[\"decltype\",{\"1\":{\"103\":3}}],[\"declspec\",{\"1\":{\"37\":4}}],[\"decay\",{\"1\":{\"21\":1,\"99\":10,\"100\":3,\"107\":9,\"116\":5}}],[\"deadlock\",{\"1\":{\"31\":1}}],[\"defines\",{\"1\":{\"108\":1}}],[\"define\",{\"1\":{\"75\":11}}],[\"deferred\",{\"1\":{\"52\":8,\"59\":5,\"107\":16,\"108\":15,\"109\":1,\"110\":1}}],[\"defer\",{\"1\":{\"31\":5}}],[\"default\",{\"1\":{\"18\":1,\"52\":1,\"75\":3,\"76\":1,\"102\":1,\"107\":5,\"108\":3,\"109\":2,\"114\":3,\"116\":2}}],[\"delete\",{\"1\":{\"13\":2,\"14\":1,\"27\":2,\"36\":9,\"37\":1,\"45\":2,\"52\":1,\"75\":2,\"95\":1,\"99\":2,\"102\":6,\"107\":2,\"108\":2,\"116\":2}}],[\"还可以设置内存次序\",{\"1\":{\"81\":1}}],[\"还提供了以下操作\",{\"1\":{\"78\":1}}],[\"还支持手动控制任务优先级\",{\"1\":{\"115\":1}}],[\"还支持\",{\"1\":{\"75\":1}}],[\"还使用\",{\"1\":{\"72\":1}}],[\"还未关联\",{\"1\":{\"52\":1}}],[\"还能扩展用于其他类似的后台任务场景\",{\"1\":{\"49\":1}}],[\"还能够确保主线程的顺畅运行\",{\"1\":{\"49\":1}}],[\"还讲了一下互斥量所有权转移\",{\"1\":{\"45\":1}}],[\"还有一个\",{\"1\":{\"54\":1}}],[\"还有一个就是表示对象是否拥有互斥量所有权的\",{\"1\":{\"31\":1}}],[\"还有它的形参是函数类型而不是函数指针类型\",{\"1\":{\"12\":1}}],[\"还引入了一个新的\",{\"1\":{\"27\":1}}],[\"还没有元素\",{\"1\":{\"25\":1}}],[\"还是简单的多\",{\"1\":{\"104\":1}}],[\"还是那句话\",{\"1\":{\"104\":1}}],[\"还是通过锁来实现\",{\"1\":{\"75\":1}}],[\"还是\",{\"1\":{\"12\":1,\"100\":1,\"108\":1}}],[\"合并这两个操作无法保证其原子性\",{\"1\":{\"76\":1}}],[\"合并\",{\"1\":{\"12\":1}}],[\"决定它的执行策略\",{\"1\":{\"12\":1}}],[\"即都是异步执行\",{\"1\":{\"107\":1}}],[\"即未来体\",{\"1\":{\"106\":1}}],[\"即不可改变可观察的副作用\",{\"1\":{\"81\":1}}],[\"即代表出现了假失败\",{\"1\":{\"77\":1}}],[\"即要求\",{\"1\":{\"71\":1}}],[\"即可\",{\"1\":{\"53\":1,\"58\":1,\"59\":1}}],[\"即可在析构的时候正常解锁\",{\"1\":{\"31\":1}}],[\"即是否当前关联任务\",{\"1\":{\"52\":1}}],[\"即任务执行完毕\",{\"1\":{\"52\":1}}],[\"即输出提示信息\",{\"1\":{\"47\":1}}],[\"即初始化只有一次\",{\"1\":{\"33\":1}}],[\"即表示当前对象拥有互斥量的所有权\",{\"1\":{\"31\":1}}],[\"即线程对象有活跃线程\",{\"1\":{\"12\":1}}],[\"即\",{\"1\":{\"12\":1,\"25\":1,\"31\":1,\"33\":1,\"36\":1,\"47\":1,\"57\":1,\"64\":1,\"71\":1,\"77\":1,\"100\":1,\"108\":1}}],[\"即使程序在某些平台上运行正常\",{\"1\":{\"81\":1}}],[\"即使通过多次\",{\"1\":{\"81\":1}}],[\"即使这些\",{\"1\":{\"79\":1}}],[\"即使这些实例是同一对象的副本且共享所有权也是如此\",{\"1\":{\"72\":1,\"79\":1}}],[\"即使使用原子类型无法带来效率的提升\",{\"1\":{\"75\":1}}],[\"即使它们是用了锁\",{\"1\":{\"75\":1}}],[\"即使在系统休眠或时钟调整的情况下\",{\"1\":{\"58\":1}}],[\"即使涉及到全局的状态\",{\"1\":{\"45\":1}}],[\"即使\",{\"1\":{\"36\":1,\"74\":1,\"90\":1}}],[\"即使多个线程同时访问\",{\"1\":{\"33\":1}}],[\"即使会改变执行顺序\",{\"1\":{\"25\":1}}],[\"即使你早已学习乃至使用\",{\"1\":{\"23\":1}}],[\"即使你从来没使用过\",{\"1\":{\"0\":1}}],[\"即使我们还没有深入讲述它\",{\"1\":{\"79\":1}}],[\"即使我们的成员函数形参类型为引用\",{\"1\":{\"14\":1}}],[\"即使我还没有为你讲述概念\",{\"1\":{\"12\":1}}],[\"即使是非静态成员函数没有使用任何数据成员\",{\"1\":{\"14\":1}}],[\"即使函数中的参数是引用\",{\"1\":{\"14\":1}}],[\"即使函数\",{\"1\":{\"13\":1}}],[\"表现如同\",{\"1\":{\"90\":1}}],[\"表示线程池中的线程数量\",{\"1\":{\"116\":1}}],[\"表示线程对象目前没有关联活跃线程\",{\"1\":{\"9\":1}}],[\"表示正确执行的状态给\",{\"1\":{\"107\":1}}],[\"表示的是后文将使用的\",{\"1\":{\"107\":1}}],[\"表示延迟执行\",{\"1\":{\"107\":1}}],[\"表示异步执行\",{\"1\":{\"107\":1}}],[\"表示任务的执行策略\",{\"1\":{\"107\":1}}],[\"表示属性\",{\"1\":{\"107\":1}}],[\"表示调用该可调用对象所需的参数类型\",{\"1\":{\"107\":1}}],[\"表示可调用对象的类型\",{\"1\":{\"107\":1}}],[\"表示资源不可用\",{\"1\":{\"99\":1}}],[\"表示新的执行线程开始执行\",{\"1\":{\"99\":1}}],[\"表示状态\",{\"1\":{\"75\":1}}],[\"表示时间间隔\",{\"1\":{\"58\":1}}],[\"表示此元素已被使用\",{\"1\":{\"49\":1}}],[\"表示有新的提示音需要播放\",{\"1\":{\"49\":1}}],[\"表示是否到达目的地\",{\"1\":{\"47\":1}}],[\"表示到达目的地\",{\"1\":{\"47\":2}}],[\"表示没有互斥量所有权\",{\"1\":{\"31\":1}}],[\"表达式必须声明为\",{\"1\":{\"71\":1}}],[\"表达式或其它函数对象\",{\"1\":{\"53\":1}}],[\"表达式线程安全考虑两方面\",{\"1\":{\"36\":1}}],[\"表达式线程安全要考虑三方面\",{\"1\":{\"36\":1}}],[\"表达式\",{\"1\":{\"12\":1,\"53\":1,\"71\":1}}],[\"再\",{\"1\":{\"114\":1}}],[\"再执行\",{\"1\":{\"109\":3}}],[\"再执行任务\",{\"1\":{\"53\":1}}],[\"再循环等待任务执行完毕\",{\"1\":{\"108\":1}}],[\"再结合源码讲解会更加简单直观\",{\"1\":{\"93\":1}}],[\"再放到线程中执行\",{\"1\":{\"53\":1}}],[\"再休眠结束后再对互斥量上锁\",{\"1\":{\"47\":1}}],[\"再次检查是否有存储的异常\",{\"1\":{\"109\":1}}],[\"再次检查异常\",{\"1\":{\"109\":1}}],[\"再次上锁是错误的\",{\"1\":{\"35\":1}}],[\"再次调用\",{\"1\":{\"12\":1,\"54\":1}}],[\"再多下去就冗余了\",{\"1\":{\"33\":1}}],[\"再上锁\",{\"1\":{\"30\":2}}],[\"再锁定\",{\"1\":{\"30\":1}}],[\"再试想\",{\"1\":{\"30\":1}}],[\"再调用\",{\"1\":{\"16\":1,\"79\":1}}],[\"再然后\",{\"1\":{\"15\":1}}],[\"再将函数类型写成函数指针类型\",{\"1\":{\"12\":1}}],[\"再加上我们的余数\",{\"1\":{\"10\":1}}],[\"文本颜色\",{\"1\":{\"64\":1}}],[\"文本居中\",{\"1\":{\"64\":2}}],[\"文档\",{\"1\":{\"12\":1,\"38\":1,\"72\":1,\"79\":1}}],[\"文件夹中\",{\"1\":{\"1\":1,\"63\":1,\"117\":1}}],[\"文件名\",{\"1\":{\"1\":1}}],[\"省略了形参的名称\",{\"1\":{\"12\":1}}],[\"和之前一样的\",{\"1\":{\"106\":1}}],[\"和形参包的索引\",{\"1\":{\"99\":1}}],[\"和一系列参数\",{\"1\":{\"99\":1}}],[\"和编译器行为\",{\"1\":{\"82\":1}}],[\"和编译器的具体行为\",{\"1\":{\"82\":1}}],[\"和编译器可能对内存操作的顺序有不同的处理\",{\"1\":{\"81\":1}}],[\"和清除\",{\"1\":{\"76\":1}}],[\"和预处理宏来让程序执行不同的代码\",{\"1\":{\"75\":1}}],[\"和线程\",{\"1\":{\"74\":1}}],[\"和等待\",{\"1\":{\"68\":1}}],[\"和每一个任务进行关联的\",{\"1\":{\"53\":1}}],[\"和各种变量进行了一个对比\",{\"1\":{\"45\":1}}],[\"和pthread\",{\"1\":{\"37\":1}}],[\"和相关的函数\",{\"1\":{\"37\":1}}],[\"和\",{\"0\":{\"85\":1},\"1\":{\"12\":2,\"21\":2,\"22\":1,\"23\":1,\"26\":1,\"27\":1,\"31\":1,\"33\":1,\"34\":1,\"37\":1,\"47\":1,\"50\":1,\"51\":1,\"55\":1,\"57\":1,\"63\":1,\"69\":1,\"71\":2,\"75\":2,\"77\":2,\"78\":2,\"82\":1,\"85\":3,\"90\":1,\"99\":2,\"100\":2,\"102\":1,\"103\":2,\"107\":3,\"109\":1,\"110\":1,\"116\":1}}],[\"和单线程效率差距越明显\",{\"1\":{\"10\":1}}],[\"声明了一个类型形参包\",{\"1\":{\"102\":1}}],[\"声明都会被跳过\",{\"1\":{\"43\":1}}],[\"声明\",{\"1\":{\"12\":1}}],[\"且是我们本章重点\",{\"1\":{\"99\":1}}],[\"且任何这些访问使用了\",{\"1\":{\"79\":1}}],[\"且任一线程使用\",{\"1\":{\"72\":1,\"79\":1}}],[\"且只能减少计数\",{\"1\":{\"70\":1}}],[\"且方便我们获取返回值罢了\",{\"1\":{\"53\":1}}],[\"且不说创建线程也需要大量时间\",{\"1\":{\"49\":1}}],[\"且它在主函数执行之前进行初始化\",{\"1\":{\"42\":1}}],[\"且运行时很多地方都依赖这个数据结构需要读取\",{\"1\":{\"34\":1}}],[\"且本文不是详尽的文档\",{\"1\":{\"33\":1}}],[\"且\",{\"1\":{\"31\":1,\"52\":1}}],[\"且等待另一个线程的互斥量解锁\",{\"1\":{\"30\":1}}],[\"且写了个函数类型\",{\"1\":{\"12\":1}}],[\"且使用的都是\",{\"1\":{\"12\":1}}],[\"小括号初始化\",{\"1\":{\"12\":1}}],[\"函数时\",{\"1\":{\"108\":1}}],[\"函数在被唤醒后\",{\"1\":{\"108\":1}}],[\"函数执行保有的函数对象\",{\"1\":{\"107\":1}}],[\"函数执行后\",{\"1\":{\"47\":1}}],[\"函数对象抛出异常就记录\",{\"1\":{\"107\":3,\"109\":1}}],[\"函数对象类型\",{\"1\":{\"71\":1}}],[\"函数根据启动模式\",{\"1\":{\"107\":1}}],[\"函数形参\",{\"1\":{\"107\":1}}],[\"函数之前\",{\"1\":{\"100\":1}}],[\"函数创建线程\",{\"1\":{\"100\":1}}],[\"函数就会返回一个包装对象\",{\"1\":{\"100\":1}}],[\"函数就是直接返回\",{\"1\":{\"68\":1}}],[\"函数就是\",{\"1\":{\"68\":1}}],[\"函数就是我们先前说的\",{\"1\":{\"68\":1}}],[\"函数来启动一个线程\",{\"1\":{\"99\":1}}],[\"函数很简单\",{\"1\":{\"99\":1}}],[\"函数也允许内存序作为给定函数的参数\",{\"1\":{\"78\":1}}],[\"函数会返回\",{\"1\":{\"76\":1}}],[\"函数会在新线程中执行\",{\"1\":{\"12\":1}}],[\"函数等价于\",{\"1\":{\"70\":1}}],[\"函数原子地将计数减至\",{\"1\":{\"70\":1}}],[\"函数阻塞子线程\",{\"1\":{\"70\":1}}],[\"函数要求\",{\"1\":{\"55\":1}}],[\"函数后\",{\"1\":{\"55\":1}}],[\"函数获取这个异常\",{\"1\":{\"54\":1}}],[\"函数外\",{\"1\":{\"54\":1}}],[\"函数设置\",{\"1\":{\"54\":1}}],[\"函数即可\",{\"1\":{\"52\":1}}],[\"函数中调用\",{\"1\":{\"76\":1,\"108\":1}}],[\"函数中的等待结束\",{\"1\":{\"47\":1}}],[\"函数中\",{\"1\":{\"47\":2}}],[\"函数退出也能正常解锁\",{\"1\":{\"30\":1}}],[\"函数的修改操作同一时间只能有一个线程在执行\",{\"1\":{\"27\":1}}],[\"函数却是可以被打断的\",{\"1\":{\"25\":1}}],[\"函数返回一个\",{\"1\":{\"107\":1}}],[\"函数返回类型\",{\"1\":{\"107\":1}}],[\"函数返回\",{\"1\":{\"16\":1,\"60\":1}}],[\"函数模板提交任务到线程池中\",{\"1\":{\"114\":1}}],[\"函数模板返回一个已经初始化且具有共享状态的\",{\"1\":{\"106\":1}}],[\"函数模板有两个重载\",{\"1\":{\"52\":1}}],[\"函数模板\",{\"1\":{\"14\":1,\"52\":1,\"107\":1}}],[\"函数\",{\"1\":{\"13\":1,\"14\":1,\"21\":2,\"27\":1,\"30\":3,\"33\":1,\"51\":1,\"53\":1,\"57\":1,\"71\":1,\"76\":2,\"77\":2,\"99\":1,\"107\":1,\"109\":1,\"115\":1}}],[\"函数继续执行下面别的代码\",{\"1\":{\"12\":1}}],[\"函数结束的时候会解锁互斥量\",{\"1\":{\"32\":1}}],[\"函数结束对象析构的时候会解锁互斥量\",{\"1\":{\"31\":1}}],[\"函数结束\",{\"1\":{\"12\":1}}],[\"函数定义\",{\"1\":{\"12\":1}}],[\"函数名为\",{\"1\":{\"12\":1}}],[\"函数名可以隐式转换到指向它的函数指针\",{\"1\":{\"12\":1}}],[\"函数声明\",{\"1\":{\"12\":2}}],[\"函数可以获得我们当前硬件支持的并发线程数量\",{\"1\":{\"10\":1}}],[\"类维护着一个\",{\"1\":{\"70\":1}}],[\"类而已\",{\"1\":{\"53\":1}}],[\"类模板对其进行封装和管理\",{\"1\":{\"107\":1}}],[\"类模板的包装\",{\"1\":{\"107\":1}}],[\"类模板是对\",{\"1\":{\"107\":1}}],[\"类模板不仅只能使用标准库为我们定义的特化类型\",{\"1\":{\"75\":1}}],[\"类模板\",{\"1\":{\"53\":1,\"54\":1,\"58\":1,\"107\":2}}],[\"类模板实参推导\",{\"1\":{\"27\":1}}],[\"类似于\",{\"1\":{\"77\":1}}],[\"类似\",{\"1\":{\"51\":1,\"56\":1,\"90\":1}}],[\"类似问题应该是看你自己的\",{\"1\":{\"7\":1}}],[\"类是\",{\"1\":{\"47\":1}}],[\"类型只有一个数据成员\",{\"1\":{\"107\":1}}],[\"类型本身不重要\",{\"1\":{\"107\":1}}],[\"类型参数调用\",{\"1\":{\"107\":1}}],[\"类型别名\",{\"1\":{\"107\":1}}],[\"类型和一个参数序列的索引序列\",{\"1\":{\"99\":1}}],[\"类型擦除\",{\"1\":{\"79\":2}}],[\"类型进行构造\",{\"1\":{\"77\":1}}],[\"类型\",{\"1\":{\"55\":1,\"59\":1,\"72\":1,\"75\":2,\"99\":1,\"107\":2,\"115\":1}}],[\"类型的成员\",{\"1\":{\"108\":1}}],[\"类型的可调用对象传递一个\",{\"1\":{\"107\":1}}],[\"类型的可调用对象后得到的结果类型\",{\"1\":{\"107\":1}}],[\"类型的构造函数实现即可\",{\"1\":{\"107\":1}}],[\"类型的状态成员\",{\"1\":{\"107\":1}}],[\"类型的实现就是保有了\",{\"1\":{\"107\":1}}],[\"类型的指针\",{\"1\":{\"107\":1}}],[\"类型的指针进行的\",{\"1\":{\"78\":1}}],[\"类型的内部实现\",{\"1\":{\"107\":1}}],[\"类型的原子操作一定有锁的\",{\"1\":{\"75\":1}}],[\"类型的原子操作一定无锁的\",{\"1\":{\"75\":1}}],[\"类型的原子操作有时是无锁的\",{\"1\":{\"75\":1}}],[\"类型的计数\",{\"1\":{\"70\":1}}],[\"类型的值\",{\"1\":{\"58\":1}}],[\"类型的参数\",{\"1\":{\"54\":1}}],[\"类型的对象需要以\",{\"1\":{\"76\":1}}],[\"类型的对象\",{\"1\":{\"31\":1,\"99\":1,\"107\":2}}],[\"类型的对象作为参数\",{\"1\":{\"14\":1}}],[\"类型是我们的核心\",{\"1\":{\"108\":1}}],[\"类型是\",{\"1\":{\"12\":1}}],[\"类名\",{\"1\":{\"12\":1,\"14\":1}}],[\"类\",{\"1\":{\"11\":1,\"30\":1}}],[\"罢了\",{\"1\":{\"10\":1,\"108\":1}}],[\"无非就是内部的返回引用实际按指针操作\",{\"1\":{\"108\":1}}],[\"无非是使用条件变量\",{\"1\":{\"116\":1}}],[\"无非是把返回引用类型的可调用对象返回的引用获取地址传递给\",{\"1\":{\"107\":1}}],[\"无非是最后调用\",{\"1\":{\"100\":1}}],[\"无非是用容器存储线程对象管理\",{\"1\":{\"10\":1}}],[\"无符号\",{\"1\":{\"98\":1}}],[\"无锁的原子操作可以显著减少锁的开销和竞争\",{\"1\":{\"75\":1}}],[\"无需进行其他\",{\"1\":{\"63\":1}}],[\"无需使用\",{\"1\":{\"59\":1}}],[\"无需同步\",{\"1\":{\"44\":2}}],[\"无法退出\",{\"1\":{\"76\":1}}],[\"无法增加计数\",{\"1\":{\"70\":1}}],[\"无法点击\",{\"1\":{\"62\":1}}],[\"无法通过编译\",{\"1\":{\"52\":1}}],[\"无法加载音频文件\",{\"1\":{\"49\":1}}],[\"无法使用\",{\"1\":{\"37\":1}}],[\"无法正确析构\",{\"1\":{\"9\":1}}],[\"无死锁\",{\"1\":{\"30\":1}}],[\"无序且操作可能被打断\",{\"1\":{\"18\":1}}],[\"最终清理\",{\"1\":{\"114\":1}}],[\"最终在\",{\"1\":{\"107\":1}}],[\"最终将\",{\"1\":{\"100\":1}}],[\"最终调用时使用\",{\"1\":{\"100\":1}}],[\"最终输出的是以毫秒作为单位\",{\"1\":{\"60\":1}}],[\"最简单的方式就是先看它的数据成员有什么\",{\"1\":{\"98\":1,\"107\":1}}],[\"最简单有效的使用是\",{\"1\":{\"51\":1}}],[\"最经典与常见的两种\",{\"1\":{\"85\":1}}],[\"最基本的预处理器判断\",{\"1\":{\"75\":1}}],[\"最基础的概念就是如此\",{\"1\":{\"73\":1}}],[\"最大值\",{\"1\":{\"72\":1}}],[\"最大的不同是\",{\"1\":{\"71\":1}}],[\"最大并发数为\",{\"1\":{\"68\":1}}],[\"最后再来稍微聊一聊提供的\",{\"1\":{\"79\":1}}],[\"最后强调一下\",{\"1\":{\"75\":1}}],[\"最后介绍了\",{\"1\":{\"72\":1}}],[\"最后介绍了一下线程存储期\",{\"1\":{\"45\":1}}],[\"最后请注意\",{\"1\":{\"71\":1}}],[\"最后汇总的时候写一个循环\",{\"1\":{\"53\":1}}],[\"最后打印了\",{\"1\":{\"25\":1}}],[\"最后一行调用\",{\"1\":{\"12\":1}}],[\"最后一行是\",{\"1\":{\"10\":1}}],[\"最后进行\",{\"1\":{\"10\":1}}],[\"最多可并行执行\",{\"1\":{\"10\":1}}],[\"同一个\",{\"1\":{\"56\":1}}],[\"同一时刻只能有一个线程执行\",{\"1\":{\"27\":1}}],[\"同一时间只有一个线程执行\",{\"1\":{\"26\":1}}],[\"同步于\",{\"1\":{\"82\":1}}],[\"同步于lock\",{\"1\":{\"82\":1}}],[\"同步设施\",{\"1\":{\"46\":1}}],[\"同步操作对于并发编程至关重要\",{\"1\":{\"72\":1}}],[\"同步操作\",{\"0\":{\"46\":1},\"1\":{\"46\":1}}],[\"同步开销\",{\"1\":{\"44\":1}}],[\"同步的\",{\"1\":{\"25\":1}}],[\"同时最为明显重要的三个设施是\",{\"1\":{\"107\":1}}],[\"同时保持高度的灵活性和扩展性\",{\"1\":{\"85\":1}}],[\"同时也要考虑代码的简洁性\",{\"1\":{\"75\":1}}],[\"同时也能解释其使用与学习中的各种问题\",{\"1\":{\"17\":1}}],[\"同时另一线程从它读取\",{\"1\":{\"75\":1}}],[\"同时开始修改变量\",{\"1\":{\"74\":1}}],[\"同时\",{\"1\":{\"67\":1,\"72\":1,\"94\":1}}],[\"同时我们讲述了一些避免死锁的方法和技术\",{\"1\":{\"45\":1}}],[\"同时扩展知识面\",{\"1\":{\"37\":1}}],[\"同时它还提供一个有额外std\",{\"1\":{\"27\":1}}],[\"同时上锁\",{\"1\":{\"27\":1}}],[\"同时阻止了移动等函数的隐式定义\",{\"1\":{\"27\":1}}],[\"同时会阻止移动构造函数和移动赋值运算符的隐式定义\",{\"1\":{\"13\":1}}],[\"同时执行任务\",{\"1\":{\"5\":1}}],[\"同样使用了\",{\"1\":{\"107\":1}}],[\"同样通过完美转发机制进行转发\",{\"1\":{\"107\":1}}],[\"同样\",{\"1\":{\"48\":1}}],[\"同样可能产生数据竞争\",{\"1\":{\"45\":1}}],[\"同样可以作为构造\",{\"1\":{\"12\":1}}],[\"同样的\",{\"1\":{\"35\":1,\"54\":1,\"60\":1}}],[\"同样支持\",{\"1\":{\"34\":1}}],[\"同样允许在对象销毁之前就解锁互斥量\",{\"1\":{\"32\":1}}],[\"同样因为\",{\"1\":{\"10\":1}}],[\"时可以正确地等待任务完成\",{\"1\":{\"108\":1}}],[\"时能够重新抛出异常\",{\"1\":{\"107\":1}}],[\"时调用我们构造\",{\"1\":{\"71\":1}}],[\"时转换为秒时没问题的\",{\"1\":{\"59\":1}}],[\"时钟节拍被指定为\",{\"1\":{\"58\":1}}],[\"时钟节拍\",{\"1\":{\"58\":1}}],[\"时钟被视为时间信息的来源\",{\"1\":{\"58\":1}}],[\"时钟\",{\"0\":{\"58\":1},\"1\":{\"57\":1}}],[\"时间库的知识\",{\"1\":{\"72\":1}}],[\"时间库支持四则运算\",{\"1\":{\"59\":1}}],[\"时间和硬件系统等关系极大\",{\"1\":{\"60\":1}}],[\"时间部分最简单的就是时间段\",{\"1\":{\"59\":1}}],[\"时间类型\",{\"1\":{\"58\":1}}],[\"时间点的知识也就足够了\",{\"1\":{\"60\":1}}],[\"时间点也支持加减以及比较操作\",{\"1\":{\"60\":1}}],[\"时间点顾名思义就是时间中的一个点\",{\"1\":{\"60\":1}}],[\"时间点可用\",{\"1\":{\"60\":1}}],[\"时间点\",{\"0\":{\"60\":1},\"1\":{\"57\":2}}],[\"时间段对象可以通过\",{\"1\":{\"59\":1}}],[\"时间段有隐式转换\",{\"1\":{\"59\":1}}],[\"时间段\",{\"0\":{\"59\":1},\"1\":{\"57\":2}}],[\"时间片\",{\"1\":{\"76\":1}}],[\"时间片持续运行\",{\"1\":{\"48\":1}}],[\"时间片让其他线程执行\",{\"1\":{\"15\":1}}],[\"时间会大大减少\",{\"1\":{\"15\":1}}],[\"时间\",{\"1\":{\"15\":1,\"57\":1}}],[\"时\",{\"1\":{\"10\":3,\"25\":1,\"76\":1,\"82\":1,\"107\":1}}],[\"每种时钟类型都提供了四种不同的信息\",{\"1\":{\"58\":1}}],[\"每个操作都可以指定内存顺序\",{\"1\":{\"76\":1}}],[\"每个\",{\"1\":{\"45\":1}}],[\"每个处理器只访问自己的变量副本\",{\"1\":{\"39\":1}}],[\"每个线程从任务队列中获取任务并执行\",{\"1\":{\"116\":1}}],[\"每个线程读写的指针也不是同一个\",{\"1\":{\"79\":1}}],[\"每个线程拥有它自身的对象实例\",{\"1\":{\"43\":1}}],[\"每个线程拥有自己独立的对象实例\",{\"1\":{\"37\":1}}],[\"每个线程\",{\"1\":{\"41\":1}}],[\"每个线程都有一个\",{\"1\":{\"56\":1}}],[\"每个线程都有其自己的\",{\"1\":{\"36\":1}}],[\"每个线程都抢着完成自己的任务\",{\"1\":{\"25\":1}}],[\"每个线程只需要使用\",{\"1\":{\"33\":1}}],[\"每个线程只持有一个锁\",{\"1\":{\"30\":1}}],[\"每个线程的处理情况如下\",{\"1\":{\"10\":1}}],[\"每一个常量都表示不同的内存次序\",{\"1\":{\"83\":1}}],[\"每一个线程都有独立的\",{\"1\":{\"37\":1}}],[\"每一站都能知道\",{\"1\":{\"47\":1}}],[\"每一位开发者赞助\",{\"1\":{\"0\":1}}],[\"每次调用都有独立实例\",{\"1\":{\"41\":1}}],[\"每次递归都会锁定互斥量\",{\"1\":{\"35\":1}}],[\"每次用户打开程序的时候\",{\"1\":{\"34\":1}}],[\"28\",{\"1\":{\"71\":1}}],[\"26\",{\"1\":{\"71\":1}}],[\"23\",{\"1\":{\"71\":1}}],[\"22\",{\"1\":{\"71\":1}}],[\"21\",{\"1\":{\"71\":1}}],[\"2px\",{\"1\":{\"64\":1}}],[\"2>\",{\"1\":{\"58\":1}}],[\"25>\",{\"1\":{\"58\":1}}],[\"25\",{\"1\":{\"58\":1,\"71\":1}}],[\"27\",{\"1\":{\"50\":1,\"71\":1}}],[\"29376\",{\"1\":{\"116\":2}}],[\"29\",{\"1\":{\"21\":1,\"71\":1}}],[\"24\",{\"1\":{\"20\":1,\"71\":1}}],[\"2我们写出了函数形参名称\",{\"1\":{\"12\":1}}],[\"2\",{\"1\":{\"10\":7,\"12\":5,\"21\":1,\"28\":2,\"30\":3,\"33\":1,\"35\":1,\"38\":1,\"39\":2,\"47\":3,\"48\":7,\"50\":1,\"53\":3,\"56\":1,\"58\":1,\"70\":3,\"71\":5,\"75\":2,\"77\":1,\"78\":3,\"81\":1,\"114\":5,\"115\":1,\"116\":4}}],[\"2022\",{\"1\":{\"92\":1}}],[\"20240731\",{\"1\":{\"1\":1}}],[\"2024\",{\"1\":{\"1\":1,\"10\":1,\"21\":1,\"57\":1}}],[\"200ms\",{\"1\":{\"21\":1}}],[\"20\",{\"1\":{\"10\":2,\"71\":1,\"75\":1,\"115\":1}}],[\"假设略微了解操作系统基本知识\",{\"1\":{\"93\":1}}],[\"假设您不了解其它语言的协程实现\",{\"1\":{\"92\":1}}],[\"假设您对协程这个概念一无所知\",{\"1\":{\"92\":1}}],[\"假设返回\",{\"1\":{\"77\":1}}],[\"假设我们有一个\",{\"1\":{\"68\":1}}],[\"假设一个时钟一秒有\",{\"1\":{\"58\":1}}],[\"假设需要执行一个耗时任务并获取其返回值\",{\"1\":{\"52\":1}}],[\"假设5秒后到达目的地\",{\"1\":{\"47\":1}}],[\"假设你正在一辆夜间运行的地铁上\",{\"1\":{\"47\":1}}],[\"假设线程\",{\"1\":{\"27\":1,\"71\":1}}],[\"假设有两个线程运行\",{\"1\":{\"77\":1}}],[\"假设有线程\",{\"1\":{\"27\":1}}],[\"假设有\",{\"1\":{\"10\":1}}],[\"假设开发者对操作系统等知识有基本了解\",{\"1\":{\"7\":1}}],[\"求和即可\",{\"1\":{\"10\":1}}],[\"到此也就足够了\",{\"1\":{\"115\":1}}],[\"到此也就可以了\",{\"1\":{\"110\":1}}],[\"到此就可以了\",{\"1\":{\"107\":1}}],[\"到此\",{\"1\":{\"48\":1,\"53\":1,\"60\":1,\"81\":1}}],[\"到底读取到多少不确定\",{\"1\":{\"74\":1}}],[\"到底哪个线程会抢到\",{\"1\":{\"48\":1}}],[\"到底是如何做到的\",{\"1\":{\"17\":1,\"100\":1}}],[\"到达目的地\",{\"1\":{\"47\":1}}],[\"到达设置的位置就提醒\",{\"1\":{\"47\":1}}],[\"到站的时候有人或者其它东西能将你叫醒\",{\"1\":{\"47\":1}}],[\"到\",{\"1\":{\"10\":1}}],[\"是通过执行\",{\"1\":{\"109\":1}}],[\"是先调用了\",{\"1\":{\"109\":1}}],[\"是调用\",{\"1\":{\"107\":1}}],[\"是为了确保延迟执行\",{\"1\":{\"108\":1}}],[\"是为了配合\",{\"1\":{\"107\":1}}],[\"是为了支持只能移动的类型能够使用\",{\"1\":{\"55\":1}}],[\"是相同的\",{\"1\":{\"107\":1}}],[\"是默认按值传递与\",{\"1\":{\"107\":1}}],[\"是用来管理一个共享状态的类模板\",{\"1\":{\"106\":1}}],[\"是无稽之谈\",{\"1\":{\"100\":1,\"101\":1,\"104\":1}}],[\"是无锁类型\",{\"1\":{\"75\":1}}],[\"是重中之重\",{\"1\":{\"99\":1}}],[\"是不是很熟悉\",{\"1\":{\"102\":1}}],[\"是不是线程安全\",{\"1\":{\"79\":1}}],[\"是不可复制的\",{\"1\":{\"99\":1}}],[\"是如何创建线程传递参数的\",{\"1\":{\"97\":1}}],[\"是如何构造的\",{\"1\":{\"97\":1}}],[\"是如何做到的呢\",{\"1\":{\"27\":1}}],[\"是强一致性模型的一种\",{\"1\":{\"85\":1}}],[\"是绝对安全的\",{\"1\":{\"83\":1}}],[\"是比较严格的内存模型\",{\"1\":{\"81\":1}}],[\"是原子操作\",{\"1\":{\"79\":1}}],[\"是最基本的整数原子类型\",{\"1\":{\"77\":1}}],[\"是最简单的原子类型\",{\"1\":{\"76\":1}}],[\"是最小\",{\"1\":{\"72\":1}}],[\"是编译期常量\",{\"1\":{\"75\":1}}],[\"是非原子操作\",{\"1\":{\"74\":1}}],[\"是我们设置的非类型模板参数\",{\"1\":{\"68\":1}}],[\"是我们学习\",{\"1\":{\"23\":1}}],[\"是在主线程运行的\",{\"1\":{\"65\":1}}],[\"是分钟类型\",{\"1\":{\"58\":1}}],[\"是按引用传递\",{\"1\":{\"56\":1}}],[\"是可见的\",{\"1\":{\"82\":1}}],[\"是可复制的\",{\"1\":{\"56\":1}}],[\"是可调用对象\",{\"1\":{\"53\":1}}],[\"是只能移动的\",{\"1\":{\"56\":1}}],[\"是只能移动不可复制的类\",{\"1\":{\"32\":1}}],[\"是系统调度决定的\",{\"1\":{\"48\":1}}],[\"是指针所指向的对象类型\",{\"1\":{\"78\":1}}],[\"是指门背后用来关门的棍子\",{\"1\":{\"70\":1}}],[\"是指提供稳定\",{\"1\":{\"58\":1}}],[\"是指在计算机科学和信息技术中的一种操作方式\",{\"1\":{\"46\":1}}],[\"是指拥有静态或线程存储期的局部变量\",{\"1\":{\"45\":1}}],[\"是因为\",{\"1\":{\"52\":1,\"90\":1}}],[\"是因为理论上线程变量一样可能产生数据竞争\",{\"1\":{\"45\":1}}],[\"是因为局部对象的构造\",{\"1\":{\"45\":1}}],[\"是操作系统内核功能\",{\"1\":{\"44\":1}}],[\"是局部对象\",{\"1\":{\"36\":1}}],[\"是全局对象\",{\"1\":{\"36\":1}}],[\"是安全的\",{\"1\":{\"34\":1}}],[\"是没有数据竞争的\",{\"1\":{\"34\":1}}],[\"是简单合理的做法\",{\"1\":{\"33\":1}}],[\"是线程协调机制\",{\"1\":{\"69\":1}}],[\"是线程安全的\",{\"1\":{\"36\":1}}],[\"是线程安全的吗\",{\"0\":{\"36\":1}}],[\"是线程安全\",{\"1\":{\"33\":1}}],[\"是线程分离\",{\"1\":{\"12\":1}}],[\"是查看指针是否为空\",{\"1\":{\"33\":1}}],[\"是灵活的\",{\"1\":{\"32\":1}}],[\"是自动发生的\",{\"1\":{\"32\":1}}],[\"是有虚函数的\",{\"1\":{\"107\":1}}],[\"是有\",{\"1\":{\"31\":1}}],[\"是互斥量中的一种尝试上锁的方式\",{\"1\":{\"28\":1}}],[\"是否为\",{\"1\":{\"108\":1}}],[\"是否已经调用过\",{\"1\":{\"107\":1}}],[\"是否能够看到线程\",{\"1\":{\"82\":1}}],[\"是否总是无锁\",{\"1\":{\"75\":1}}],[\"是否收到了停止请求\",{\"1\":{\"21\":1}}],[\"是否对未捕获的异常进行任何栈回溯由实现定义\",{\"1\":{\"13\":1}}],[\"是一次性的\",{\"1\":{\"55\":1,\"56\":2}}],[\"是一种抽象的指代\",{\"1\":{\"112\":1}}],[\"是一种开源的精简指令集计算\",{\"1\":{\"85\":1}}],[\"是一种精简指令集计算\",{\"1\":{\"85\":1}}],[\"是一种强一致性模型\",{\"1\":{\"85\":1}}],[\"是一种复杂指令集计算\",{\"1\":{\"85\":1}}],[\"是一种非常古老的机制\",{\"1\":{\"37\":1}}],[\"是一种用来保护临界区\",{\"1\":{\"26\":1}}],[\"是一种发送取消请求的函数\",{\"1\":{\"21\":1}}],[\"是一个指针类型\",{\"1\":{\"108\":1}}],[\"是一个空类\",{\"1\":{\"107\":1}}],[\"是一个类型形参包\",{\"1\":{\"107\":1}}],[\"是一个类模板\",{\"1\":{\"102\":1}}],[\"是一个可变参数类模板\",{\"1\":{\"102\":1}}],[\"是一个宏\",{\"1\":{\"99\":1,\"107\":2}}],[\"是一个结构体\",{\"1\":{\"98\":1}}],[\"是一个枚举类型\",{\"1\":{\"83\":1}}],[\"是一个原子指针类型\",{\"1\":{\"78\":1}}],[\"是一个加载操作\",{\"1\":{\"77\":1}}],[\"是一个存储操作\",{\"1\":{\"77\":1}}],[\"是一个\",{\"1\":{\"76\":1,\"77\":1}}],[\"是一个轻量同步原语\",{\"1\":{\"68\":1}}],[\"是一个古老而广泛应用的同步设施\",{\"1\":{\"68\":1}}],[\"是一个分数类模板\",{\"1\":{\"58\":1}}],[\"是一个跨平台的\",{\"1\":{\"50\":1,\"114\":1}}],[\"是一个数组对象\",{\"1\":{\"14\":1}}],[\"是一个整体\",{\"1\":{\"14\":1}}],[\"是一个函数类型\",{\"1\":{\"12\":1}}],[\"是一个返回类型为\",{\"1\":{\"12\":1}}],[\"是打印时间格式\",{\"1\":{\"15\":1}}],[\"是第一个被销毁的\",{\"1\":{\"13\":1}}],[\"是每个线程分配的任务\",{\"1\":{\"10\":1}}],[\"是当前硬件支持的并发线程的值\",{\"1\":{\"10\":1}}],[\"是\",{\"1\":{\"10\":1,\"12\":2,\"15\":1,\"31\":2,\"35\":1,\"59\":2,\"68\":1,\"82\":1,\"112\":1,\"114\":1,\"115\":1}}],[\"是很快的\",{\"1\":{\"5\":1}}],[\"定义一个信号量\",{\"1\":{\"68\":1}}],[\"定义一个函数用作打印任务\",{\"1\":{\"9\":1}}],[\"定义在\",{\"1\":{\"68\":1}}],[\"定义的\",{\"1\":{\"59\":1}}],[\"定义的别名\",{\"1\":{\"59\":1}}],[\"定义了一个元组类型\",{\"1\":{\"99\":1}}],[\"定义了一个别名\",{\"1\":{\"10\":1}}],[\"定义了很多种时间类型\",{\"1\":{\"58\":1}}],[\"定义\",{\"1\":{\"12\":1,\"107\":2}}],[\"汇总线程的计算结果\",{\"1\":{\"10\":1,\"53\":1}}],[\"elif\",{\"1\":{\"75\":1}}],[\"else\",{\"1\":{\"21\":1,\"28\":2,\"75\":2,\"77\":2,\"79\":2,\"99\":2,\"100\":1,\"108\":1,\"109\":1}}],[\"e\",{\"1\":{\"54\":4,\"55\":2}}],[\"empty\",{\"1\":{\"48\":4,\"49\":3,\"116\":2}}],[\"emplace\",{\"1\":{\"10\":1,\"18\":2,\"25\":3,\"26\":2,\"53\":2,\"68\":1,\"70\":1,\"71\":2,\"109\":5,\"116\":4}}],[\"exec\",{\"1\":{\"115\":1}}],[\"exit\",{\"1\":{\"99\":1,\"107\":1,\"109\":4}}],[\"exchang\",{\"1\":{\"77\":1,\"79\":1}}],[\"exchanged\",{\"1\":{\"75\":3}}],[\"exchange\",{\"1\":{\"75\":8,\"77\":16,\"78\":3,\"99\":2}}],[\"exception`\",{\"1\":{\"108\":1}}],[\"exception\",{\"1\":{\"33\":2,\"54\":15,\"55\":4,\"107\":9,\"108\":12,\"109\":2}}],[\"extensions\",{\"1\":{\"37\":1}}],[\"extern\",{\"1\":{\"32\":5}}],[\"expopt\",{\"1\":{\"107\":1}}],[\"export\",{\"1\":{\"27\":1,\"59\":1,\"102\":1,\"107\":3,\"108\":1}}],[\"explorer\",{\"1\":{\"94\":1}}],[\"explicit\",{\"1\":{\"13\":1,\"18\":2,\"21\":1,\"27\":1,\"99\":1,\"102\":6,\"103\":2}}],[\"expected↩︎\",{\"1\":{\"90\":1}}],[\"expected\",{\"1\":{\"77\":11,\"90\":1}}],[\"errc\",{\"1\":{\"31\":2,\"55\":1,\"107\":7,\"108\":3,\"109\":1}}],[\"error2\",{\"1\":{\"107\":6,\"108\":3,\"109\":1}}],[\"error\",{\"1\":{\"16\":1,\"31\":2,\"33\":1,\"52\":2,\"54\":3,\"99\":3,\"116\":1}}],[\"erase\",{\"1\":{\"25\":1}}],[\"enum\",{\"1\":{\"50\":1,\"83\":2,\"115\":1}}],[\"enable\",{\"1\":{\"21\":1,\"99\":3}}],[\"endif\",{\"1\":{\"75\":1,\"100\":1}}],[\"end\",{\"1\":{\"10\":7,\"27\":2,\"34\":1,\"53\":4,\"60\":2,\"71\":2,\"81\":4,\"107\":3,\"109\":1}}],[\"endl\",{\"1\":{\"9\":2,\"15\":3,\"21\":1,\"28\":3,\"35\":2,\"47\":1,\"48\":2,\"49\":1,\"54\":1,\"56\":8,\"68\":1,\"75\":8,\"79\":4}}],[\"创建并启动指定数量的线程\",{\"1\":{\"116\":1}}],[\"创建并启动线程\",{\"1\":{\"10\":1}}],[\"创建任务对象\",{\"1\":{\"115\":1}}],[\"创建\",{\"1\":{\"110\":1}}],[\"创建的索引形参包\",{\"1\":{\"99\":1}}],[\"创建控件\",{\"1\":{\"64\":1}}],[\"创建一个有\",{\"1\":{\"116\":2}}],[\"创建一个包含\",{\"1\":{\"114\":1}}],[\"创建一个\",{\"1\":{\"54\":1,\"75\":1}}],[\"创建一个线程来执行异步任务\",{\"1\":{\"53\":1}}],[\"创建线程池\",{\"1\":{\"114\":1}}],[\"创建线程池时\",{\"1\":{\"114\":1}}],[\"创建线程池对象\",{\"1\":{\"114\":1}}],[\"创建线程\",{\"1\":{\"100\":1}}],[\"创建线程执行异步任务\",{\"1\":{\"52\":1}}],[\"创建线程对象\",{\"1\":{\"12\":1}}],[\"创建异步任务获取返回值\",{\"0\":{\"52\":1}}],[\"创建了一个独占指针\",{\"1\":{\"99\":1}}],[\"创建了一个条件变量\",{\"1\":{\"47\":1}}],[\"创建了一个互斥量\",{\"1\":{\"47\":1}}],[\"创建了一个块作用域\",{\"1\":{\"27\":1}}],[\"创建了一个线程对象\",{\"1\":{\"9\":1}}],[\"创建局部对象\",{\"1\":{\"12\":1}}],[\">activethreadcount\",{\"1\":{\"115\":1}}],[\">addwidget\",{\"1\":{\"64\":3}}],[\">start\",{\"1\":{\"115\":2}}],[\">setlayout\",{\"1\":{\"64\":1}}],[\">setsizepolicy\",{\"1\":{\"64\":2}}],[\">setstylesheet\",{\"1\":{\"64\":3}}],[\">setmaximumwidth\",{\"1\":{\"64\":2}}],[\">setminimumsize\",{\"1\":{\"64\":2}}],[\">setvalue\",{\"1\":{\"62\":1,\"64\":1}}],[\">settext\",{\"1\":{\"62\":2,\"64\":2}}],[\">setrange\",{\"1\":{\"62\":1,\"64\":2}}],[\">setenabled\",{\"1\":{\"62\":2,\"64\":2}}],[\">second\",{\"1\":{\"34\":1}}],[\">maxthreadcount\",{\"1\":{\"115\":1}}],[\">get\",{\"1\":{\"79\":3,\"116\":1}}],[\">>\",{\"1\":{\"53\":2,\"107\":4,\"116\":2}}],[\">unlock\",{\"1\":{\"31\":1}}],[\">lock\",{\"1\":{\"31\":2}}],[\">do\",{\"1\":{\"29\":1,\"33\":3}}],[\">=\",{\"1\":{\"10\":1}}],[\">\",{\"1\":{\"10\":1,\"21\":1,\"35\":2,\"47\":1,\"53\":9,\"55\":1,\"60\":1,\"71\":2,\"77\":1,\"78\":5,\"99\":9,\"100\":1,\"102\":2,\"103\":2,\"107\":27,\"108\":9,\"109\":3,\"116\":2}}],[\"virtual\",{\"1\":{\"108\":2}}],[\"visual\",{\"1\":{\"63\":1,\"92\":1}}],[\"vmajornext\",{\"1\":{\"52\":1,\"107\":1}}],[\"vue\",{\"1\":{\"50\":1}}],[\"variable>\",{\"1\":{\"47\":1,\"116\":1}}],[\"variable\",{\"1\":{\"47\":11,\"48\":1,\"49\":1,\"57\":1,\"60\":1,\"107\":1,\"116\":3}}],[\"variables\",{\"1\":{\"39\":1}}],[\"val\",{\"1\":{\"109\":7}}],[\"valid\",{\"1\":{\"52\":3,\"55\":2,\"56\":1,\"107\":6,\"108\":2}}],[\"validate\",{\"1\":{\"31\":3}}],[\"value++\",{\"1\":{\"21\":1}}],[\"value\",{\"1\":{\"10\":10,\"21\":1,\"34\":2,\"48\":8,\"53\":9,\"54\":9,\"55\":3,\"75\":10,\"77\":2,\"79\":13,\"107\":7,\"108\":17,\"109\":9}}],[\"v\",{\"1\":{\"25\":6,\"36\":2,\"85\":5,\"97\":1,\"106\":1}}],[\"v<std\",{\"1\":{\"99\":1,\"103\":1}}],[\"v<\",{\"1\":{\"71\":1,\"99\":1,\"107\":1,\"108\":4,\"109\":1}}],[\"v<decay\",{\"1\":{\"21\":1}}],[\"v<remove\",{\"1\":{\"21\":1}}],[\"vector\",{\"1\":{\"18\":1,\"25\":3}}],[\"vector<int>\",{\"1\":{\"27\":1}}],[\"vector<int>v\",{\"1\":{\"25\":1}}],[\"vector<joining\",{\"1\":{\"18\":1}}],[\"vector<std\",{\"1\":{\"10\":1,\"18\":1,\"26\":2,\"53\":5,\"68\":1,\"70\":1,\"71\":2,\"116\":4}}],[\"vector<value\",{\"1\":{\"10\":1}}],[\"void没办法获取返回值\",{\"1\":{\"53\":1}}],[\"void\",{\"1\":{\"9\":1,\"12\":6,\"13\":1,\"14\":14,\"16\":1,\"18\":4,\"21\":2,\"25\":4,\"26\":2,\"27\":4,\"28\":1,\"29\":4,\"30\":6,\"31\":4,\"32\":1,\"33\":4,\"34\":1,\"35\":2,\"36\":4,\"37\":1,\"38\":2,\"47\":8,\"48\":4,\"49\":2,\"52\":6,\"53\":1,\"54\":3,\"55\":1,\"56\":1,\"62\":1,\"64\":1,\"68\":2,\"70\":2,\"71\":2,\"74\":2,\"76\":3,\"77\":1,\"79\":7,\"98\":1,\"99\":6,\"100\":2,\"102\":1,\"103\":6,\"107\":11,\"108\":7,\"109\":4,\"114\":1,\"115\":3,\"116\":3}}],[\"up\",{\"1\":{\"79\":2}}],[\"ullong\",{\"1\":{\"75\":1}}],[\"ulong\",{\"1\":{\"75\":1}}],[\"uchar\",{\"1\":{\"75\":1}}],[\"uint\",{\"1\":{\"75\":1}}],[\"ui\",{\"1\":{\"61\":3,\"62\":4,\"63\":1,\"64\":4,\"67\":2,\"72\":1,\"94\":1}}],[\"u\",{\"1\":{\"50\":1,\"75\":1}}],[\"ushort\",{\"1\":{\"75\":1}}],[\"usbmonitor\",{\"1\":{\"50\":1}}],[\"user\",{\"1\":{\"76\":1,\"99\":1}}],[\"use\",{\"1\":{\"38\":3,\"76\":1}}],[\"using\",{\"1\":{\"10\":1,\"15\":1,\"21\":1,\"27\":1,\"53\":1,\"58\":1,\"59\":12,\"60\":1,\"68\":1,\"75\":11,\"98\":1,\"99\":2,\"100\":3,\"102\":1,\"107\":8,\"108\":1,\"116\":2}}],[\"unavailable\",{\"1\":{\"99\":2}}],[\"unless\",{\"1\":{\"76\":1}}],[\"unlocks\",{\"1\":{\"27\":1,\"102\":1}}],[\"unlock\",{\"1\":{\"26\":3,\"27\":4,\"28\":1,\"30\":1,\"31\":5,\"32\":1,\"35\":6,\"47\":3,\"76\":2,\"82\":4,\"102\":2,\"103\":4,\"107\":1,\"108\":1}}],[\"unlocked\",{\"1\":{\"26\":1}}],[\"uniform\",{\"1\":{\"68\":1}}],[\"unique<\",{\"1\":{\"99\":2}}],[\"unique\",{\"1\":{\"31\":13,\"32\":12,\"34\":1,\"35\":1,\"47\":9,\"48\":2,\"49\":1,\"51\":1,\"56\":1,\"60\":1,\"99\":2,\"107\":1,\"108\":6,\"109\":2,\"116\":1}}],[\"until\",{\"1\":{\"15\":6,\"55\":3,\"57\":3,\"60\":2,\"108\":4}}],[\"unsigned\",{\"1\":{\"10\":1,\"66\":1,\"75\":1,\"98\":1,\"99\":1}}],[\"abi\",{\"1\":{\"99\":1,\"107\":1}}],[\"at\",{\"1\":{\"99\":1,\"107\":1,\"109\":4}}],[\"atomic类型\",{\"1\":{\"77\":1}}],[\"atomic<foo\",{\"1\":{\"78\":1}}],[\"atomic<t\",{\"1\":{\"77\":1,\"78\":4}}],[\"atomic<trivial\",{\"1\":{\"75\":2}}],[\"atomic<long\",{\"1\":{\"75\":1}}],[\"atomic<long>\",{\"1\":{\"75\":1}}],[\"atomic<unsigned\",{\"1\":{\"75\":5}}],[\"atomic<char>\",{\"1\":{\"75\":1}}],[\"atomic<int>\",{\"1\":{\"75\":7}}],[\"atomic<short>\",{\"1\":{\"75\":1}}],[\"atomic<shared\",{\"1\":{\"72\":1,\"79\":3}}],[\"atomic<signed\",{\"1\":{\"75\":1}}],[\"atomic<std\",{\"1\":{\"72\":1,\"79\":8,\"116\":3}}],[\"atomic<bool>b\",{\"1\":{\"77\":1}}],[\"atomic<bool>\",{\"1\":{\"49\":1,\"75\":2,\"76\":1,\"77\":11,\"116\":3}}],[\"atomic\",{\"1\":{\"25\":1,\"71\":1,\"74\":1,\"75\":46,\"76\":20,\"77\":3,\"79\":6}}],[\"avoid\",{\"1\":{\"99\":1}}],[\"again\",{\"1\":{\"99\":2}}],[\"await\",{\"1\":{\"92\":1}}],[\"aware\",{\"1\":{\"76\":1}}],[\"asio\",{\"1\":{\"114\":16,\"115\":2,\"116\":1,\"117\":1}}],[\"as\",{\"1\":{\"81\":1}}],[\"asscoiated\",{\"1\":{\"109\":1}}],[\"asscociated\",{\"1\":{\"108\":1}}],[\"assigns\",{\"1\":{\"109\":1}}],[\"assigned\",{\"1\":{\"108\":1}}],[\"assignable<trivial\",{\"1\":{\"75\":2}}],[\"assoc\",{\"1\":{\"107\":4,\"108\":6}}],[\"associated\",{\"1\":{\"52\":3,\"107\":24,\"108\":7}}],[\"assert\",{\"1\":{\"75\":5,\"78\":4,\"108\":1}}],[\"asynchronous\",{\"1\":{\"52\":1,\"107\":1,\"108\":1}}],[\"async\",{\"0\":{\"105\":1},\"1\":{\"38\":8,\"52\":34,\"53\":2,\"55\":1,\"56\":5,\"59\":2,\"62\":2,\"63\":2,\"64\":8,\"65\":2,\"106\":4,\"107\":36,\"108\":16,\"109\":2,\"110\":6,\"116\":1}}],[\"app\",{\"1\":{\"115\":2}}],[\"apply\",{\"1\":{\"102\":1,\"103\":8}}],[\"apt\",{\"1\":{\"50\":2}}],[\"api\",{\"1\":{\"37\":1,\"60\":3,\"66\":1,\"69\":1,\"94\":1,\"100\":2}}],[\"audio\",{\"1\":{\"49\":7}}],[\"audioplayer\",{\"1\":{\"49\":3}}],[\"auto\",{\"1\":{\"10\":6,\"15\":4,\"18\":1,\"25\":1,\"26\":2,\"27\":1,\"34\":1,\"52\":8,\"53\":4,\"56\":1,\"58\":2,\"59\":7,\"60\":4,\"64\":1,\"77\":1,\"79\":2,\"99\":5,\"103\":4,\"107\":1,\"116\":5}}],[\"arm\",{\"1\":{\"85\":6}}],[\"are\",{\"1\":{\"76\":1}}],[\"argv\",{\"1\":{\"115\":2}}],[\"argc\",{\"1\":{\"115\":2}}],[\"argtypes\",{\"1\":{\"107\":16,\"109\":1}}],[\"argtypes>\",{\"1\":{\"107\":15,\"109\":1}}],[\"arg\",{\"1\":{\"52\":1,\"107\":8,\"115\":1}}],[\"args\",{\"1\":{\"18\":3,\"21\":2,\"53\":4,\"99\":9,\"107\":15,\"109\":2,\"116\":3}}],[\"args>\",{\"1\":{\"18\":1,\"21\":3,\"53\":1,\"99\":7,\"100\":1,\"116\":1}}],[\"array\",{\"1\":{\"50\":1,\"78\":6,\"108\":1}}],[\"arrive\",{\"1\":{\"70\":3,\"71\":14}}],[\"arrived\",{\"1\":{\"47\":9}}],[\"arrival\",{\"1\":{\"47\":6}}],[\"any\",{\"1\":{\"47\":7}}],[\"and\",{\"1\":{\"21\":2,\"27\":1,\"70\":3,\"71\":12,\"76\":7,\"77\":1,\"102\":2,\"103\":1}}],[\"always\",{\"1\":{\"75\":6}}],[\"alignhcenter\",{\"1\":{\"64\":2}}],[\"align\",{\"1\":{\"64\":2}}],[\"aligned\",{\"1\":{\"36\":1}}],[\"already\",{\"1\":{\"54\":2,\"107\":3,\"108\":2,\"109\":3}}],[\"all\",{\"1\":{\"49\":1,\"79\":1,\"107\":3,\"109\":1,\"116\":1}}],[\"alloc\",{\"1\":{\"36\":1}}],[\"adl\",{\"1\":{\"99\":1}}],[\"adapter<\",{\"1\":{\"107\":2}}],[\"adapt\",{\"1\":{\"99\":1}}],[\"addaudiopath\",{\"1\":{\"49\":2}}],[\"addressof\",{\"1\":{\"31\":1,\"107\":1,\"109\":1}}],[\"add\",{\"1\":{\"27\":6,\"75\":1,\"78\":4,\"114\":1}}],[\"adopt\",{\"1\":{\"27\":2,\"30\":3,\"31\":5,\"102\":3,\"103\":3}}],[\"ax\",{\"1\":{\"21\":3,\"99\":5}}],[\"after\",{\"1\":{\"15\":1}}],[\"a的引用只能引用a\",{\"1\":{\"14\":1}}],[\"a\",{\"1\":{\"14\":8,\"27\":6,\"29\":1,\"30\":10,\"52\":1,\"53\":8,\"74\":8,\"75\":2,\"82\":9,\"107\":3,\"108\":5,\"109\":3}}],[\"actually\",{\"1\":{\"76\":1}}],[\"active\",{\"1\":{\"71\":3}}],[\"acq\",{\"1\":{\"75\":1,\"77\":1,\"83\":4}}],[\"acquire\",{\"1\":{\"68\":7,\"75\":2,\"76\":1,\"77\":3,\"82\":1,\"83\":4}}],[\"acquisition\",{\"1\":{\"13\":1}}],[\"accumulate\",{\"1\":{\"10\":4,\"27\":1,\"53\":2}}],[\"amd\",{\"1\":{\"10\":1}}],[\"fake\",{\"1\":{\"107\":2}}],[\"failed\",{\"1\":{\"99\":2}}],[\"false\",{\"1\":{\"9\":1,\"12\":2,\"28\":1,\"31\":3,\"32\":1,\"47\":3,\"49\":1,\"52\":2,\"55\":1,\"56\":1,\"60\":2,\"62\":1,\"64\":1,\"75\":3,\"76\":9,\"77\":18,\"107\":11,\"109\":2,\"114\":1,\"116\":1}}],[\"f4\",{\"1\":{\"76\":1}}],[\"fetch\",{\"1\":{\"56\":4,\"75\":2,\"78\":5}}],[\"fexperimental\",{\"1\":{\"21\":1}}],[\"f3\",{\"1\":{\"52\":1,\"76\":1}}],[\"f1\",{\"1\":{\"52\":2}}],[\"fty2\",{\"1\":{\"107\":3}}],[\"fty2>\",{\"1\":{\"107\":5}}],[\"fty\",{\"1\":{\"52\":1,\"107\":13}}],[\"fty>\",{\"1\":{\"52\":3,\"107\":11}}],[\"ffmpeg\",{\"1\":{\"50\":1}}],[\"fun\",{\"1\":{\"107\":2}}],[\"functio\",{\"1\":{\"56\":3}}],[\"functiontorun\",{\"1\":{\"115\":2}}],[\"function来运行可能的延迟任务\",{\"1\":{\"109\":1}}],[\"functions\",{\"1\":{\"107\":3}}],[\"function\",{\"1\":{\"28\":3,\"29\":3,\"35\":6,\"54\":4,\"71\":1,\"107\":5,\"108\":11}}],[\"func>\",{\"1\":{\"29\":1}}],[\"func\",{\"1\":{\"12\":9,\"13\":1,\"18\":2,\"29\":3}}],[\"fut\",{\"1\":{\"54\":4,\"56\":2}}],[\"future对象用于获取任务结果以及确保任务执行完毕\",{\"1\":{\"116\":1}}],[\"future<rettype>\",{\"1\":{\"116\":1}}],[\"future<\",{\"1\":{\"107\":5,\"108\":3}}],[\"future<std\",{\"1\":{\"56\":5,\"107\":1,\"116\":1}}],[\"future<t\",{\"1\":{\"55\":1,\"108\":1}}],[\"future<t>\",{\"1\":{\"55\":2,\"56\":1,\"108\":2}}],[\"future<value\",{\"1\":{\"53\":2}}],[\"future<void>future\",{\"1\":{\"55\":1,\"64\":1}}],[\"future<void>\",{\"1\":{\"52\":1,\"55\":1,\"108\":2}}],[\"future<double>\",{\"1\":{\"53\":1}}],[\"future<double>future\",{\"1\":{\"53\":1}}],[\"future<move\",{\"1\":{\"52\":1}}],[\"future<int>>\",{\"1\":{\"116\":1}}],[\"future<int>\",{\"1\":{\"52\":1,\"53\":1,\"54\":3,\"56\":1,\"59\":1,\"107\":1,\"108\":1}}],[\"future\",{\"0\":{\"55\":1,\"105\":1},\"1\":{\"46\":2,\"51\":9,\"52\":15,\"53\":19,\"54\":11,\"55\":16,\"56\":47,\"59\":12,\"62\":1,\"64\":1,\"72\":1,\"106\":3,\"107\":44,\"108\":38,\"109\":3,\"110\":5,\"116\":4}}],[\"futures\",{\"1\":{\"45\":1,\"53\":5,\"108\":2,\"116\":5}}],[\"fms\",{\"1\":{\"37\":1}}],[\"fret\",{\"1\":{\"107\":3}}],[\"fret>\",{\"1\":{\"107\":2}}],[\"free\",{\"1\":{\"36\":1,\"75\":22}}],[\"from\",{\"1\":{\"107\":4,\"108\":1}}],[\"front\",{\"1\":{\"48\":2,\"49\":1,\"116\":1}}],[\"friend\",{\"1\":{\"30\":1}}],[\"fixed\",{\"1\":{\"52\":1,\"64\":2,\"107\":1}}],[\"find\",{\"1\":{\"34\":1}}],[\"first\",{\"1\":{\"10\":7,\"53\":4}}],[\"float\",{\"1\":{\"75\":3}}],[\"flac\",{\"1\":{\"50\":1}}],[\"flag不可复制不可移动不可赋值\",{\"1\":{\"76\":1}}],[\"flag\",{\"1\":{\"33\":8,\"47\":5,\"76\":26,\"77\":14}}],[\"flush\",{\"1\":{\"21\":1}}],[\"found\",{\"1\":{\"120\":1}}],[\"font\",{\"1\":{\"64\":1}}],[\"foo\",{\"1\":{\"29\":1,\"33\":1,\"78\":3}}],[\"format\",{\"1\":{\"68\":1,\"70\":2}}],[\"forward<f>\",{\"1\":{\"116\":1}}],[\"forward<fty>\",{\"1\":{\"107\":1}}],[\"forward<argtypes>\",{\"1\":{\"107\":1}}],[\"forward<args>\",{\"1\":{\"18\":1,\"53\":1,\"116\":1}}],[\"forward<tuple>\",{\"1\":{\"103\":2}}],[\"forward<\",{\"1\":{\"21\":4,\"52\":2,\"99\":6,\"107\":13,\"109\":3}}],[\"forward<callable>\",{\"1\":{\"18\":1,\"103\":2,\"115\":1}}],[\"forwardit\",{\"1\":{\"10\":4,\"53\":2}}],[\"forwardit>\",{\"1\":{\"10\":2,\"53\":1}}],[\"for\",{\"1\":{\"10\":2,\"12\":1,\"15\":5,\"18\":3,\"21\":2,\"26\":4,\"27\":1,\"28\":1,\"47\":8,\"48\":2,\"49\":1,\"52\":2,\"53\":3,\"54\":1,\"56\":2,\"57\":3,\"59\":3,\"60\":2,\"62\":2,\"64\":2,\"68\":4,\"70\":3,\"71\":5,\"79\":10,\"98\":1,\"107\":13,\"108\":2,\"114\":2,\"115\":1,\"116\":5}}],[\"fx\",{\"1\":{\"21\":3,\"99\":5}}],[\"fnvals\",{\"1\":{\"99\":2}}],[\"fnarg\",{\"1\":{\"52\":3,\"107\":16}}],[\"fn>\",{\"1\":{\"21\":4,\"99\":6,\"100\":1}}],[\"fn\",{\"1\":{\"21\":2,\"99\":8,\"107\":4,\"109\":1}}],[\"f2\",{\"1\":{\"12\":3,\"13\":2,\"25\":7,\"30\":6,\"52\":3,\"76\":1,\"103\":1}}],[\"f\",{\"1\":{\"12\":3,\"13\":2,\"14\":27,\"16\":7,\"21\":4,\"25\":10,\"26\":5,\"27\":2,\"30\":6,\"31\":1,\"33\":4,\"36\":3,\"52\":15,\"70\":2,\"71\":4,\"74\":2,\"76\":7,\"99\":1,\"103\":6,\"107\":2,\"116\":7}}],[\"物理核心这个通常不看重\",{\"1\":{\"10\":1}}],[\"6900\",{\"1\":{\"116\":4}}],[\"69\",{\"1\":{\"71\":1}}],[\"68\",{\"1\":{\"71\":1}}],[\"67\",{\"1\":{\"71\":1}}],[\"66\",{\"1\":{\"71\":1,\"103\":1}}],[\"65\",{\"1\":{\"71\":1}}],[\"63\",{\"1\":{\"71\":1}}],[\"62\",{\"1\":{\"71\":1}}],[\"61\",{\"1\":{\"71\":1}}],[\"60\",{\"1\":{\"58\":1,\"71\":1,\"75\":1}}],[\"64\",{\"1\":{\"20\":1,\"71\":1,\"100\":1}}],[\"6\",{\"1\":{\"10\":1,\"39\":1,\"44\":1,\"50\":1,\"59\":1,\"60\":3,\"71\":1,\"83\":1,\"115\":1,\"116\":3}}],[\"有三个偏特化\",{\"1\":{\"107\":1}}],[\"有两个重载\",{\"1\":{\"107\":1}}],[\"有两个小孩\",{\"1\":{\"30\":1}}],[\"有四个构造函数\",{\"1\":{\"99\":1}}],[\"有限的特性使得\",{\"1\":{\"76\":1}}],[\"有可能不会是\",{\"1\":{\"60\":1}}],[\"有可能函数\",{\"1\":{\"30\":1}}],[\"有一个\",{\"1\":{\"56\":1}}],[\"有一个局限\",{\"1\":{\"56\":1}}],[\"有一个玩具\",{\"1\":{\"30\":1}}],[\"有时可以通过改变数据结构来避免对原子操作的依赖\",{\"1\":{\"75\":1}}],[\"有时候线程可能会在没有收到通知的情况下被唤醒\",{\"1\":{\"47\":1}}],[\"有时这是无法避免的\",{\"1\":{\"30\":1}}],[\"有特殊需求\",{\"1\":{\"47\":1}}],[\"有兴趣参见我们的链接即可\",{\"1\":{\"37\":1}}],[\"有它的定义\",{\"1\":{\"32\":1}}],[\"有疑问\",{\"1\":{\"32\":1}}],[\"有些功能实现起来非常简单\",{\"1\":{\"116\":1}}],[\"有些人可能喜欢称作\",{\"1\":{\"45\":1}}],[\"有些人认为二者大多数时候是相同的\",{\"1\":{\"6\":1}}],[\"有些人认为二者毫无关系\",{\"1\":{\"6\":1}}],[\"有些时候\",{\"1\":{\"32\":1}}],[\"有的时候只需要一个指针或者引用\",{\"1\":{\"29\":1}}],[\"有数据竞争\",{\"1\":{\"25\":1}}],[\"有关线程安全的其它问题\",{\"1\":{\"24\":1}}],[\"有点像外部给线程传递信号一样\",{\"1\":{\"21\":1}}],[\"有\",{\"1\":{\"10\":1}}],[\"19\",{\"1\":{\"71\":1}}],[\"18\",{\"1\":{\"71\":1}}],[\"17\",{\"1\":{\"71\":1,\"92\":1,\"97\":1,\"106\":1,\"108\":1}}],[\"13\",{\"1\":{\"71\":1}}],[\"13700h\",{\"1\":{\"10\":1}}],[\"11\",{\"1\":{\"71\":1,\"92\":1}}],[\"11检测全部完成\",{\"1\":{\"50\":1}}],[\"1h\",{\"1\":{\"59\":1}}],[\"1min\",{\"1\":{\"59\":1}}],[\"1ms\",{\"1\":{\"59\":1}}],[\"1s\",{\"1\":{\"59\":1,\"70\":1}}],[\"1us\",{\"1\":{\"59\":1}}],[\"1ns\",{\"1\":{\"59\":1}}],[\"1>\",{\"1\":{\"58\":1}}],[\"1f\",{\"1\":{\"49\":1}}],[\"15\",{\"1\":{\"21\":1,\"60\":3,\"71\":1}}],[\"16\",{\"1\":{\"20\":2,\"31\":1,\"71\":1,\"98\":2}}],[\"10px\",{\"1\":{\"64\":1}}],[\"10ms\",{\"1\":{\"62\":1,\"64\":1,\"79\":2}}],[\"10反应杯不足\",{\"1\":{\"50\":1}}],[\"1024\",{\"1\":{\"14\":3,\"95\":1}}],[\"1024000\",{\"1\":{\"10\":2,\"53\":1}}],[\"100ms\",{\"1\":{\"79\":2}}],[\"1000\",{\"1\":{\"60\":1,\"62\":2,\"64\":3}}],[\"10000000>>\",{\"1\":{\"60\":1}}],[\"1000>\",{\"1\":{\"59\":1}}],[\"100\",{\"1\":{\"12\":2,\"28\":1,\"47\":1,\"54\":3,\"60\":2,\"64\":4,\"71\":1,\"79\":3}}],[\"10\",{\"1\":{\"10\":1,\"12\":3,\"13\":1,\"18\":3,\"26\":2,\"52\":3,\"53\":3,\"56\":1,\"57\":2,\"68\":2,\"70\":2,\"71\":5,\"75\":1,\"79\":7,\"114\":2,\"115\":2,\"116\":2}}],[\"1\",{\"1\":{\"10\":5,\"12\":5,\"14\":3,\"16\":3,\"21\":3,\"25\":1,\"26\":1,\"27\":1,\"28\":3,\"30\":3,\"33\":1,\"35\":4,\"36\":2,\"37\":1,\"38\":3,\"47\":3,\"48\":5,\"52\":2,\"53\":1,\"54\":1,\"56\":2,\"58\":3,\"60\":5,\"68\":2,\"70\":2,\"71\":14,\"72\":1,\"75\":2,\"77\":1,\"78\":5,\"81\":1,\"100\":1,\"107\":5,\"108\":1,\"115\":2,\"116\":2}}],[\"14px\",{\"1\":{\"64\":1}}],[\"14\",{\"1\":{\"10\":1,\"71\":1}}],[\"123\",{\"1\":{\"57\":1,\"59\":2}}],[\"12\",{\"1\":{\"10\":1,\"71\":1}}],[\"混合设计架构\",{\"1\":{\"10\":1}}],[\"大部分开发者早就自己使用\",{\"1\":{\"112\":1}}],[\"大概是因为这些编程语言都在新版本中引入它作为核心语言特性\",{\"1\":{\"92\":1}}],[\"大体来说我们可以将它们分为三类\",{\"1\":{\"83\":1}}],[\"大家可以使用\",{\"1\":{\"50\":1}}],[\"大家可以打开自己电脑的任务管理器看一眼\",{\"1\":{\"5\":1}}],[\"大多数的提示音播放都是短暂且简单\",{\"1\":{\"49\":1}}],[\"大多数时候它是合适的\",{\"1\":{\"12\":1}}],[\"大约\",{\"1\":{\"21\":1}}],[\"大小为\",{\"1\":{\"20\":1}}],[\"大小核\",{\"1\":{\"10\":1}}],[\"代表这些任务就是在主线程\",{\"1\":{\"64\":1}}],[\"代表一秒\",{\"1\":{\"59\":1}}],[\"代酷睿开始\",{\"1\":{\"10\":1}}],[\"代码很简单\",{\"1\":{\"114\":1}}],[\"代码如下\",{\"1\":{\"107\":1}}],[\"代码进行讲解\",{\"1\":{\"97\":1,\"101\":1}}],[\"代码风格\",{\"0\":{\"95\":1}}],[\"代码后如下\",{\"1\":{\"30\":1}}],[\"代码创建了一个调用\",{\"1\":{\"14\":1}}],[\"代码\",{\"1\":{\"0\":1}}],[\"英特尔从\",{\"1\":{\"10\":1}}],[\"英特尔®\",{\"1\":{\"10\":1}}],[\"都可以进行所谓的\",{\"1\":{\"112\":1}}],[\"都继承自\",{\"1\":{\"107\":1}}],[\"都没这样做\",{\"1\":{\"103\":1}}],[\"都进行零初始化\",{\"1\":{\"99\":1}}],[\"都出过至少算作正经的\",{\"1\":{\"92\":1}}],[\"都是微软提供的用于创建线程的\",{\"1\":{\"100\":1}}],[\"都是胡言乱语\",{\"1\":{\"92\":1}}],[\"都是弱序内存模型\",{\"1\":{\"85\":1}}],[\"都是省略了\",{\"1\":{\"59\":1}}],[\"都有一个内存序参数\",{\"1\":{\"75\":1}}],[\"都提供了函数\",{\"1\":{\"58\":1}}],[\"都会返回\",{\"1\":{\"52\":1}}],[\"都会获得该变量的一个副本\",{\"1\":{\"39\":1}}],[\"都声明在\",{\"1\":{\"51\":1}}],[\"都只能单独执行\",{\"1\":{\"48\":1}}],[\"都要进行读取\",{\"1\":{\"34\":1}}],[\"都以\",{\"1\":{\"31\":1}}],[\"都与线程对象关联\",{\"1\":{\"22\":1}}],[\"都能正常析构\",{\"1\":{\"16\":1}}],[\"都基于这个类\",{\"1\":{\"15\":1}}],[\"都被销毁了\",{\"1\":{\"12\":1}}],[\"都\",{\"1\":{\"10\":1}}],[\"都并行\",{\"1\":{\"5\":1}}],[\"个字节\",{\"1\":{\"98\":1}}],[\"个常量\",{\"1\":{\"83\":1}}],[\"个同时访问者\",{\"1\":{\"68\":2}}],[\"个并发请求\",{\"1\":{\"68\":1}}],[\"个并发线程\",{\"1\":{\"10\":1}}],[\"个\",{\"1\":{\"68\":1,\"71\":1}}],[\"个节拍\",{\"1\":{\"58\":1}}],[\"个线程的线程池\",{\"1\":{\"114\":1,\"116\":2}}],[\"个线程\",{\"1\":{\"18\":1,\"114\":1}}],[\"个线程执行\",{\"1\":{\"10\":1}}],[\"个元素被分配给了前两个线程\",{\"1\":{\"10\":1}}],[\"个性能核\",{\"1\":{\"10\":1}}],[\"个能效核\",{\"1\":{\"10\":1}}],[\"个任务分配三个线程\",{\"1\":{\"10\":1}}],[\"个任务\",{\"1\":{\"10\":1}}],[\"核心是监控一个音频队列\",{\"1\":{\"49\":1}}],[\"核心\",{\"1\":{\"10\":2}}],[\"一节中我们也详细聊过\",{\"1\":{\"108\":1}}],[\"一切的重点\",{\"1\":{\"107\":1}}],[\"一切最终都是依靠开发者使用与管理\",{\"1\":{\"30\":1}}],[\"一定要会使用\",{\"1\":{\"103\":1}}],[\"一定时间内没有连接到服务器就不会继续阻塞了\",{\"1\":{\"57\":1}}],[\"一般初始化时使用\",{\"1\":{\"95\":1}}],[\"一般都是互斥量\",{\"1\":{\"82\":1}}],[\"一般最好使用\",{\"1\":{\"76\":1}}],[\"一般不建议指出\",{\"1\":{\"33\":1}}],[\"一种是\",{\"1\":{\"57\":1}}],[\"一种可能的使用是允许函数去锁住一个互斥量\",{\"1\":{\"32\":1}}],[\"一旦有提示音需要播放\",{\"1\":{\"49\":1}}],[\"一旦条件满足\",{\"1\":{\"47\":1}}],[\"一直不休息\",{\"1\":{\"47\":1}}],[\"一起使用\",{\"1\":{\"38\":1,\"53\":1}}],[\"一起出现\",{\"1\":{\"34\":1}}],[\"一样错误\",{\"1\":{\"52\":1}}],[\"一样\",{\"1\":{\"52\":2,\"56\":1}}],[\"一样使用\",{\"1\":{\"31\":1}}],[\"一样只是多了复制\",{\"1\":{\"14\":1}}],[\"一个可调用\",{\"1\":{\"103\":1}}],[\"一个静态函数指针\",{\"1\":{\"99\":1}}],[\"一个在互联网上非常热门的八股问题是\",{\"1\":{\"79\":1}}],[\"一个常见的例子是在很多网络库中的\",{\"1\":{\"57\":1}}],[\"一个常见的场景是\",{\"1\":{\"49\":1}}],[\"一个异常\",{\"1\":{\"54\":3}}],[\"一个成员函数在对象构造时就启动\",{\"1\":{\"49\":1}}],[\"一个操作完成后才能开始下一个操作\",{\"1\":{\"46\":1}}],[\"一个直观的展示是\",{\"1\":{\"36\":1}}],[\"一个线程\",{\"1\":{\"48\":1}}],[\"一个线程会尝试在释放一个互斥量前多次获取\",{\"1\":{\"35\":1}}],[\"一个线程知道另一个线程已经在执行③\",{\"1\":{\"33\":1}}],[\"一个互斥量的指针\",{\"1\":{\"31\":1}}],[\"一个引用\",{\"1\":{\"27\":1}}],[\"一个冲突的求值发生早于\",{\"1\":{\"25\":1}}],[\"一个删除元素\",{\"1\":{\"25\":1}}],[\"一次是调用函数\",{\"1\":{\"14\":1}}],[\"一次是被\",{\"1\":{\"14\":1}}],[\"一款\",{\"1\":{\"10\":1}}],[\"一些当前线程可能抛出异常的代码\",{\"1\":{\"12\":3}}],[\"一些老式特殊情况不聊\",{\"1\":{\"12\":1}}],[\"一些古老的书籍比如\",{\"1\":{\"10\":1}}],[\"一些单核机器\",{\"1\":{\"5\":1}}],[\"sp\",{\"1\":{\"79\":3}}],[\"space\",{\"1\":{\"76\":1}}],[\"spinlocks\",{\"1\":{\"76\":1}}],[\"spinlock\",{\"1\":{\"76\":4}}],[\"spurious\",{\"1\":{\"47\":1}}],[\"scheduler\",{\"1\":{\"114\":3}}],[\"schar\",{\"1\":{\"75\":1}}],[\"scoped\",{\"0\":{\"101\":1},\"1\":{\"27\":3,\"30\":4,\"101\":2,\"102\":26,\"103\":6,\"104\":1}}],[\"smph\",{\"1\":{\"68\":6}}],[\"smt\",{\"1\":{\"10\":1}}],[\"satisfied\",{\"1\":{\"54\":2,\"109\":1}}],[\"same\",{\"1\":{\"21\":1,\"99\":2}}],[\"square\",{\"1\":{\"54\":2}}],[\"shutdown\",{\"1\":{\"114\":3}}],[\"short>\",{\"1\":{\"75\":1}}],[\"short\",{\"1\":{\"75\":2}}],[\"should\",{\"1\":{\"52\":1,\"107\":1,\"108\":1}}],[\"share\",{\"1\":{\"56\":2,\"108\":1}}],[\"shared<std\",{\"1\":{\"116\":1}}],[\"shared<int>\",{\"1\":{\"79\":4}}],[\"shared<data>\",{\"1\":{\"79\":4}}],[\"shared<t>\",{\"1\":{\"48\":1}}],[\"shared\",{\"1\":{\"33\":1,\"34\":11,\"45\":1,\"48\":3,\"51\":4,\"55\":1,\"56\":30,\"72\":3,\"79\":33,\"90\":2,\"108\":2}}],[\"switch\",{\"1\":{\"52\":1,\"107\":1}}],[\"swap\",{\"1\":{\"18\":2,\"30\":10,\"31\":3,\"79\":3,\"107\":3}}],[\"supplied\",{\"1\":{\"107\":1}}],[\"submit\",{\"1\":{\"116\":8}}],[\"sub\",{\"1\":{\"75\":1,\"78\":1}}],[\"sudo\",{\"1\":{\"50\":2}}],[\"sum\",{\"1\":{\"10\":8,\"27\":4,\"53\":7,\"116\":5}}],[\"sfinae\",{\"1\":{\"99\":1}}],[\"sf\",{\"1\":{\"49\":4,\"56\":1}}],[\"sfml不支持\",{\"1\":{\"50\":1}}],[\"sfml\",{\"1\":{\"49\":2,\"50\":4}}],[\"sequence\",{\"1\":{\"99\":2,\"103\":2}}],[\"sequence<std\",{\"1\":{\"103\":1}}],[\"sequence<index\",{\"1\":{\"103\":1}}],[\"sequence<\",{\"1\":{\"99\":1}}],[\"sequence<1\",{\"1\":{\"99\":2}}],[\"seq\",{\"1\":{\"75\":3,\"76\":2,\"83\":5}}],[\"semaphore允许同一资源进行多个并发的访问\",{\"1\":{\"68\":1}}],[\"semaphore<3>\",{\"1\":{\"68\":1}}],[\"semaphore<1>\",{\"1\":{\"68\":1}}],[\"semaphore\",{\"1\":{\"68\":13,\"72\":1}}],[\"self\",{\"1\":{\"66\":1}}],[\"select\",{\"1\":{\"52\":1,\"107\":1}}],[\"second\",{\"1\":{\"59\":1}}],[\"seconds>\",{\"1\":{\"59\":1}}],[\"seconds\",{\"1\":{\"15\":2,\"47\":2,\"49\":1,\"52\":1,\"54\":1,\"56\":2,\"59\":4,\"60\":1,\"68\":1}}],[\"setupui\",{\"1\":{\"64\":1}}],[\"setspecific\",{\"1\":{\"37\":1}}],[\"set\",{\"1\":{\"34\":1,\"52\":1,\"54\":18,\"76\":6,\"77\":3,\"79\":1,\"107\":12,\"109\":7}}],[\"settings\",{\"1\":{\"34\":1}}],[\"so\",{\"1\":{\"108\":1}}],[\"solid\",{\"1\":{\"64\":1}}],[\"soundcount\",{\"1\":{\"50\":1}}],[\"soundindex\",{\"1\":{\"50\":1}}],[\"sound\",{\"1\":{\"50\":11}}],[\"soundresources\",{\"1\":{\"50\":2}}],[\"soundsource\",{\"1\":{\"49\":1}}],[\"source\",{\"1\":{\"20\":3,\"21\":6,\"22\":1,\"23\":1}}],[\"some\",{\"1\":{\"32\":4,\"33\":4}}],[\"something\",{\"1\":{\"29\":4,\"33\":3}}],[\"ssource\",{\"1\":{\"20\":1,\"21\":2}}],[\"s\",{\"1\":{\"15\":3,\"58\":2,\"59\":4,\"64\":2,\"75\":1,\"99\":2}}],[\"system\",{\"1\":{\"15\":5,\"31\":2,\"58\":6,\"60\":4}}],[\"sleep\",{\"1\":{\"15\":11,\"21\":2,\"28\":1,\"47\":3,\"49\":3,\"52\":1,\"54\":1,\"56\":2,\"57\":2,\"60\":3,\"62\":1,\"64\":1,\"68\":3,\"70\":2,\"71\":1,\"79\":5}}],[\"signed\",{\"1\":{\"75\":1}}],[\"signal\",{\"1\":{\"68\":6,\"107\":1,\"108\":2}}],[\"simulate\",{\"1\":{\"47\":3}}],[\"simultaneous\",{\"1\":{\"10\":1}}],[\"singleton\",{\"1\":{\"33\":1}}],[\"sizeof\",{\"1\":{\"20\":1,\"98\":1,\"99\":2,\"100\":1}}],[\"size\",{\"1\":{\"10\":9,\"18\":3,\"25\":1,\"26\":2,\"30\":1,\"36\":1,\"53\":7,\"99\":2,\"103\":2,\"114\":4,\"116\":9}}],[\"sttd\",{\"1\":{\"110\":1}}],[\"style\",{\"1\":{\"64\":5}}],[\"studio\",{\"1\":{\"63\":1,\"92\":1}}],[\"steady\",{\"1\":{\"58\":4,\"60\":4}}],[\"store\",{\"1\":{\"75\":5,\"77\":3,\"78\":1,\"79\":4,\"81\":1,\"85\":2,\"94\":1,\"109\":2,\"116\":1}}],[\"stored\",{\"1\":{\"55\":5,\"107\":1,\"108\":10,\"109\":2}}],[\"storage\",{\"1\":{\"37\":1}}],[\"stopped\",{\"1\":{\"116\":1}}],[\"stop\",{\"1\":{\"20\":3,\"21\":25,\"22\":2,\"23\":2,\"49\":5,\"114\":3,\"116\":15}}],[\"status\",{\"1\":{\"59\":4,\"60\":1}}],[\"state继承关系示意图\",{\"1\":{\"108\":1}}],[\"state<void\",{\"1\":{\"107\":1}}],[\"state<\",{\"1\":{\"52\":2,\"107\":16,\"108\":4}}],[\"state<typename\",{\"1\":{\"52\":1,\"107\":1}}],[\"state\",{\"1\":{\"52\":3,\"55\":1,\"107\":99,\"108\":36,\"109\":2}}],[\"static\",{\"1\":{\"33\":1,\"42\":1,\"50\":1,\"75\":6,\"99\":3,\"108\":1,\"109\":1,\"114\":1}}],[\"start\",{\"1\":{\"10\":8,\"21\":2,\"53\":5,\"60\":2,\"62\":1,\"64\":2,\"70\":4,\"71\":2,\"81\":3,\"99\":5,\"100\":1,\"115\":6,\"116\":4}}],[\"strong\",{\"1\":{\"75\":2,\"77\":6,\"78\":1}}],[\"str\",{\"1\":{\"30\":2,\"64\":2}}],[\"strengthened\",{\"1\":{\"27\":1,\"102\":3,\"103\":1}}],[\"string>\",{\"1\":{\"34\":1,\"49\":1,\"56\":6}}],[\"string\",{\"1\":{\"14\":10,\"29\":1,\"30\":2,\"34\":5,\"49\":2,\"56\":2,\"64\":2,\"103\":1}}],[\"struct\",{\"1\":{\"12\":2,\"14\":3,\"30\":1,\"36\":1,\"38\":1,\"52\":3,\"75\":2,\"78\":1,\"95\":1,\"98\":1,\"99\":1,\"107\":3,\"115\":1,\"116\":1}}],[\"stdcall\",{\"1\":{\"99\":1}}],[\"std\",{\"0\":{\"97\":1,\"101\":1,\"105\":2},\"1\":{\"8\":3,\"9\":12,\"10\":24,\"11\":2,\"12\":25,\"13\":7,\"14\":57,\"15\":32,\"16\":36,\"17\":4,\"18\":25,\"19\":2,\"20\":9,\"21\":26,\"22\":2,\"23\":5,\"24\":1,\"25\":13,\"26\":10,\"27\":34,\"28\":11,\"29\":5,\"30\":30,\"31\":30,\"32\":15,\"33\":19,\"34\":19,\"35\":16,\"36\":7,\"37\":4,\"38\":13,\"45\":4,\"46\":1,\"47\":27,\"48\":14,\"49\":12,\"50\":1,\"51\":7,\"52\":76,\"53\":50,\"54\":42,\"55\":20,\"56\":65,\"57\":3,\"58\":22,\"59\":27,\"60\":26,\"62\":3,\"64\":6,\"65\":2,\"66\":2,\"68\":25,\"69\":2,\"70\":14,\"71\":26,\"72\":2,\"74\":3,\"75\":39,\"76\":22,\"77\":20,\"78\":6,\"79\":52,\"82\":2,\"83\":1,\"90\":2,\"95\":3,\"97\":2,\"98\":2,\"99\":34,\"100\":12,\"101\":3,\"102\":13,\"103\":32,\"104\":2,\"106\":7,\"107\":48,\"108\":26,\"109\":7,\"110\":8,\"114\":6,\"115\":1,\"116\":46}}],[\"stl\",{\"1\":{\"0\":1,\"20\":1,\"21\":1,\"22\":1,\"27\":1,\"31\":1,\"47\":1,\"52\":2,\"55\":1,\"59\":1,\"68\":1,\"71\":1,\"75\":1,\"76\":1,\"93\":1,\"94\":1,\"97\":1,\"100\":1,\"101\":1,\"103\":1,\"106\":2,\"107\":1}}],[\"更新值并唤醒\",{\"1\":{\"79\":1}}],[\"更新和用户交互\",{\"1\":{\"61\":1}}],[\"更多的是一些风格上的\",{\"1\":{\"101\":1}}],[\"更多的问题参见源码都很直观\",{\"1\":{\"60\":1}}],[\"更多的线程意味着可以并行完成更多的工作\",{\"1\":{\"10\":1}}],[\"更合理的方案是\",{\"1\":{\"49\":1}}],[\"更换为\",{\"1\":{\"47\":1}}],[\"更加简洁\",{\"1\":{\"75\":1}}],[\"更加灵活\",{\"1\":{\"31\":1}}],[\"更加的灵活\",{\"1\":{\"31\":1}}],[\"更加注重性能\",{\"1\":{\"6\":1}}],[\"更好\",{\"1\":{\"30\":1}}],[\"支持任意可调用\",{\"1\":{\"52\":1}}],[\"支持的形式还有很多\",{\"1\":{\"12\":1}}],[\"支持\",{\"1\":{\"10\":1,\"50\":1}}],[\"==\",{\"1\":{\"30\":3,\"31\":1,\"49\":1,\"56\":1,\"59\":2,\"60\":1,\"71\":2,\"75\":2,\"78\":4,\"114\":1,\"116\":1}}],[\"=delete\",{\"1\":{\"13\":1}}],[\"=\",{\"1\":{\"10\":19,\"12\":4,\"13\":3,\"14\":12,\"15\":6,\"16\":4,\"18\":4,\"21\":1,\"25\":2,\"26\":2,\"27\":4,\"29\":2,\"31\":3,\"32\":2,\"33\":1,\"34\":3,\"36\":5,\"37\":4,\"38\":1,\"47\":4,\"48\":3,\"49\":2,\"52\":14,\"53\":16,\"54\":5,\"55\":1,\"56\":6,\"58\":6,\"59\":23,\"60\":5,\"62\":3,\"64\":9,\"68\":3,\"70\":1,\"71\":7,\"74\":1,\"75\":20,\"76\":4,\"77\":12,\"78\":4,\"79\":17,\"83\":6,\"90\":1,\"95\":3,\"98\":1,\"99\":15,\"100\":3,\"102\":8,\"107\":19,\"108\":8,\"109\":2,\"114\":4,\"115\":5,\"116\":17}}],[\"highestpriority\",{\"1\":{\"115\":1}}],[\"highpriority\",{\"1\":{\"115\":2}}],[\"hpp>\",{\"1\":{\"114\":1}}],[\"homework\",{\"1\":{\"117\":1}}],[\"holds\",{\"1\":{\"108\":1}}],[\"holder<\",{\"1\":{\"107\":1}}],[\"hour\",{\"1\":{\"59\":1}}],[\"hours\",{\"1\":{\"59\":2}}],[\"hnd\",{\"1\":{\"98\":2,\"99\":7}}],[\"has\",{\"1\":{\"100\":2,\"107\":1,\"109\":2}}],[\"happyyang的百草园\",{\"1\":{\"92\":1}}],[\"handle\",{\"1\":{\"68\":3,\"98\":1,\"99\":1,\"100\":2}}],[\"hardware\",{\"1\":{\"10\":5,\"53\":1,\"114\":3,\"116\":1}}],[\"held\",{\"1\":{\"108\":1,\"109\":2}}],[\"hello\",{\"0\":{\"9\":1},\"1\":{\"9\":8,\"10\":1,\"12\":1,\"14\":2}}],[\"here\",{\"1\":{\"52\":1,\"107\":1}}],[\"h\",{\"1\":{\"12\":2,\"15\":3,\"58\":2,\"63\":1}}],[\"当调用\",{\"1\":{\"108\":1}}],[\"当异步任务完成时\",{\"1\":{\"107\":1}}],[\"当异常抛出时\",{\"1\":{\"13\":1}}],[\"当线程请求锁\",{\"1\":{\"76\":1}}],[\"当标志对象已初始化\",{\"1\":{\"76\":1}}],[\"当完成一个阶段\",{\"1\":{\"71\":1}}],[\"当不要求截断值的情况下\",{\"1\":{\"59\":1}}],[\"当一个时钟的时钟节拍每\",{\"1\":{\"58\":1}}],[\"当结果被某个线程获取后\",{\"1\":{\"56\":1}}],[\"当我们想要获取任务的返回值的时候\",{\"1\":{\"53\":1}}],[\"当我们使用函数对象用于构造\",{\"1\":{\"12\":1}}],[\"当需要任务执行完的结果的时候\",{\"1\":{\"52\":1}}],[\"当多个线程需要访问一个独立\",{\"1\":{\"51\":1}}],[\"当多个线程执行函数\",{\"1\":{\"26\":1}}],[\"当外部通过调用\",{\"1\":{\"49\":1}}],[\"当有新的任务加入队列\",{\"1\":{\"112\":1}}],[\"当有新任务加入时\",{\"1\":{\"112\":1}}],[\"当有新任务时通知音频线程\",{\"1\":{\"49\":1}}],[\"当有多个互斥量保护同一个类的对象时\",{\"1\":{\"30\":1}}],[\"当没有需要播放的提示时\",{\"1\":{\"49\":1}}],[\"当队列为空时\",{\"1\":{\"48\":2}}],[\"当执行\",{\"1\":{\"48\":1}}],[\"当条件不满足时\",{\"1\":{\"47\":1}}],[\"当同一线程多次对同一个\",{\"1\":{\"35\":1}}],[\"当获取锁后会再检查一次指针②\",{\"1\":{\"33\":1}}],[\"当它无法满足你的需求或者显得代码非常繁琐\",{\"1\":{\"31\":1}}],[\"当运行\",{\"1\":{\"31\":1}}],[\"当然也包括非静态成员函数\",{\"1\":{\"116\":1}}],[\"当然\",{\"1\":{\"31\":1,\"32\":1,\"75\":1,\"116\":1}}],[\"当然了\",{\"1\":{\"10\":1,\"12\":1,\"14\":1,\"25\":1,\"59\":1,\"79\":1}}],[\"当写通用代码时\",{\"1\":{\"30\":1}}],[\"当另一个小孩也想玩\",{\"1\":{\"30\":1}}],[\"当其中一个小孩拿到了遥控器和玩具车时\",{\"1\":{\"30\":1}}],[\"当某个表达式的求值写入某个内存位置\",{\"1\":{\"25\":1}}],[\"当两个线程同时尝试向\",{\"1\":{\"25\":1}}],[\"当你的软件完成了主要功能后\",{\"1\":{\"49\":1}}],[\"当你调用\",{\"1\":{\"21\":1}}],[\"当你看完\",{\"1\":{\"17\":1}}],[\"当取消被执行时\",{\"1\":{\"21\":1}}],[\"当前活跃线程数\",{\"1\":{\"115\":1}}],[\"当前线程都会正确地等待任务的完成信号\",{\"1\":{\"108\":1}}],[\"当前原子对象的值为\",{\"1\":{\"77\":1}}],[\"当前值与预期一致时\",{\"1\":{\"77\":1}}],[\"当前计数与重置之后的计数均减\",{\"1\":{\"71\":1}}],[\"当前计数减\",{\"1\":{\"71\":1}}],[\"当前阶段的期待计数也减少一\",{\"1\":{\"71\":1}}],[\"当前时间可以通过静态成员函数\",{\"1\":{\"58\":1}}],[\"当前时间\",{\"1\":{\"58\":1}}],[\"当前是否关联共享状态\",{\"1\":{\"52\":1}}],[\"当前持有线程资源\",{\"1\":{\"16\":1}}],[\"当前没有关联活跃线程\",{\"1\":{\"16\":1}}],[\"当前关联了活跃线程\",{\"1\":{\"16\":1}}],[\"当前环境\",{\"1\":{\"75\":2}}],[\"当前环境核心越多数据越多\",{\"1\":{\"10\":1}}],[\"当前环境支持并发线程数\",{\"0\":{\"10\":1}}],[\"当\",{\"1\":{\"10\":3,\"12\":1,\"15\":1,\"47\":1,\"76\":1,\"107\":1}}],[\"当关注重点在于任务分离或任务响应时\",{\"1\":{\"6\":1}}],[\"其逻辑比信号量更简单\",{\"1\":{\"70\":1}}],[\"其\",{\"1\":{\"68\":1}}],[\"其所有权可以在不同的对象中互相传递\",{\"1\":{\"56\":1}}],[\"其返回值或所抛异常被存储于能通过\",{\"1\":{\"53\":1}}],[\"其它概念\",{\"0\":{\"84\":1}}],[\"其它同步机制\",{\"1\":{\"75\":1}}],[\"其它\",{\"1\":{\"46\":1}}],[\"其它线程调用\",{\"1\":{\"76\":1}}],[\"其它线程通过这个指针读写线程局部变量而不附加同步\",{\"1\":{\"45\":1}}],[\"其它线程会等待初始化完成\",{\"1\":{\"33\":1}}],[\"其它方面就得自己保证了\",{\"1\":{\"36\":1}}],[\"其中有许多的\",{\"1\":{\"107\":1}}],[\"其中有一段话说得很直接\",{\"1\":{\"76\":1}}],[\"其中第二个重载只是给了一个执行策略并将参数全部转发\",{\"1\":{\"107\":1}}],[\"其中的大部分接口实际上是调用\",{\"1\":{\"107\":1}}],[\"其中的数据成员也是不同的\",{\"1\":{\"102\":1}}],[\"其中的重中之重就是它的构造\",{\"1\":{\"17\":1}}],[\"其中包含\",{\"1\":{\"79\":1}}],[\"其中不同的任务或操作按顺序执行\",{\"1\":{\"46\":1}}],[\"其中每个线程都有一个互斥量\",{\"1\":{\"30\":1}}],[\"其他所有的线程\",{\"1\":{\"26\":1}}],[\"其相当于实现了一个公共的\",{\"1\":{\"26\":1}}],[\"其主要在于\",{\"1\":{\"22\":1}}],[\"其次是篇幅限制\",{\"1\":{\"110\":1}}],[\"其次是\",{\"1\":{\"15\":1}}],[\"其局部对象正常析构释放\",{\"1\":{\"12\":1}}],[\"其实绝大部分开发者使用线程池\",{\"1\":{\"116\":1}}],[\"其实各位不用着急完全理解\",{\"1\":{\"110\":1}}],[\"其实又是回去调用父类的虚函数了\",{\"1\":{\"108\":1}}],[\"其实先前已经聊过很多次了\",{\"1\":{\"108\":1}}],[\"其实还有两种特化\",{\"1\":{\"108\":1}}],[\"其实还有不少其他的做法或者反例\",{\"1\":{\"33\":1}}],[\"其实重中之重主要是那几个类\",{\"1\":{\"108\":1}}],[\"其实这很简单\",{\"1\":{\"104\":1}}],[\"其实这段代码还存在着一个初始化顺序导致的问题\",{\"1\":{\"50\":1}}],[\"其实很简单\",{\"1\":{\"99\":1}}],[\"其实很多时候根本没这种性能的担忧\",{\"1\":{\"75\":1}}],[\"其实并不是什么复杂的东西\",{\"1\":{\"76\":1}}],[\"其实默认类型就是\",{\"1\":{\"59\":1}}],[\"其实不算难\",{\"1\":{\"103\":1}}],[\"其实不同无非是定义了\",{\"1\":{\"53\":1}}],[\"其实不用感到奇怪\",{\"1\":{\"32\":1}}],[\"其实\",{\"1\":{\"53\":1,\"107\":1}}],[\"其实到此基本就差不多了\",{\"1\":{\"52\":1}}],[\"其实第一种方法就是在说\",{\"1\":{\"47\":1}}],[\"其实也就可以理解为表示时间点的精度\",{\"1\":{\"60\":1}}],[\"其实也就是回到了第一个示例的问题\",{\"1\":{\"30\":1}}],[\"其实也就是指管理\",{\"1\":{\"11\":1}}],[\"其实也就是要\",{\"1\":{\"10\":1}}],[\"其实也还是别名罢了\",{\"1\":{\"59\":1}}],[\"其实也很简单\",{\"1\":{\"35\":1}}],[\"其实理论上你\",{\"1\":{\"32\":1}}],[\"其实只是传递了它们的指针或者引用罢了\",{\"1\":{\"32\":2}}],[\"其实倒也还好\",{\"1\":{\"31\":1}}],[\"其实上面的代码还不够简单直接\",{\"1\":{\"31\":1}}],[\"其实简单来说\",{\"1\":{\"21\":1}}],[\"其实就是代表这个成员函数只能调用一次\",{\"1\":{\"108\":1}}],[\"其实就是父类指针指向了子类对象\",{\"1\":{\"107\":1}}],[\"其实就是把元组给解包了\",{\"1\":{\"103\":1}}],[\"其实就是先前讲的\",{\"1\":{\"57\":1}}],[\"其实就是在传递可调用对象与参数之前传递枚举值罢了\",{\"1\":{\"52\":1}}],[\"其实就是线程对象自己调用\",{\"1\":{\"21\":1}}],[\"其实就是\",{\"1\":{\"14\":1}}],[\"其实可以直接简单理解为\",{\"1\":{\"3\":1}}],[\"其成员函数也很少\",{\"1\":{\"9\":1}}],[\"如线程池\",{\"1\":{\"118\":1}}],[\"如新任务加入队列\",{\"1\":{\"116\":1}}],[\"如任务队列\",{\"1\":{\"116\":1}}],[\"如内存访问的优化\",{\"1\":{\"81\":1}}],[\"如读写锁\",{\"1\":{\"75\":1}}],[\"如互斥量\",{\"1\":{\"74\":1}}],[\"如其名所示\",{\"1\":{\"72\":1}}],[\"如上\",{\"1\":{\"59\":1}}],[\"如上所示\",{\"1\":{\"55\":1}}],[\"如之前所提到\",{\"1\":{\"55\":1}}],[\"如同规则\",{\"1\":{\"81\":1}}],[\"如同没有线程资源所有权的\",{\"1\":{\"52\":1}}],[\"如同第一个示例那样\",{\"1\":{\"30\":1}}],[\"如下\",{\"1\":{\"31\":1,\"48\":1,\"99\":2}}],[\"如何创建的\",{\"1\":{\"110\":1}}],[\"如何创建的线程\",{\"1\":{\"17\":1,\"100\":1}}],[\"如何对内存操作的顺序和一致性进行规范\",{\"1\":{\"85\":1}}],[\"如何做到接受任意可调用对象\",{\"1\":{\"17\":1,\"100\":1}}],[\"如何做到的默认按值复制\",{\"1\":{\"17\":1,\"100\":1}}],[\"如何支持只能移动的对象\",{\"1\":{\"17\":1,\"100\":1}}],[\"如\",{\"1\":{\"17\":1,\"50\":1,\"60\":2,\"71\":1,\"75\":1,\"79\":1,\"82\":1,\"92\":2,\"95\":1,\"97\":1,\"106\":1,\"107\":1,\"110\":1}}],[\"如你所见它的形参类型是\",{\"1\":{\"99\":1}}],[\"如你所见很简单\",{\"1\":{\"31\":1}}],[\"如你所见\",{\"1\":{\"9\":1,\"31\":2,\"52\":3,\"58\":1,\"60\":1,\"75\":1,\"99\":1,\"104\":1}}],[\"如果等待线程池对象调用析构函数\",{\"1\":{\"116\":1}}],[\"如果读者学过\",{\"1\":{\"115\":1}}],[\"如果结果尚未准备好\",{\"1\":{\"109\":1}}],[\"如果存在存储的异常\",{\"1\":{\"109\":1}}],[\"如果拥有共享状态则继续\",{\"1\":{\"108\":1}}],[\"如果二次调用\",{\"1\":{\"107\":1}}],[\"如果线程启动失败\",{\"1\":{\"99\":1}}],[\"如果线程句柄\",{\"1\":{\"99\":1}}],[\"如果线程\",{\"1\":{\"82\":2}}],[\"如果线程被回收并用于新的\",{\"1\":{\"38\":1}}],[\"如果要传递引用\",{\"1\":{\"100\":1}}],[\"如果要操作其保护的共享指针指向的资源还是得\",{\"1\":{\"79\":1}}],[\"如果要支持\",{\"1\":{\"37\":1}}],[\"如果多个线程同时访问同一个\",{\"1\":{\"79\":1}}],[\"如果相等则将其更新为新值并返回\",{\"1\":{\"77\":1}}],[\"如果原子变量的赋值操作返回了一个引用\",{\"1\":{\"77\":1}}],[\"如果发现某些原子类型在目标平台上是有锁的\",{\"1\":{\"75\":1}}],[\"如果一个类型的原子操作总是无锁的\",{\"1\":{\"75\":1}}],[\"如果一个线程写入原子对象\",{\"1\":{\"75\":1}}],[\"如果这些操作在目标平台上是有锁的\",{\"1\":{\"75\":1}}],[\"如果我们不自己指明线程池的线程数量\",{\"1\":{\"114\":1}}],[\"如果我们知道某些操作在目标平台上是无锁的\",{\"1\":{\"75\":1}}],[\"如果我们的\",{\"1\":{\"14\":1}}],[\"如果信号量只有二进制的\",{\"1\":{\"72\":1}}],[\"如果使用的是一个功能丰富的设施\",{\"1\":{\"70\":1}}],[\"如果使用这个构造函数\",{\"1\":{\"27\":1}}],[\"如果当前值为\",{\"1\":{\"77\":1}}],[\"如果当前环境上的原子类型\",{\"1\":{\"75\":1}}],[\"如果当前信号量的计数值为\",{\"1\":{\"68\":2}}],[\"如果当前有活跃线程\",{\"1\":{\"18\":1}}],[\"如果在主线程中执行耗时任务会导致界面卡顿\",{\"1\":{\"61\":1}}],[\"如果在指定的超时间隔后仍然无法得到结果\",{\"1\":{\"59\":1}}],[\"如果超过了这个时间还没有被唤醒\",{\"1\":{\"60\":1}}],[\"如果超线程被启用\",{\"1\":{\"45\":1}}],[\"如果需要进行多次\",{\"1\":{\"55\":1}}],[\"如果先前调用了\",{\"1\":{\"54\":1}}],[\"如果promise的值还没有被设置\",{\"1\":{\"54\":1}}],[\"如果想要异步的获取返回值\",{\"1\":{\"53\":1}}],[\"如果从\",{\"1\":{\"52\":1}}],[\"如果系统资源有限\",{\"1\":{\"52\":1}}],[\"如果系统资源充足\",{\"1\":{\"52\":1}}],[\"如果只是为了播放\",{\"1\":{\"50\":1}}],[\"如果队列为空\",{\"1\":{\"49\":1}}],[\"如果队列中有任务\",{\"1\":{\"49\":1}}],[\"如果每次播放提示音时都新建一个线程\",{\"1\":{\"49\":1}}],[\"如果它们不是线程安全的\",{\"1\":{\"45\":1}}],[\"如果构造函数\",{\"1\":{\"36\":1}}],[\"如果\",{\"1\":{\"36\":1,\"38\":1,\"54\":1,\"109\":2}}],[\"如果用外部代码要获取一个锁\",{\"1\":{\"30\":1}}],[\"如果必须要获取多个锁\",{\"1\":{\"30\":1}}],[\"如果按照前面的的选择一个固定的顺序上锁解锁\",{\"1\":{\"30\":1}}],[\"如果两个线程同时运行\",{\"1\":{\"30\":1}}],[\"如果上锁成功就返回\",{\"1\":{\"28\":1}}],[\"如果互斥量是锁定的\",{\"1\":{\"26\":1}}],[\"如果出现数据竞争\",{\"1\":{\"25\":1}}],[\"如果非要使用\",{\"1\":{\"21\":1}}],[\"如果您对内存次序感兴趣\",{\"1\":{\"81\":1}}],[\"如果您主要关注业务开发\",{\"1\":{\"81\":1}}],[\"如果您是\",{\"1\":{\"66\":1}}],[\"如果您好好的学习了上一节的内容\",{\"1\":{\"18\":1}}],[\"如果您支持\",{\"1\":{\"15\":1}}],[\"如果标准达到\",{\"1\":{\"16\":1}}],[\"如果还没完成就调用\",{\"1\":{\"15\":1}}],[\"如果还有不理解\",{\"1\":{\"14\":1}}],[\"如果不是同一\",{\"1\":{\"79\":1}}],[\"如果不满足要求\",{\"1\":{\"75\":1}}],[\"如果不这样做\",{\"1\":{\"62\":1}}],[\"如果不写此弃值表达式\",{\"1\":{\"38\":1}}],[\"如果不使用线程\",{\"1\":{\"62\":1}}],[\"如果不使用\",{\"1\":{\"14\":1}}],[\"如果不想等待线程结束可以使用\",{\"1\":{\"13\":1}}],[\"如果对他们的实现感兴趣\",{\"1\":{\"14\":1}}],[\"如果有兴趣\",{\"1\":{\"116\":1}}],[\"如果有两个线程运行这段代码\",{\"1\":{\"28\":1}}],[\"如果有\",{\"1\":{\"13\":1}}],[\"如果异常被抛出但未被捕获那么就会调用\",{\"1\":{\"13\":1}}],[\"如果抛出异常\",{\"1\":{\"12\":1}}],[\"如果抛出了异常\",{\"1\":{\"12\":1}}],[\"如果代码里抛出了异常\",{\"1\":{\"12\":1}}],[\"如果是标量类型\",{\"1\":{\"95\":1}}],[\"如果是整数类型的特化\",{\"1\":{\"75\":1}}],[\"如果是\",{\"1\":{\"52\":1}}],[\"如果是测试使用\",{\"1\":{\"50\":1}}],[\"如果是自己重载\",{\"1\":{\"36\":1}}],[\"如果是默认构造之类的\",{\"1\":{\"12\":1}}],[\"如果是普通代码\",{\"1\":{\"1\":1}}],[\"如果你对此网站的使用不熟悉\",{\"1\":{\"94\":1}}],[\"如果你从事嵌入式系统或者学术研究等\",{\"1\":{\"85\":1}}],[\"如果你使用基于系统时钟的计时方法\",{\"1\":{\"60\":1}}],[\"如果你阅读\",{\"1\":{\"52\":1}}],[\"如果你需要更多的操作\",{\"1\":{\"36\":1}}],[\"如果你需要多线程求和\",{\"1\":{\"10\":1}}],[\"如果你的标准达到\",{\"1\":{\"36\":1}}],[\"如果你的同事或上司写出此代码\",{\"1\":{\"33\":1}}],[\"如果你学过其它语言或者操作系统\",{\"1\":{\"34\":1}}],[\"如果你有需要\",{\"1\":{\"33\":1}}],[\"如果你有些地方无法理解\",{\"1\":{\"16\":1}}],[\"如果你觉得难以理解\",{\"1\":{\"33\":1}}],[\"如果你觉得本仓库对你有所帮助\",{\"1\":{\"0\":1}}],[\"如果你简单写一个\",{\"1\":{\"32\":1}}],[\"如果你自己编译了这些代码\",{\"1\":{\"18\":1}}],[\"如果你直接用一个循环不断判断这个操作是否完成就会使得这个线程占满\",{\"1\":{\"15\":1}}],[\"如果你是第一次见到成员指针\",{\"1\":{\"14\":1}}],[\"如果你传入的是一个临时对象\",{\"1\":{\"12\":1}}],[\"如果希望代码可以在\",{\"1\":{\"10\":1}}],[\"如果为\",{\"1\":{\"9\":1}}],[\"如果没有同步\",{\"1\":{\"72\":1}}],[\"如果没有指明\",{\"1\":{\"59\":1}}],[\"如果没有进行同步保护\",{\"1\":{\"56\":2}}],[\"如果没有找到键返回空字符串\",{\"1\":{\"34\":1}}],[\"如果没有线程持有这个互斥量\",{\"1\":{\"26\":1}}],[\"如果没有\",{\"1\":{\"0\":1}}],[\"会先进行\",{\"1\":{\"116\":1}}],[\"会根据函数\",{\"1\":{\"114\":1}}],[\"会再次进入休眠状态\",{\"1\":{\"112\":1}}],[\"会重新检查条件\",{\"1\":{\"108\":1}}],[\"会被定义为\",{\"1\":{\"107\":1}}],[\"会不会指令重排导致先输出\",{\"1\":{\"81\":1}}],[\"会保证外部行为的一致性\",{\"1\":{\"81\":1}}],[\"会将指针\",{\"1\":{\"78\":1}}],[\"会在期待计数减少至\",{\"1\":{\"71\":1}}],[\"会看到先输出\",{\"1\":{\"68\":1}}],[\"会返回系统的当前时间\",{\"1\":{\"58\":1}}],[\"会进行其它处理\",{\"1\":{\"57\":1}}],[\"会抛出\",{\"1\":{\"54\":1}}],[\"会通过\",{\"1\":{\"52\":1}}],[\"会发现的确如此\",{\"1\":{\"52\":1}}],[\"会使用到\",{\"1\":{\"45\":1}}],[\"会作为线程启动的一部分进行\",{\"1\":{\"43\":1}}],[\"会输出\",{\"1\":{\"38\":2}}],[\"会优化掉\",{\"1\":{\"38\":1}}],[\"会按照互斥量的规则进行阻塞\",{\"1\":{\"35\":1}}],[\"会让传入的可调用对象被多次调用\",{\"1\":{\"33\":1}}],[\"会持有一个悬垂指针\",{\"1\":{\"32\":1}}],[\"会尝试上锁\",{\"1\":{\"28\":1}}],[\"会详细了解这个类\",{\"1\":{\"27\":1}}],[\"会打印出了一样的值\",{\"1\":{\"27\":1}}],[\"会多\",{\"1\":{\"20\":1}}],[\"会导致问题\",{\"1\":{\"14\":1}}],[\"会自动调用对象的析构函数\",{\"1\":{\"13\":1}}],[\"会产生未定义行为\",{\"1\":{\"12\":1}}],[\"会调用第一个版本的重载\",{\"1\":{\"47\":1}}],[\"会调用\",{\"1\":{\"9\":1,\"21\":1}}],[\"会讨论程序的并发性\",{\"1\":{\"6\":1}}],[\"会讨论程序的并行性\",{\"1\":{\"6\":1}}],[\"判断线程对象目前是否有关联活跃线程\",{\"1\":{\"9\":1}}],[\"返回当前活跃线程数等\",{\"1\":{\"116\":1}}],[\"返回当前线程\",{\"1\":{\"15\":1}}],[\"返回结果\",{\"1\":{\"109\":2}}],[\"返回底层\",{\"1\":{\"107\":1}}],[\"返回引用类型\",{\"1\":{\"107\":1}}],[\"返回普通类型\",{\"1\":{\"107\":1}}],[\"返回类型不为\",{\"1\":{\"103\":1}}],[\"返回类型都是\",{\"1\":{\"103\":1}}],[\"返回类型推导是\",{\"1\":{\"10\":1}}],[\"返回了\",{\"1\":{\"79\":1}}],[\"返回操作前的指针值\",{\"1\":{\"78\":2}}],[\"返回一个普通的\",{\"1\":{\"77\":1}}],[\"返回的内部类\",{\"1\":{\"66\":1}}],[\"返回的临时\",{\"1\":{\"16\":1}}],[\"返回值\",{\"1\":{\"55\":1}}],[\"返回执行结果\",{\"1\":{\"52\":1}}],[\"返回与\",{\"1\":{\"21\":2}}],[\"返回\",{\"1\":{\"9\":1,\"14\":1,\"75\":2,\"76\":1,\"77\":1,\"99\":1,\"107\":2,\"108\":2,\"109\":1}}],[\"让操作系统自行调度而已\",{\"1\":{\"116\":1}}],[\"让元组保有的互斥量引用都进行解锁\",{\"1\":{\"103\":1}}],[\"让你对它再无疑问\",{\"1\":{\"101\":1}}],[\"让你彻底了解这个类\",{\"1\":{\"97\":1}}],[\"让一些线程退出同步\",{\"1\":{\"71\":1}}],[\"让我们得以简单的使用\",{\"1\":{\"59\":1}}],[\"让它能在需要的时候获取\",{\"1\":{\"56\":1}}],[\"让它和\",{\"1\":{\"53\":1}}],[\"让另外的线程有机会获取锁并设置标识\",{\"1\":{\"47\":1}}],[\"让其他线程得以执行\",{\"1\":{\"76\":1}}],[\"让其选择到不上锁的构造函数\",{\"1\":{\"30\":1}}],[\"让其关联的线程执行成员函数\",{\"1\":{\"14\":1}}],[\"让持有线程资源的\",{\"1\":{\"16\":1}}],[\"让当前线程延迟到具体的时间\",{\"1\":{\"15\":1}}],[\"让对象的生命周期和资源绑定\",{\"1\":{\"13\":1}}],[\"让\",{\"1\":{\"9\":1}}],[\"然后安排线程去执行\",{\"1\":{\"116\":1}}],[\"然后将任务对象传递给线程池的\",{\"1\":{\"115\":1}}],[\"然后唤醒所有线程\",{\"1\":{\"114\":1}}],[\"然后继续执行\",{\"1\":{\"108\":1}}],[\"然后也就和上面说的没什么区别了\",{\"1\":{\"107\":1}}],[\"然后就用\",{\"1\":{\"103\":1}}],[\"然后就是推荐使用\",{\"1\":{\"76\":1}}],[\"然后调用函数\",{\"1\":{\"108\":1}}],[\"然后调用\",{\"1\":{\"99\":1}}],[\"然后退出循环\",{\"1\":{\"76\":1}}],[\"然后在当前阶段的同步点阻塞直至运行当前阶段的阶段完成步骤\",{\"1\":{\"71\":1}}],[\"然后在循环中制造任务插入容器\",{\"1\":{\"53\":1}}],[\"然后利用了屏障一轮一轮地打印\",{\"1\":{\"71\":1}}],[\"然后\",{\"1\":{\"54\":1,\"109\":1}}],[\"然后我们来传递任务进行异步调用等操作\",{\"1\":{\"53\":1}}],[\"然后使用\",{\"1\":{\"53\":1,\"60\":1,\"100\":1}}],[\"然后逐个执行\",{\"1\":{\"52\":1}}],[\"然后再进行\",{\"1\":{\"114\":1}}],[\"然后再去调用父类\",{\"1\":{\"108\":1}}],[\"然后再写入另一个对象\",{\"1\":{\"76\":1}}],[\"然后再获取返回值\",{\"1\":{\"53\":1}}],[\"然后再自己进行上层封装\",{\"1\":{\"49\":1}}],[\"然后再尝试锁定\",{\"1\":{\"30\":1}}],[\"然后设置一个稍早的闹钟\",{\"1\":{\"47\":1}}],[\"然后聊了一下\",{\"1\":{\"45\":1}}],[\"然后讨论了面对不同情况保护共享数据的不同方式\",{\"1\":{\"45\":1}}],[\"然后传递\",{\"1\":{\"31\":1}}],[\"然后作用域结束\",{\"1\":{\"27\":1}}],[\"然后执行\",{\"1\":{\"25\":1}}],[\"然后来管理函数到底如何执行\",{\"1\":{\"22\":1}}],[\"然后这个临时对象再用来初始化\",{\"1\":{\"16\":1}}],[\"然后返回它\",{\"1\":{\"16\":1}}],[\"然后会修改对象的状态\",{\"1\":{\"9\":1}}],[\"然而新任务的到来让调度器再次将它唤醒\",{\"1\":{\"112\":1}}],[\"然而这其实并不是\",{\"1\":{\"112\":1}}],[\"然而这还不够\",{\"1\":{\"108\":1}}],[\"然而这显然没用\",{\"1\":{\"33\":1}}],[\"然而它也是最为复杂的\",{\"1\":{\"107\":1}}],[\"然而它们的帮助都是有限的\",{\"1\":{\"30\":1}}],[\"然而要想阅读学习源码\",{\"1\":{\"93\":1}}],[\"然而值得注意的是\",{\"1\":{\"52\":1}}],[\"然而\",{\"1\":{\"52\":1,\"68\":1,\"79\":1,\"108\":1}}],[\"然而在某些情况下\",{\"1\":{\"35\":1}}],[\"然而使用\",{\"1\":{\"34\":1}}],[\"然而使用互斥量来保护共享数据也并不是在函数中加上一个\",{\"1\":{\"29\":1}}],[\"然而函数\",{\"1\":{\"30\":1}}],[\"然而此时我们必须再次\",{\"1\":{\"12\":1}}],[\"然而大多数是粗糙的\",{\"1\":{\"0\":1}}],[\"否则它为空\",{\"1\":{\"107\":1}}],[\"否则会抛出异常\",{\"1\":{\"55\":1}}],[\"否则将所有权层数减少\",{\"1\":{\"35\":1}}],[\"否则将一直阻塞\",{\"1\":{\"9\":1}}],[\"否则\",{\"1\":{\"9\":1,\"77\":1,\"109\":1}}],[\"就足够编写一个满足绝大部分业务需求的线程池\",{\"1\":{\"116\":1}}],[\"就如同我们先前聊\",{\"1\":{\"101\":1}}],[\"就如同我们先前所说\",{\"1\":{\"56\":1}}],[\"就比如它们\",{\"1\":{\"100\":1}}],[\"就接受了我们构造\",{\"1\":{\"99\":1}}],[\"就等于\",{\"1\":{\"99\":1}}],[\"就涉及到可见的问题\",{\"1\":{\"82\":1}}],[\"就算真的\",{\"1\":{\"81\":1}}],[\"就重置期待计数为构造中指定的值了\",{\"1\":{\"71\":1}}],[\"就不再重复\",{\"1\":{\"103\":1}}],[\"就不再需要使用\",{\"1\":{\"76\":1}}],[\"就不需要再强调了\",{\"1\":{\"56\":1}}],[\"就不可再次调用\",{\"1\":{\"54\":1}}],[\"就无法再用于其他线程\",{\"1\":{\"56\":1}}],[\"就\",{\"1\":{\"53\":1}}],[\"就取出并播放提示音\",{\"1\":{\"49\":1}}],[\"就启动一个专门用于播放提示音的线程\",{\"1\":{\"49\":1}}],[\"就光是其频繁创建线程的开销也是不能接受的\",{\"1\":{\"49\":1}}],[\"就休息\",{\"1\":{\"47\":1}}],[\"就像线程变量为每个线程提供独立的对象实例\",{\"1\":{\"39\":1}}],[\"就得使用互斥量之类的方式保护了\",{\"1\":{\"36\":1}}],[\"就可能会导致数据竞争和未定义行为\",{\"1\":{\"36\":1}}],[\"就可以执行了\",{\"1\":{\"99\":1}}],[\"就可以解决这个问题\",{\"1\":{\"71\":1}}],[\"就可以\",{\"1\":{\"33\":1}}],[\"就可以尽情玩耍\",{\"1\":{\"30\":1}}],[\"就可以进去执行了\",{\"1\":{\"27\":1}}],[\"就别再获取第二个锁\",{\"1\":{\"30\":1}}],[\"就有死锁风险\",{\"1\":{\"30\":1}}],[\"就通常不会死锁\",{\"1\":{\"30\":1}}],[\"就应该是单纯的在受互斥量保护的情况下老老实实调用\",{\"1\":{\"29\":1}}],[\"就万事大吉了\",{\"1\":{\"29\":1}}],[\"就更简单了\",{\"1\":{\"27\":1}}],[\"就解锁了互斥量\",{\"1\":{\"26\":1}}],[\"就要避免其它线程修改\",{\"1\":{\"30\":1}}],[\"就要开始聊共享数据的那些事\",{\"1\":{\"24\":1}}],[\"就要特别注意了\",{\"1\":{\"14\":1}}],[\"就好\",{\"1\":{\"21\":1}}],[\"就能明白\",{\"1\":{\"79\":1}}],[\"就能让这种保护形同虚设\",{\"1\":{\"29\":1}}],[\"就能成功调用\",{\"1\":{\"14\":1}}],[\"就能正常的调用\",{\"1\":{\"12\":1}}],[\"就在\",{\"1\":{\"12\":1}}],[\"就会抛出\",{\"1\":{\"107\":1}}],[\"就会导致编译错误\",{\"1\":{\"52\":1}}],[\"就会阻塞直到\",{\"1\":{\"52\":1}}],[\"就会违反第一个指导意见\",{\"1\":{\"30\":1}}],[\"就会产生死锁\",{\"1\":{\"30\":1}}],[\"就会跳转到\",{\"1\":{\"12\":1}}],[\"就会被跳过\",{\"1\":{\"12\":1}}],[\"就手搓了一个\",{\"1\":{\"10\":1}}],[\"就是被调度器分配了任务1\",{\"1\":{\"112\":1}}],[\"就是单纯的执行延时任务而已\",{\"1\":{\"109\":1}}],[\"就是直接调用父类虚函数\",{\"1\":{\"108\":1}}],[\"就是执行我们实际传入的函数对象\",{\"1\":{\"108\":1}}],[\"就是解锁然后调用\",{\"1\":{\"108\":1}}],[\"就是我们前面讲的\",{\"1\":{\"99\":1}}],[\"就是接受一个元组类型\",{\"1\":{\"99\":1}}],[\"就是占据\",{\"1\":{\"98\":1}}],[\"就是在原子类型的类型名前面加上\",{\"1\":{\"75\":1}}],[\"就是主线程\",{\"1\":{\"64\":1}}],[\"就是时间的间隔\",{\"1\":{\"60\":1}}],[\"就是一个稳定时钟\",{\"1\":{\"58\":1}}],[\"就是其关联的事件\",{\"1\":{\"51\":1}}],[\"就是调用移动构造\",{\"1\":{\"32\":1}}],[\"就是按引用传递了\",{\"1\":{\"14\":1}}],[\"就是返回了\",{\"1\":{\"14\":1}}],[\"就是\",{\"1\":{\"14\":1,\"58\":1,\"99\":1,\"108\":1,\"114\":1}}],[\"就是构造\",{\"1\":{\"12\":1}}],[\"就是确保线程对象关联的线程已经执行完毕\",{\"1\":{\"9\":1}}],[\"就是为了区别多线程中不同的关注点\",{\"1\":{\"6\":1}}],[\"就自动在新线程开始执行函数\",{\"1\":{\"9\":1}}],[\"将任务提交到任务队列\",{\"1\":{\"116\":1}}],[\"将任务传递给线程池后可以再指明执行策略\",{\"1\":{\"115\":1}}],[\"将任务加入线程池\",{\"1\":{\"114\":2}}],[\"将结果或异常存储在\",{\"1\":{\"107\":1}}],[\"将我们\",{\"1\":{\"107\":1}}],[\"将我们构造函数的参数全部完美转发\",{\"1\":{\"99\":1}}],[\"将线程id设置为0\",{\"1\":{\"99\":1}}],[\"将独占指针的所有权转移给线程\",{\"1\":{\"99\":1}}],[\"将原子对象的值设置给\",{\"1\":{\"77\":1}}],[\"将原子对象的值加载进\",{\"1\":{\"77\":1}}],[\"将原子对象\",{\"1\":{\"77\":1}}],[\"将是\",{\"1\":{\"77\":1}}],[\"将标志对象的状态原子地更改为设置\",{\"1\":{\"76\":1}}],[\"将标志对象的状态原子地更改为清除\",{\"1\":{\"76\":1}}],[\"将返回\",{\"1\":{\"75\":1}}],[\"将它视为信号量维护的计数最大值即可\",{\"1\":{\"68\":1}}],[\"将当前对象的共享状态转移给了这个局部对象\",{\"1\":{\"55\":1}}],[\"将错误码设置为\",{\"1\":{\"54\":1}}],[\"将持有最终计算出来的结果\",{\"1\":{\"52\":1}}],[\"将互斥量的所有权转移给调用方\",{\"1\":{\"32\":1}}],[\"将数据成员赋给新对象\",{\"1\":{\"32\":1}}],[\"将临时对象的线程资源所有权移交给\",{\"1\":{\"16\":1}}],[\"将对象包装\",{\"1\":{\"14\":1}}],[\"将\",{\"1\":{\"9\":1,\"12\":1,\"14\":1,\"16\":3,\"70\":1,\"76\":3,\"81\":1,\"99\":1,\"107\":1,\"109\":1}}],[\"java\",{\"1\":{\"92\":1,\"115\":1}}],[\"joining\",{\"1\":{\"18\":11}}],[\"joinable\",{\"1\":{\"9\":2,\"12\":3,\"13\":1,\"16\":4,\"18\":4,\"21\":1,\"49\":1,\"116\":1}}],[\"join\",{\"1\":{\"9\":3,\"10\":2,\"12\":26,\"13\":4,\"14\":7,\"15\":1,\"16\":11,\"18\":8,\"19\":1,\"21\":4,\"25\":4,\"26\":2,\"27\":4,\"28\":2,\"35\":2,\"37\":2,\"38\":1,\"49\":1,\"52\":1,\"53\":3,\"54\":3,\"56\":6,\"79\":2,\"114\":9,\"116\":2}}],[\"jthread>\",{\"1\":{\"21\":1,\"68\":1,\"70\":1,\"71\":2}}],[\"jthread\",{\"1\":{\"8\":1,\"19\":1,\"20\":3,\"21\":12,\"23\":1,\"68\":1,\"70\":1}}],[\"<functional>\",{\"1\":{\"116\":1}}],[\"<future>\",{\"1\":{\"51\":1,\"52\":1,\"116\":1}}],[\"<syncstream>\",{\"1\":{\"116\":1}}],[\"<semaphore>\",{\"1\":{\"68\":1}}],[\"<vector>\",{\"1\":{\"116\":1}}],[\"<typename\",{\"1\":{\"115\":1}}],[\"<thread>\",{\"1\":{\"9\":1,\"10\":1,\"12\":2,\"35\":1,\"52\":1,\"116\":1}}],[\"<queue>\",{\"1\":{\"116\":1}}],[\"<qdebug>\",{\"1\":{\"115\":1}}],[\"<qrunnable>\",{\"1\":{\"115\":1}}],[\"<qthreadpool>\",{\"1\":{\"115\":1}}],[\"<qcoreapplication>\",{\"1\":{\"115\":1}}],[\"<boost\",{\"1\":{\"114\":1}}],[\"<barrier>\",{\"1\":{\"69\":1}}],[\"<>\",{\"1\":{\"102\":1,\"107\":1,\"108\":1}}],[\"<atomic>\",{\"1\":{\"75\":1,\"116\":1}}],[\"<latch>\",{\"1\":{\"69\":1}}],[\"<condition\",{\"1\":{\"47\":1,\"116\":1}}],[\"<class\",{\"1\":{\"21\":1,\"27\":1,\"47\":1,\"52\":1,\"59\":1,\"99\":6,\"102\":2,\"107\":12,\"108\":2,\"109\":1}}],[\"<mutex>\",{\"1\":{\"26\":1,\"35\":1,\"116\":1}}],[\"<=\",{\"1\":{\"12\":1,\"64\":1,\"71\":3}}],[\"<\",{\"1\":{\"10\":5,\"18\":2,\"26\":2,\"48\":2,\"53\":3,\"62\":1,\"68\":1,\"70\":1,\"71\":1,\"79\":4,\"114\":2,\"115\":1,\"116\":3}}],[\"<<qstring\",{\"1\":{\"115\":1}}],[\"<<threadpool\",{\"1\":{\"115\":1}}],[\"<<\",{\"1\":{\"9\":4,\"10\":3,\"12\":2,\"14\":12,\"15\":13,\"16\":10,\"18\":6,\"21\":4,\"25\":4,\"26\":4,\"27\":5,\"28\":12,\"33\":3,\"35\":10,\"37\":6,\"38\":6,\"47\":2,\"48\":6,\"49\":3,\"52\":26,\"53\":6,\"54\":15,\"55\":8,\"56\":22,\"58\":4,\"59\":6,\"60\":3,\"68\":8,\"70\":5,\"71\":18,\"75\":25,\"76\":2,\"77\":2,\"79\":16,\"103\":2,\"114\":5,\"115\":2,\"116\":7}}],[\"<iostream>\",{\"1\":{\"9\":2,\"10\":1,\"12\":2,\"35\":1,\"52\":1,\"95\":1,\"114\":1,\"116\":1}}],[\"mt19937\",{\"1\":{\"68\":1}}],[\"mtxes\",{\"1\":{\"102\":7,\"103\":7}}],[\"mtx\",{\"1\":{\"27\":4,\"28\":3,\"31\":2,\"35\":4,\"47\":5,\"49\":3,\"102\":4,\"107\":1,\"108\":2,\"109\":1}}],[\"ms\",{\"1\":{\"59\":4}}],[\"msvc\",{\"1\":{\"0\":1,\"20\":1,\"21\":1,\"22\":1,\"27\":1,\"31\":1,\"37\":6,\"38\":2,\"47\":1,\"52\":2,\"55\":1,\"59\":1,\"68\":1,\"71\":1,\"75\":1,\"76\":1,\"94\":3,\"97\":2,\"99\":1,\"100\":1,\"101\":2,\"103\":1,\"106\":2,\"107\":1}}],[\"module\",{\"1\":{\"107\":1}}],[\"model\",{\"1\":{\"85\":1}}],[\"modify\",{\"1\":{\"75\":1}}],[\"months\",{\"1\":{\"59\":1}}],[\"move\",{\"1\":{\"14\":9,\"16\":5,\"18\":4,\"32\":1,\"52\":16,\"53\":3,\"54\":4,\"55\":7,\"75\":2,\"95\":9,\"99\":2,\"100\":3,\"108\":8,\"116\":1}}],[\"mq白\",{\"1\":{\"51\":1}}],[\"millisecond\",{\"1\":{\"59\":1}}],[\"milliseconds>\",{\"1\":{\"60\":1}}],[\"milliseconds\",{\"1\":{\"28\":1,\"47\":1,\"59\":3,\"60\":1}}],[\"milli\",{\"1\":{\"59\":1}}],[\"milli>\",{\"1\":{\"59\":1}}],[\"microsecond\",{\"1\":{\"59\":1}}],[\"microseconds\",{\"1\":{\"59\":1}}],[\"micro>\",{\"1\":{\"59\":1}}],[\"minimum\",{\"1\":{\"64\":2}}],[\"minimp3\",{\"1\":{\"50\":2}}],[\"minute\",{\"1\":{\"59\":1}}],[\"minutes\",{\"1\":{\"58\":2,\"59\":1}}],[\"mp3\",{\"1\":{\"50\":3}}],[\"meet\",{\"1\":{\"108\":1}}],[\"memcpy\",{\"1\":{\"90\":1}}],[\"memcmp\",{\"1\":{\"90\":1}}],[\"memory\",{\"1\":{\"25\":1,\"75\":13,\"76\":6,\"77\":6,\"78\":1,\"82\":3,\"83\":30,\"85\":2}}],[\"meyers\",{\"1\":{\"33\":1}}],[\"m2\",{\"1\":{\"30\":8,\"102\":2}}],[\"m1\",{\"1\":{\"30\":7,\"102\":3}}],[\"maybe\",{\"1\":{\"108\":5,\"109\":1}}],[\"manager\",{\"1\":{\"107\":7,\"108\":6}}],[\"manager<int>\",{\"1\":{\"108\":1}}],[\"manager<\",{\"1\":{\"107\":8,\"108\":4}}],[\"manages\",{\"1\":{\"107\":2}}],[\"max\",{\"1\":{\"68\":1,\"72\":1}}],[\"make\",{\"1\":{\"48\":1,\"79\":8,\"99\":6,\"103\":2,\"116\":1}}],[\"malloc\",{\"1\":{\"36\":1}}],[\"malicious\",{\"1\":{\"29\":3}}],[\"map<std\",{\"1\":{\"34\":1}}],[\"main\",{\"1\":{\"9\":2,\"10\":1,\"12\":4,\"14\":3,\"15\":4,\"16\":4,\"18\":3,\"21\":1,\"25\":2,\"26\":2,\"31\":2,\"33\":1,\"35\":1,\"37\":1,\"38\":1,\"52\":6,\"53\":1,\"54\":2,\"56\":3,\"63\":1,\"68\":8,\"70\":2,\"71\":2,\"79\":1,\"95\":1,\"114\":1,\"115\":1,\"116\":2}}],[\"must\",{\"1\":{\"108\":1}}],[\"music\",{\"1\":{\"49\":5}}],[\"mutable\",{\"1\":{\"34\":2,\"48\":1,\"71\":2}}],[\"mutexes>\",{\"1\":{\"102\":1}}],[\"mutexes\",{\"1\":{\"102\":6,\"103\":3}}],[\"mutex>sp\",{\"1\":{\"103\":1}}],[\"mutex>\",{\"1\":{\"27\":7,\"29\":1,\"30\":8,\"31\":5,\"32\":3,\"33\":1,\"34\":3,\"35\":1,\"47\":8,\"48\":4,\"49\":2,\"60\":1,\"74\":1,\"76\":1,\"102\":4,\"103\":1,\"114\":1,\"116\":2}}],[\"mutex\",{\"1\":{\"26\":2,\"27\":9,\"28\":1,\"29\":1,\"30\":2,\"31\":7,\"32\":10,\"34\":12,\"35\":6,\"45\":4,\"47\":4,\"48\":1,\"49\":1,\"60\":1,\"68\":1,\"74\":1,\"76\":7,\"82\":2,\"102\":10,\"103\":2,\"107\":1,\"114\":1,\"116\":8}}],[\"multiply<ratio<146097\",{\"1\":{\"59\":1}}],[\"multiply<ratio<7>\",{\"1\":{\"59\":1}}],[\"multiply<ratio<24>\",{\"1\":{\"59\":1}}],[\"multi\",{\"1\":{\"10\":1}}],[\"mytask\",{\"1\":{\"115\":3}}],[\"mybase\",{\"1\":{\"107\":4,\"108\":6}}],[\"mymtx\",{\"1\":{\"47\":1}}],[\"mymutexes让它保有这些互斥量的引用\",{\"1\":{\"103\":2}}],[\"mymutexes\",{\"1\":{\"102\":4,\"103\":3}}],[\"mymutex\",{\"1\":{\"27\":5,\"102\":5}}],[\"mycnd\",{\"1\":{\"47\":1}}],[\"my\",{\"1\":{\"12\":10,\"33\":5,\"75\":6}}],[\"m\",{\"1\":{\"12\":3,\"13\":4,\"15\":3,\"26\":3,\"27\":9,\"29\":2,\"30\":11,\"31\":8,\"33\":1,\"34\":2,\"47\":3,\"48\":5,\"58\":2,\"60\":2,\"74\":2,\"76\":2,\"95\":1,\"103\":5,\"114\":2}}],[\"writer\",{\"1\":{\"79\":5}}],[\"write\",{\"1\":{\"75\":1}}],[\"wrapper<int>\",{\"1\":{\"14\":1}}],[\"wrapper<const\",{\"1\":{\"14\":2}}],[\"wrapper可以隐式转换为被包装对象的引用即可\",{\"1\":{\"14\":1}}],[\"wrapper\",{\"1\":{\"14\":1,\"29\":2}}],[\"wchar\",{\"1\":{\"75\":1}}],[\"weakly\",{\"1\":{\"85\":2}}],[\"weak\",{\"1\":{\"75\":2,\"77\":6,\"78\":1,\"79\":1}}],[\"weeks\",{\"1\":{\"59\":1}}],[\"web\",{\"1\":{\"5\":1,\"68\":2}}],[\"when\",{\"1\":{\"109\":1}}],[\"what\",{\"1\":{\"54\":2,\"55\":1,\"76\":2}}],[\"while\",{\"1\":{\"15\":1,\"21\":1,\"47\":4,\"49\":3,\"60\":1,\"76\":1,\"77\":1,\"108\":3,\"109\":1,\"116\":1}}],[\"would\",{\"1\":{\"31\":1}}],[\"worker\",{\"1\":{\"68\":1}}],[\"work\",{\"1\":{\"18\":3,\"70\":6}}],[\"world\",{\"0\":{\"9\":1},\"1\":{\"9\":3,\"10\":1,\"12\":1}}],[\"width\",{\"1\":{\"64\":1}}],[\"winmm\",{\"1\":{\"60\":1}}],[\"win32\",{\"1\":{\"37\":3,\"66\":1,\"69\":1,\"94\":1,\"98\":2,\"100\":2}}],[\"windows\",{\"1\":{\"14\":1,\"38\":2,\"39\":1,\"50\":1,\"60\":3,\"100\":2}}],[\"with\",{\"1\":{\"27\":1,\"102\":1,\"107\":2}}],[\"wake\",{\"1\":{\"79\":2}}],[\"wakeup\",{\"1\":{\"15\":5,\"47\":1}}],[\"wastecontaineralmostfull\",{\"1\":{\"50\":1}}],[\"wastebinalmostfull\",{\"1\":{\"50\":1}}],[\"waitforsingleobject\",{\"1\":{\"60\":1}}],[\"wait\",{\"1\":{\"47\":15,\"48\":2,\"49\":1,\"52\":5,\"55\":1,\"56\":4,\"57\":4,\"59\":5,\"60\":2,\"70\":6,\"71\":7,\"79\":3,\"107\":3,\"108\":18,\"109\":2,\"116\":3}}],[\"waiting\",{\"1\":{\"15\":2,\"47\":1}}],[\"中提到过一句话\",{\"1\":{\"107\":1}}],[\"中体现出来\",{\"1\":{\"100\":1}}],[\"中是可见的\",{\"1\":{\"82\":1}}],[\"中文语境一般说\",{\"1\":{\"70\":1}}],[\"中才得以引入\",{\"1\":{\"68\":1}}],[\"中获取线程\",{\"1\":{\"64\":1}}],[\"中用于表达当前时间\",{\"1\":{\"60\":1}}],[\"中运行\",{\"1\":{\"50\":1}}],[\"中增加打印语句\",{\"1\":{\"48\":1}}],[\"中无对应抽象实现\",{\"1\":{\"44\":1}}],[\"中添加元素时\",{\"1\":{\"25\":1}}],[\"中创建了一个局部的\",{\"1\":{\"16\":1}}],[\"中创建的线程正常执行完成\",{\"1\":{\"12\":1}}],[\"中的高级工具之后\",{\"1\":{\"72\":1}}],[\"中的意思就是先前说的\",{\"1\":{\"70\":1}}],[\"中的时间库\",{\"1\":{\"57\":1}}],[\"中的\",{\"1\":{\"12\":1,\"27\":2,\"32\":1}}],[\"中\",{\"1\":{\"8\":1,\"54\":1,\"62\":1,\"68\":1,\"75\":2,\"76\":1,\"79\":1,\"99\":1,\"107\":2}}],[\"它根据系统的硬件并发能力来决定使用的线程数\",{\"1\":{\"114\":1}}],[\"它必然指向\",{\"1\":{\"108\":1}}],[\"它实际会指向自己的子类对象\",{\"1\":{\"108\":1}}],[\"它选择到了\",{\"1\":{\"107\":1}}],[\"它从线程池中获取线程并执行任务返回包装对象\",{\"1\":{\"107\":1}}],[\"它用来存储需要执行的异步任务\",{\"1\":{\"107\":1}}],[\"它用于对时间段进行处理\",{\"1\":{\"59\":1}}],[\"它用于处理线程中需要等待某个事件的情况\",{\"1\":{\"51\":1}}],[\"它默认为\",{\"1\":{\"107\":1}}],[\"它默认的时钟节拍是\",{\"1\":{\"58\":1}}],[\"它自身不包含状态\",{\"1\":{\"106\":1}}],[\"它自身就是类类型\",{\"1\":{\"12\":1}}],[\"它包含了可调用对象和参数的类型\",{\"1\":{\"99\":1}}],[\"它保有两个数据成员\",{\"1\":{\"98\":1}}],[\"它目前在国内的应用也逐渐增多\",{\"1\":{\"85\":1}}],[\"它定义了在多线程或并发环境中\",{\"1\":{\"85\":1}}],[\"它描述了一个线程中的数据修改对其他线程的可见程度\",{\"1\":{\"82\":1}}],[\"它满足\",{\"1\":{\"79\":1}}],[\"它还提供了一种存储方式\",{\"1\":{\"77\":1}}],[\"它在后续\",{\"1\":{\"108\":1}}],[\"它在语义上强调了异步任务返回值的处理方式\",{\"1\":{\"107\":1}}],[\"它在内存模型方面也有自己独特的特性\",{\"1\":{\"85\":1}}],[\"它在不同的标准库实现中只是简单的初始化\",{\"1\":{\"76\":1}}],[\"它在标准\",{\"1\":{\"44\":1}}],[\"它很简单\",{\"1\":{\"76\":1}}],[\"它返回一个\",{\"1\":{\"72\":1}}],[\"它将所有后继阶段的初始期待计数减少一\",{\"1\":{\"71\":1}}],[\"它将我们传入的参数\",{\"1\":{\"14\":1}}],[\"它只能做三件事情\",{\"1\":{\"76\":1}}],[\"它只能处理有限数量的并发请求\",{\"1\":{\"68\":1}}],[\"它只是一个可变参数成员函数模板\",{\"1\":{\"99\":1}}],[\"它只是一个\",{\"1\":{\"76\":2}}],[\"它只保有一个私有数据成员\",{\"1\":{\"27\":1}}],[\"它维护一个计数\",{\"1\":{\"68\":1}}],[\"它通常用于测量时间间隔和性能计时等需要高精度和稳定性的场景\",{\"1\":{\"58\":1}}],[\"它通过创建新的类型提供了更多的功能\",{\"1\":{\"20\":1}}],[\"它较为麻烦\",{\"1\":{\"57\":1}}],[\"它并不具备设置任务优先级之类的调度功能\",{\"1\":{\"116\":1}}],[\"它并不是完全线程安全的\",{\"1\":{\"79\":1}}],[\"它并没有提供线程安全的方式\",{\"1\":{\"56\":1}}],[\"它并非具体类型\",{\"1\":{\"53\":1}}],[\"它\",{\"1\":{\"55\":1}}],[\"它就会失去共享状态\",{\"1\":{\"55\":1}}],[\"它就应该只是单纯的管理线程对象仅此而已\",{\"1\":{\"13\":1}}],[\"它接受一个\",{\"1\":{\"54\":1}}],[\"它本身并没什么特殊的\",{\"1\":{\"53\":1}}],[\"它有一个\",{\"1\":{\"107\":1}}],[\"它有两个特化\",{\"1\":{\"102\":1}}],[\"它有两个非类型模板参数\",{\"1\":{\"58\":1}}],[\"它有\",{\"1\":{\"53\":1}}],[\"它不仅适用于提示音的播放\",{\"1\":{\"49\":1}}],[\"它不管有没有发生数据竞争\",{\"1\":{\"34\":1}}],[\"它主要依赖于当前系统内核来进行使用\",{\"1\":{\"44\":1}}],[\"它支持任意可调用类型\",{\"1\":{\"116\":1}}],[\"它支持只移动类型\",{\"1\":{\"52\":1}}],[\"它支持所有可调用\",{\"1\":{\"52\":1}}],[\"它支持\",{\"1\":{\"37\":1}}],[\"它允许同一线程多次锁定同一个互斥量\",{\"1\":{\"35\":1}}],[\"它也是一个可变参数成员函数模板\",{\"1\":{\"99\":1}}],[\"它也能保持稳定\",{\"1\":{\"58\":1}}],[\"它也可以是类的成员\",{\"1\":{\"33\":1}}],[\"它也更加的复杂\",{\"1\":{\"31\":1}}],[\"它指定外部链接\",{\"1\":{\"32\":1}}],[\"它移动即标志其管理的互斥量的所有权转移了\",{\"1\":{\"32\":1}}],[\"它拥有自动存储期\",{\"1\":{\"41\":1}}],[\"它拥有\",{\"1\":{\"31\":1}}],[\"它相当于是对start\",{\"1\":{\"115\":1}}],[\"它相比于\",{\"1\":{\"31\":1}}],[\"它相较于\",{\"1\":{\"27\":1,\"77\":1}}],[\"它能一次性锁住多个互斥量\",{\"1\":{\"30\":1}}],[\"它才能往下执行\",{\"1\":{\"30\":1}}],[\"它和\",{\"1\":{\"27\":1}}],[\"它可以原子的使用新的值替换已经存储的值\",{\"1\":{\"77\":1}}],[\"它可以在编译阶段进行决策\",{\"1\":{\"75\":1}}],[\"它可以提供相对于起始时间的稳定的递增时间\",{\"1\":{\"58\":1}}],[\"它可以管理多个互斥量\",{\"1\":{\"27\":1}}],[\"它可以处于锁定\",{\"1\":{\"26\":1}}],[\"它会放弃\",{\"1\":{\"76\":1}}],[\"它会执行我们传递的可调用\",{\"1\":{\"53\":1}}],[\"它会阻塞\",{\"1\":{\"52\":1}}],[\"它会返回一个\",{\"1\":{\"52\":1}}],[\"它会设置内部的停止状态为\",{\"1\":{\"21\":1}}],[\"它会退化成指向它的const\",{\"1\":{\"14\":1}}],[\"它们定义在标头\",{\"1\":{\"69\":1}}],[\"它们位于仓库的\",{\"1\":{\"63\":1}}],[\"它们都是将当前对象\",{\"1\":{\"108\":1}}],[\"它们都是通过\",{\"1\":{\"59\":1}}],[\"它们都是模板\",{\"1\":{\"51\":1}}],[\"它们相比于\",{\"1\":{\"57\":1}}],[\"它们和我们先前讲的\",{\"1\":{\"57\":1}}],[\"它们的构造函数都接受一个函数对象\",{\"1\":{\"107\":1}}],[\"它们的实现彼此之间会共用不少设施\",{\"1\":{\"106\":1}}],[\"它们的主要区别在于前者依赖于\",{\"1\":{\"100\":1}}],[\"它们的返回类型都是\",{\"1\":{\"60\":1}}],[\"它们的模板类型参数\",{\"1\":{\"51\":1}}],[\"它们的区别与\",{\"1\":{\"51\":1}}],[\"它们的区别简单来说\",{\"1\":{\"34\":1}}],[\"它们的跨平台性和可移植性较差\",{\"1\":{\"37\":1}}],[\"它们不是同一个\",{\"1\":{\"37\":1}}],[\"它们就可能会彼此等待对方释放其所需的锁\",{\"1\":{\"30\":1}}],[\"它们之中最常用的是\",{\"1\":{\"15\":1}}],[\"它们构成了成员指针\",{\"1\":{\"14\":1}}],[\"它们返回一个包装类\",{\"1\":{\"14\":1}}],[\"它们没有什么区别\",{\"1\":{\"6\":1}}],[\"它现在根本没有关联任何线程\",{\"1\":{\"12\":1}}],[\"它被调整为了一个指向这个函数类型的指针类型\",{\"1\":{\"12\":1}}],[\"它的定义来自于父类\",{\"1\":{\"108\":1}}],[\"它的数据成员\",{\"1\":{\"107\":1}}],[\"它的形参类型我们不再过多介绍\",{\"1\":{\"99\":1}}],[\"它的形式表现为\",{\"1\":{\"77\":1}}],[\"它的实现完全基于\",{\"1\":{\"97\":1,\"106\":1}}],[\"它的所有操作都直接是原子的\",{\"1\":{\"74\":1}}],[\"它的使用同样可参见文档\",{\"1\":{\"72\":1}}],[\"它的使用通常非常简单\",{\"1\":{\"70\":1}}],[\"它的使用与概念也非常的简单\",{\"1\":{\"23\":1}}],[\"它的第二个模板参数是时间段\",{\"1\":{\"60\":1}}],[\"它的第一个参数是类型表示\",{\"1\":{\"59\":1}}],[\"它的特点是不受系统时间调整或变化的影响\",{\"1\":{\"58\":1}}],[\"它的\",{\"1\":{\"56\":1}}],[\"它的结果只能被一个线程获取\",{\"1\":{\"56\":1}}],[\"它的初始化需要考虑局部与非局部两种情况\",{\"1\":{\"43\":1}}],[\"它的存储在线程开始时分配\",{\"1\":{\"43\":1}}],[\"它的存储在程序开始时分配\",{\"1\":{\"42\":1}}],[\"它的返回类型是一个枚举类\",{\"1\":{\"59\":1}}],[\"它的返回类型是\",{\"1\":{\"28\":1}}],[\"它的效率接近我们实现的\",{\"1\":{\"10\":1}}],[\"它的用法也还远不止如此\",{\"1\":{\"9\":1}}],[\"它存储的就是余数\",{\"1\":{\"10\":1}}],[\"它与英特尔的技术实现有所不同\",{\"1\":{\"10\":1}}],[\"它是用来管理自家的\",{\"1\":{\"115\":1}}],[\"它是重要而直观的\",{\"1\":{\"107\":1}}],[\"它是实现\",{\"1\":{\"107\":1}}],[\"它是使用\",{\"1\":{\"107\":1}}],[\"它是线程实际执行的函数\",{\"1\":{\"99\":2}}],[\"它是原子的\",{\"1\":{\"76\":1}}],[\"它是有效的\",{\"1\":{\"76\":1}}],[\"它是怎么实现的呢\",{\"1\":{\"27\":1}}],[\"它是模板\",{\"1\":{\"15\":1}}],[\"它是\",{\"1\":{\"10\":2,\"71\":1}}],[\"它要想并发\",{\"1\":{\"5\":1}}],[\"对这些概念的理解也会逐渐提升\",{\"1\":{\"112\":1}}],[\"对这个临时对象调用\",{\"1\":{\"79\":1}}],[\"对类型形参包为空的情况的全特化\",{\"1\":{\"102\":1}}],[\"对模板类型形参包只有一个类型情况的偏特化\",{\"1\":{\"102\":1}}],[\"对它们的兼容\",{\"1\":{\"94\":1}}],[\"对标准库的实现\",{\"1\":{\"94\":1}}],[\"对共享数据的修改会对之后调用\",{\"1\":{\"82\":1}}],[\"对变量\",{\"1\":{\"82\":2}}],[\"对此类有兴趣或任何疑问\",{\"1\":{\"30\":1}}],[\"对数据做了保护\",{\"1\":{\"29\":1}}],[\"对每个线程对象调用\",{\"1\":{\"18\":1}}],[\"对移动语义不了解\",{\"1\":{\"16\":1}}],[\"对线程资源是独占所有权\",{\"1\":{\"16\":1,\"99\":1}}],[\"对\",{\"1\":{\"13\":1,\"74\":1,\"82\":3}}],[\"对象池\",{\"1\":{\"112\":1}}],[\"对象并将它与执行线程关联\",{\"1\":{\"99\":1}}],[\"对象赋值给\",{\"1\":{\"77\":1}}],[\"对象不可进行复制\",{\"1\":{\"75\":1}}],[\"对象不可表示一个线程\",{\"1\":{\"16\":1}}],[\"对象而不同步\",{\"1\":{\"72\":1,\"79\":1}}],[\"对象上调用所有成员函数\",{\"1\":{\"72\":1,\"79\":1}}],[\"对象在默认构造时是清除\",{\"1\":{\"76\":1}}],[\"对象在\",{\"1\":{\"59\":1}}],[\"对象必须拥有共享状态\",{\"1\":{\"55\":1}}],[\"对象拥有共享状态\",{\"1\":{\"55\":1}}],[\"对象也会失去共享状态\",{\"1\":{\"55\":1}}],[\"对象只能是存储值或者异常其中一种\",{\"1\":{\"54\":1}}],[\"对象会重新抛出这个异常\",{\"1\":{\"54\":1}}],[\"对象通过\",{\"1\":{\"54\":1}}],[\"对象进行操作时\",{\"1\":{\"56\":2}}],[\"对象进行关联\",{\"1\":{\"54\":1}}],[\"对象进行复制或赋值等操作会引发一个编译错误\",{\"1\":{\"13\":1}}],[\"对象异步获得\",{\"1\":{\"54\":1}}],[\"对象所创建的\",{\"1\":{\"54\":1}}],[\"对象所持有的线程资源转移给\",{\"1\":{\"16\":1}}],[\"对象访问的共享状态中\",{\"1\":{\"53\":1}}],[\"对象调用\",{\"1\":{\"52\":2}}],[\"对象副本进行访问\",{\"1\":{\"51\":1,\"56\":1}}],[\"对象时传入的\",{\"1\":{\"71\":1}}],[\"对象时\",{\"1\":{\"51\":1}}],[\"对象实例并调用非\",{\"1\":{\"79\":1}}],[\"对象实例包含一个指向控制块的指针和一个指向底层元素的指针\",{\"1\":{\"79\":1}}],[\"对象实例本身并不是线程安全的\",{\"1\":{\"79\":1}}],[\"对象实例\",{\"1\":{\"36\":1}}],[\"对象是全局命名空间作用域声明\",{\"1\":{\"33\":1}}],[\"对象都具有静态或线程存储期\",{\"1\":{\"32\":1}}],[\"对象都能检查到这个停止请求\",{\"1\":{\"21\":1}}],[\"对象表示拥有互斥量的所有权\",{\"1\":{\"31\":1}}],[\"对象停止状态\",{\"1\":{\"21\":1}}],[\"对象关联的\",{\"1\":{\"21\":1}}],[\"对象管理\",{\"1\":{\"18\":1}}],[\"对象中的\",{\"1\":{\"107\":1}}],[\"对象中存储的\",{\"1\":{\"76\":1}}],[\"对象中\",{\"1\":{\"16\":1,\"107\":1,\"110\":1}}],[\"对象最后调用\",{\"1\":{\"16\":1}}],[\"对象的状态原子地更改为清除\",{\"1\":{\"76\":1}}],[\"对象的状态为设置\",{\"1\":{\"76\":1}}],[\"对象的生命周期结束时\",{\"1\":{\"76\":1}}],[\"对象的计数减少到零\",{\"1\":{\"70\":1}}],[\"对象的引入传给线程对象\",{\"1\":{\"56\":1}}],[\"对象的引入传入\",{\"1\":{\"56\":1}}],[\"对象的\",{\"1\":{\"54\":1}}],[\"对象的线程资源所有权转移给另一个\",{\"1\":{\"16\":1}}],[\"对象的指针\",{\"1\":{\"14\":1}}],[\"对象失去了线程资源的所有权\",{\"1\":{\"13\":1}}],[\"对象销毁之后再去访问\",{\"1\":{\"12\":1}}],[\"对象即可\",{\"1\":{\"12\":1,\"33\":1}}],[\"对象\",{\"1\":{\"9\":1,\"11\":1,\"12\":5,\"13\":1,\"14\":1,\"16\":5,\"32\":2,\"33\":1,\"37\":1,\"52\":3,\"53\":1,\"54\":1,\"56\":1,\"75\":1,\"79\":5,\"99\":2,\"103\":1,\"106\":1,\"107\":3}}],[\"对于\",{\"1\":{\"106\":1,\"108\":1}}],[\"对于多线程程序\",{\"1\":{\"81\":1}}],[\"对于单线程程序\",{\"1\":{\"81\":1}}],[\"对于普通开发者来说\",{\"1\":{\"81\":1}}],[\"对于两个独立的对象\",{\"1\":{\"76\":1}}],[\"对于标准内建类型的别名\",{\"1\":{\"75\":1}}],[\"对于有时无锁的内建原子类型是\",{\"1\":{\"75\":1}}],[\"对于一定无锁的内建原子类型是\",{\"1\":{\"75\":1}}],[\"对于一定有锁的内建原子类型是\",{\"1\":{\"75\":1}}],[\"对于一些特殊的场景\",{\"1\":{\"33\":1}}],[\"对于那些熟悉操作系统或其它并发支持库的开发者来说\",{\"1\":{\"68\":1}}],[\"对于每个线程来说是独立的\",{\"1\":{\"36\":1}}],[\"对于相同类型的两个不同对象进行数据的交换操作\",{\"1\":{\"30\":1}}],[\"对于很多人来说\",{\"1\":{\"6\":1}}],[\"对于这两个术语\",{\"1\":{\"6\":1}}],[\"对多线程来说\",{\"1\":{\"6\":1}}],[\"只会让各位开发者感觉复杂难\",{\"1\":{\"108\":1}}],[\"只管理一个互斥量的\",{\"1\":{\"103\":1}}],[\"只不过一直没详细展开讲解\",{\"1\":{\"81\":1}}],[\"只不过实践中通常不会那样做\",{\"1\":{\"45\":1}}],[\"只需关注\",{\"1\":{\"63\":1}}],[\"只需要不到一百行代码\",{\"1\":{\"116\":1}}],[\"只需要调用\",{\"1\":{\"52\":1}}],[\"只需要接受可调用\",{\"1\":{\"33\":1}}],[\"只需要将这些参数作为\",{\"1\":{\"14\":1}}],[\"只在只在有音频任务需要播放时工作\",{\"1\":{\"49\":1}}],[\"只保有一个私有数据成员\",{\"1\":{\"98\":1}}],[\"只保有一个引用\",{\"1\":{\"13\":1}}],[\"只保证了\",{\"1\":{\"36\":1}}],[\"只要不是\",{\"1\":{\"52\":1}}],[\"只要不影响自己即可\",{\"1\":{\"33\":1}}],[\"只要可被多个线程读写\",{\"1\":{\"36\":1}}],[\"只要是可调用\",{\"1\":{\"12\":1}}],[\"只能被调用一次\",{\"1\":{\"56\":1}}],[\"只能包一层了\",{\"1\":{\"53\":1}}],[\"只能移动\",{\"1\":{\"53\":1}}],[\"只能与单个指定事件关联\",{\"1\":{\"51\":1}}],[\"只能寄希望于调用方传递的代码是能正常执行的\",{\"1\":{\"30\":1}}],[\"只能通过对象关联线程后\",{\"1\":{\"11\":1}}],[\"只用来确保必须的共享资源的线程安全\",{\"1\":{\"27\":1}}],[\"只有当任务完成并设置\",{\"1\":{\"108\":1}}],[\"只有两个版本需要介绍\",{\"1\":{\"103\":1}}],[\"只有第四个构造函数较为复杂\",{\"1\":{\"99\":1}}],[\"只有声明为\",{\"1\":{\"43\":1}}],[\"只有在解锁与锁定次数相匹配时\",{\"1\":{\"35\":1}}],[\"只有在涉及多线程读写相同共享数据的时候\",{\"1\":{\"25\":1}}],[\"只有一个线程可以运行\",{\"1\":{\"34\":1}}],[\"只有一个线程能在\",{\"1\":{\"27\":1}}],[\"只有一个线程能成功调用并将\",{\"1\":{\"76\":1}}],[\"只有一个线程能成功调用\",{\"1\":{\"26\":1}}],[\"只有\",{\"1\":{\"27\":1}}],[\"只有硬件上是多核的\",{\"1\":{\"5\":1}}],[\"只是初始化数据成员\",{\"1\":{\"103\":1}}],[\"只是初始化了数据成员而已\",{\"1\":{\"31\":1}}],[\"只是为了不重复多次创建线程罢了\",{\"1\":{\"116\":1}}],[\"只是为了区分重载\",{\"1\":{\"107\":1}}],[\"只是为了处理引用类型以及\",{\"1\":{\"107\":1}}],[\"只是为了表示\",{\"1\":{\"79\":1}}],[\"只是为了让线程对象关联的线程得以正确执行完毕\",{\"1\":{\"12\":1}}],[\"只是确保了操作的线程安全\",{\"1\":{\"79\":1}}],[\"只是个读取操作\",{\"1\":{\"79\":1}}],[\"只是其中之一\",{\"1\":{\"77\":1}}],[\"只是\",{\"1\":{\"68\":1}}],[\"只是不上锁\",{\"1\":{\"31\":1}}],[\"只是多了两个功能\",{\"1\":{\"19\":1}}],[\"只是保有了线程对象的引用\",{\"1\":{\"13\":1}}],[\"只是用于描述一些东西的时候关注点不同\",{\"1\":{\"6\":1}}],[\"指示线程池是否停止\",{\"1\":{\"116\":1}}],[\"指定线程数量\",{\"1\":{\"114\":1}}],[\"指定或让\",{\"1\":{\"114\":1}}],[\"指定时间的方式\",{\"1\":{\"57\":1}}],[\"指令集架构就是\",{\"1\":{\"85\":1}}],[\"指令重排了\",{\"1\":{\"81\":1}}],[\"指明\",{\"1\":{\"76\":1}}],[\"指的是系统中的每个物理处理器或每个逻辑处理器\",{\"1\":{\"45\":1}}],[\"指的是一个访问共享资源的程序片段\",{\"1\":{\"45\":1}}],[\"指的是由\",{\"1\":{\"23\":1}}],[\"指针转换到原类型\",{\"1\":{\"100\":1}}],[\"指针为空\",{\"1\":{\"33\":1}}],[\"指针就悬空了\",{\"1\":{\"14\":1}}],[\"指针\",{\"1\":{\"14\":1,\"98\":1,\"107\":2}}],[\"指向了一个静态成员函数\",{\"1\":{\"99\":1}}],[\"指向的是\",{\"1\":{\"99\":1}}],[\"指向被管理对象的指针或被管理对象本身\",{\"1\":{\"79\":1}}],[\"指向控制块\",{\"1\":{\"79\":1}}],[\"指向底层元素的指针\",{\"1\":{\"79\":1}}],[\"指向它的指针这当然没问题了\",{\"1\":{\"14\":1}}],[\"指向\",{\"1\":{\"12\":1}}],[\"指代的东西完全不同\",{\"1\":{\"6\":1}}],[\"指两个或两个以上的独立活动同时发生\",{\"1\":{\"4\":1}}],[\"并分配新的任务给它们执行\",{\"1\":{\"112\":1}}],[\"并重新抛出它\",{\"1\":{\"109\":1}}],[\"并接收到任务完成的信号\",{\"1\":{\"108\":1}}],[\"并等待任务的完成\",{\"1\":{\"107\":1}}],[\"并增加了一个表示状态的成员\",{\"1\":{\"107\":1}}],[\"并进一步解释\",{\"1\":{\"107\":1}}],[\"并将其转发给基类\",{\"1\":{\"107\":1}}],[\"并将线程句柄存储到\",{\"1\":{\"99\":1}}],[\"并将互斥量的所有权转移到调用者上\",{\"1\":{\"32\":1}}],[\"并返回一个std\",{\"1\":{\"116\":1}}],[\"并返回一个指向弹出元素的\",{\"1\":{\"48\":1}}],[\"并返回原始值\",{\"1\":{\"78\":2}}],[\"并返回操作前的指针值\",{\"1\":{\"78\":1}}],[\"并返回\",{\"1\":{\"77\":1}}],[\"并返回旧值\",{\"1\":{\"77\":1}}],[\"并返回它先前的值\",{\"1\":{\"76\":1}}],[\"并返回它先前保有的值给\",{\"1\":{\"76\":1}}],[\"并返回它先前保有的值\",{\"1\":{\"76\":1}}],[\"并介绍其成员函数和使用方法\",{\"1\":{\"75\":1}}],[\"并减少重置计数\",{\"1\":{\"71\":1}}],[\"并解除所有在阶段同步点上阻塞的线程\",{\"1\":{\"71\":1}}],[\"并指明了执行策略\",{\"1\":{\"62\":1}}],[\"并指明执行策略\",{\"1\":{\"10\":1}}],[\"并更新进度条\",{\"1\":{\"61\":1}}],[\"并退出循环\",{\"1\":{\"60\":1}}],[\"并执行后续的操作\",{\"1\":{\"47\":1}}],[\"并说明了可以使用互斥量\",{\"1\":{\"45\":1}}],[\"并按顺序早于线程函数的执行开始\",{\"1\":{\"43\":1}}],[\"并在条件满足时唤醒线程\",{\"1\":{\"116\":1}}],[\"并在主线程中通过与其关联的\",{\"1\":{\"54\":1}}],[\"并在成功添加任务后唤醒条件变量\",{\"1\":{\"49\":1}}],[\"并在线程结束时解分配\",{\"1\":{\"43\":1}}],[\"并在线程结束时释放\",{\"1\":{\"37\":1}}],[\"并在程序结束时解分配\",{\"1\":{\"42\":1}}],[\"并在以后反复查看和实践\",{\"1\":{\"23\":1}}],[\"并非是不可打断不可交换的固定指令\",{\"1\":{\"33\":1}}],[\"并非引用了局部对象\",{\"1\":{\"14\":1}}],[\"并造成死锁\",{\"1\":{\"30\":1}}],[\"并对它进行修改\",{\"1\":{\"25\":1}}],[\"并且有线程处于休眠状态时\",{\"1\":{\"112\":1}}],[\"并且能从非原子的\",{\"1\":{\"77\":1}}],[\"并且这种形式的转换是可以直接隐式的\",{\"1\":{\"59\":1}}],[\"并且为了方便使用\",{\"1\":{\"59\":1}}],[\"并且状态被完全销毁\",{\"1\":{\"55\":1,\"108\":1}}],[\"并且异步任务的执行不会导致性能问题\",{\"1\":{\"52\":1}}],[\"并且它们都不可移动不可复制\",{\"1\":{\"102\":1}}],[\"并且它和\",{\"1\":{\"52\":1}}],[\"并且它有自己的问题\",{\"1\":{\"45\":1}}],[\"并且也是默认按值复制\",{\"1\":{\"52\":1}}],[\"并且整体仅需\",{\"1\":{\"50\":1}}],[\"并且确保这些提示音的播放不会影响其他功能的正常运行\",{\"1\":{\"49\":1}}],[\"并且通过\",{\"1\":{\"47\":1}}],[\"并且条件变量\",{\"1\":{\"47\":1}}],[\"并且要注意互斥量上锁的\",{\"1\":{\"45\":1}}],[\"并且额外支持超时功能\",{\"1\":{\"34\":1}}],[\"并且让当前线程获取锁\",{\"1\":{\"33\":1}}],[\"并且把\",{\"1\":{\"31\":1}}],[\"并且死锁经常是不可预见\",{\"1\":{\"30\":1}}],[\"并且没有死锁风险\",{\"1\":{\"30\":1}}],[\"并且一个拿到了遥控器\",{\"1\":{\"30\":1}}],[\"并且两个小孩都想要玩\",{\"1\":{\"30\":1}}],[\"并且\",{\"1\":{\"27\":1,\"31\":1,\"55\":1}}],[\"并且如果是第一次学习本章的内容\",{\"1\":{\"23\":1}}],[\"并且余数是\",{\"1\":{\"10\":1}}],[\"并不会在线程中执行任务\",{\"1\":{\"107\":1}}],[\"并不会完全一样\",{\"1\":{\"85\":1}}],[\"并不会改变\",{\"1\":{\"79\":1}}],[\"并不会和前面\",{\"1\":{\"14\":1}}],[\"并不总是无锁\",{\"1\":{\"75\":1}}],[\"并不阻塞\",{\"1\":{\"53\":1}}],[\"并不是说要在\",{\"1\":{\"14\":1}}],[\"并没有什么特殊作用\",{\"1\":{\"107\":1}}],[\"并没有太多区别\",{\"1\":{\"101\":1}}],[\"并没有处理什么其他的东西\",{\"1\":{\"12\":1}}],[\"并没有非常公认的说法\",{\"1\":{\"6\":1}}],[\"并行模式库\",{\"1\":{\"107\":1}}],[\"并行求和\",{\"1\":{\"10\":1}}],[\"并行\",{\"1\":{\"6\":1}}],[\"并发调用barrier\",{\"1\":{\"71\":1}}],[\"并发支持库进行多线程编程\",{\"1\":{\"93\":1}}],[\"并发支持库的重中之重\",{\"1\":{\"23\":1}}],[\"并发支持库也不涉及多进程\",{\"1\":{\"3\":1}}],[\"并发库的历史发展\",{\"1\":{\"7\":1}}],[\"并发与并行\",{\"0\":{\"6\":1}}],[\"并发在生活中随处可见\",{\"1\":{\"4\":1}}],[\"并发\",{\"0\":{\"4\":1},\"1\":{\"4\":1}}],[\"并发编程\",{\"1\":{\"3\":1}}],[\"并发编程的教程并不稀少\",{\"1\":{\"0\":1}}],[\"并发编程教程\",{\"1\":{\"0\":1,\"92\":1,\"94\":1}}],[\"事实上只需要一句话就可以表达了\",{\"1\":{\"93\":1}}],[\"事实上我们在前面就用到了不少的内存次序\",{\"1\":{\"81\":1}}],[\"事实上最简单的方式是\",{\"1\":{\"47\":1}}],[\"事实上完全等价\",{\"1\":{\"12\":1}}],[\"事实上\",{\"1\":{\"6\":1}}],[\"浏览器\",{\"1\":{\"5\":1}}],[\"编程\",{\"1\":{\"114\":1}}],[\"编译此代码\",{\"1\":{\"38\":1}}],[\"编译选项\",{\"1\":{\"21\":1,\"37\":1}}],[\"编译器优化或缓存问题\",{\"1\":{\"82\":1}}],[\"编译器优化\",{\"1\":{\"82\":1}}],[\"编译器优化需要遵守一个\",{\"1\":{\"81\":1}}],[\"编译器在编译代码时\",{\"1\":{\"81\":1}}],[\"编译器重排\",{\"1\":{\"81\":1}}],[\"编译器可以\",{\"1\":{\"37\":1}}],[\"编译器\",{\"1\":{\"5\":1}}],[\"编辑器和\",{\"1\":{\"5\":1}}],[\"这可能导致一些任务无法执行\",{\"1\":{\"116\":1}}],[\"这可以避免\",{\"1\":{\"47\":1}}],[\"这点也和\",{\"1\":{\"115\":1}}],[\"这其实是个多态调用\",{\"1\":{\"108\":1}}],[\"这其中的\",{\"1\":{\"108\":1}}],[\"这防止了由于虚假唤醒导致的错误行为\",{\"1\":{\"108\":1}}],[\"这非常重要\",{\"1\":{\"107\":1}}],[\"这类似于\",{\"1\":{\"107\":1}}],[\"这很重要\",{\"1\":{\"107\":1}}],[\"这很明显\",{\"1\":{\"103\":1}}],[\"这很正常\",{\"1\":{\"48\":1}}],[\"这三个版本中\",{\"1\":{\"103\":1}}],[\"这三个文件\",{\"1\":{\"63\":1}}],[\"这没办法\",{\"1\":{\"101\":1}}],[\"这没有可见性的问题吗\",{\"1\":{\"82\":1}}],[\"这在线程实际执行的函数\",{\"1\":{\"100\":1}}],[\"这带来了许多的热度\",{\"1\":{\"92\":1}}],[\"这与\",{\"1\":{\"85\":1}}],[\"这两种架构在设计理念和应用领域上存在显著差异\",{\"1\":{\"85\":1}}],[\"这两个类分别对应于异步任务的两种不同执行策略\",{\"1\":{\"107\":1}}],[\"这两个函数都非常的简单\",{\"1\":{\"99\":1}}],[\"这两个指针的操作在多个线程中并没有同步机制\",{\"1\":{\"79\":1}}],[\"这两个库\",{\"1\":{\"50\":1}}],[\"这两个实现都包含在\",{\"1\":{\"47\":1}}],[\"这两个方面的线程安全\",{\"1\":{\"36\":1}}],[\"这两个数据成员\",{\"1\":{\"20\":1}}],[\"这两个问题其实也算一个问题\",{\"1\":{\"12\":1}}],[\"这两个术语存在的目的\",{\"1\":{\"6\":1}}],[\"这两个词是用来描述硬件同时执行多个任务的方式\",{\"1\":{\"6\":1}}],[\"这两个概念大部分是重叠的\",{\"1\":{\"6\":1}}],[\"这\",{\"1\":{\"83\":1}}],[\"这显然不现实\",{\"1\":{\"81\":1}}],[\"这将使学习过程具有一定挑战性\",{\"1\":{\"81\":1}}],[\"这并非当前描述不足或者不够严谨\",{\"1\":{\"94\":1}}],[\"这并非是\",{\"1\":{\"79\":1}}],[\"这并不能创建异步任务\",{\"1\":{\"52\":1}}],[\"这导致了数据竞争\",{\"1\":{\"79\":1}}],[\"这不是\",{\"1\":{\"76\":1}}],[\"这不是接口设计者可以处理的\",{\"1\":{\"30\":1}}],[\"这也是它们在不同应用场景中表现出色的原因\",{\"1\":{\"85\":1}}],[\"这也是很正常的需求\",{\"1\":{\"75\":1}}],[\"这也就是源码中添加约束的目的\",{\"1\":{\"99\":1}}],[\"这也就是前面说的\",{\"1\":{\"81\":1}}],[\"这也就是下一章节的内容了\",{\"1\":{\"18\":1}}],[\"这构成了数据竞争\",{\"1\":{\"74\":1}}],[\"这行代码会产生一个编译错误\",{\"1\":{\"71\":1}}],[\"这行代码是获取当前线程的执行范围\",{\"1\":{\"10\":1}}],[\"这使得\",{\"1\":{\"70\":1,\"107\":1}}],[\"这对于代码块的计时是很有用的\",{\"1\":{\"60\":1}}],[\"这只是一个简单的示例\",{\"1\":{\"53\":1}}],[\"这一点和大部分库的设计一致\",{\"1\":{\"116\":1}}],[\"这一点和\",{\"1\":{\"56\":1}}],[\"这一点很好理解并且常见\",{\"1\":{\"55\":1}}],[\"这一点中在源码中很明显\",{\"1\":{\"52\":1}}],[\"这一切的问题都会在后面的\",{\"1\":{\"14\":1}}],[\"这会涉及不少模板技术\",{\"1\":{\"104\":1}}],[\"这会涉及到不少的模板技术\",{\"1\":{\"101\":1}}],[\"这会影响到程序的行为\",{\"1\":{\"47\":1}}],[\"这会造成很多的额外开销\",{\"1\":{\"33\":1}}],[\"这会造成资源浪费\",{\"1\":{\"15\":1}}],[\"这和线程有什么关系呢\",{\"1\":{\"47\":1}}],[\"这意味着当前对象\",{\"1\":{\"108\":1}}],[\"这意味着当前对象失去共享状态\",{\"1\":{\"55\":1}}],[\"这意味着多个线程可以安全地操作引用计数和访问管理对象\",{\"1\":{\"79\":1}}],[\"这意味着它的所有操作都是原子操作\",{\"1\":{\"79\":1}}],[\"这意味着它无法接受浮点数\",{\"1\":{\"59\":1}}],[\"这意味着你可以根据成功或失败的情况\",{\"1\":{\"77\":1}}],[\"这意味着\",{\"1\":{\"70\":1,\"82\":1}}],[\"这意味着无法保证线程局部变量在任务完成时会被销毁\",{\"1\":{\"38\":1}}],[\"这意味着通过调用\",{\"1\":{\"12\":1}}],[\"这都不是最重要的\",{\"1\":{\"31\":1}}],[\"这都很正常\",{\"1\":{\"27\":1}}],[\"这种方法过于原始\",{\"1\":{\"115\":1}}],[\"这种方法在多线程编程中很有用\",{\"1\":{\"28\":1}}],[\"这种遍历元组的方式在之前讲\",{\"1\":{\"103\":1}}],[\"这种代码自然不应该让它通过编译\",{\"1\":{\"99\":1}}],[\"这种强弱其实也只是一种分类而已\",{\"1\":{\"85\":1}}],[\"这种描述方式可以帮助更清楚地理解和描述多线程并发编程中如何通过\",{\"1\":{\"82\":1}}],[\"这种重排通常遵循一些硬件层面的优化规则\",{\"1\":{\"81\":1}}],[\"这种做法非常的愚蠢\",{\"1\":{\"79\":1}}],[\"这种操作叫做\",{\"1\":{\"77\":1}}],[\"这种设计思路非常常见\",{\"1\":{\"50\":1}}],[\"这种设计通过合理利用条件变量和互斥量\",{\"1\":{\"49\":1}}],[\"这种区分必然是\",{\"1\":{\"47\":1}}],[\"这种机制就称为\",{\"1\":{\"47\":1}}],[\"这种机制不是强制性的终止线程\",{\"1\":{\"23\":1}}],[\"这种实现进步了很多\",{\"1\":{\"47\":1}}],[\"这种实现方式是线程安全的\",{\"1\":{\"33\":1}}],[\"这种行为很合理\",{\"1\":{\"33\":1}}],[\"这种错误写法在一些单例中也非常的常见\",{\"1\":{\"33\":1}}],[\"这种转移\",{\"1\":{\"32\":1}}],[\"这种情况就是死锁\",{\"1\":{\"30\":1}}],[\"这些功能超出了本次讲解的范围\",{\"1\":{\"116\":1}}],[\"这些线程由线程池管理\",{\"1\":{\"112\":1}}],[\"这些类型先经过\",{\"1\":{\"100\":1}}],[\"这些类型的操作都是原子的\",{\"1\":{\"75\":1}}],[\"这些设施自动确保数据的可见性\",{\"1\":{\"82\":1}}],[\"这些还是简单直接且符合直觉的\",{\"1\":{\"81\":1}}],[\"这些东西用来创建一个线程\",{\"1\":{\"99\":1}}],[\"这些东西\",{\"1\":{\"81\":1,\"116\":1}}],[\"这些函数接受并返回的类型都是\",{\"1\":{\"78\":1}}],[\"这些操作会导致对这些指针的并发修改\",{\"1\":{\"79\":1}}],[\"这些操作确保在多线程环境下进行安全的指针操作\",{\"1\":{\"78\":1}}],[\"这些操作是不被允许的\",{\"1\":{\"76\":1}}],[\"这些操作对应的函数分别是\",{\"1\":{\"76\":1}}],[\"这些概念在面试和技术讨论中常常出现\",{\"1\":{\"39\":1}}],[\"这些扩展并不是标准的\",{\"1\":{\"37\":1}}],[\"这些已经足够了\",{\"1\":{\"33\":1}}],[\"这些都由操作系统调度决定\",{\"1\":{\"27\":1}}],[\"这些参数会复制到新线程的内存空间中\",{\"1\":{\"14\":1}}],[\"这所谓的线程停止\",{\"1\":{\"21\":1}}],[\"这就是第三个问题\",{\"1\":{\"100\":1}}],[\"这就是这个类型名字的由来\",{\"1\":{\"72\":1}}],[\"这就是双重检查\",{\"1\":{\"33\":1}}],[\"这就是所谓的\",{\"1\":{\"32\":1}}],[\"这就是\",{\"1\":{\"20\":1}}],[\"这段代码确保当前线程会等待任务在另一个线程中执行完毕\",{\"1\":{\"108\":1}}],[\"这段代码使用了条件变量\",{\"1\":{\"108\":1}}],[\"这段代码也很好的说明在\",{\"1\":{\"107\":1}}],[\"这段代码最直观的信息是\",{\"1\":{\"107\":1}}],[\"这段代码为你展示了\",{\"1\":{\"103\":1}}],[\"这段代码就会正常的出现编译错误\",{\"1\":{\"99\":1}}],[\"这段代码很简单\",{\"1\":{\"68\":1}}],[\"这段代码很好的展示了\",{\"1\":{\"37\":1}}],[\"这段代码存在数据竞争\",{\"1\":{\"56\":1}}],[\"这段代码运行会抛出异常\",{\"1\":{\"31\":1}}],[\"这段代码极其简单\",{\"1\":{\"27\":1}}],[\"这段代码你多次运行它会得到毫无规律和格式的结果\",{\"1\":{\"26\":1}}],[\"这段代码可以通过编译\",{\"1\":{\"16\":1}}],[\"这段代码通过移动构造转移了线程对象\",{\"1\":{\"16\":1}}],[\"这段代码将\",{\"1\":{\"9\":1}}],[\"这确保了线程对象\",{\"1\":{\"13\":1}}],[\"这确保了剩余的\",{\"1\":{\"10\":1}}],[\"这个词感到陌生\",{\"1\":{\"112\":1}}],[\"这个非常重要\",{\"1\":{\"103\":1}}],[\"这个东西可以用来接收一个由\",{\"1\":{\"99\":1}}],[\"这个函数很简单\",{\"1\":{\"109\":1}}],[\"这个函数模板接受两个参数\",{\"1\":{\"103\":1}}],[\"这个函数用于获取一个函数指针\",{\"1\":{\"99\":1}}],[\"这个函数才是我们的重点\",{\"1\":{\"99\":1}}],[\"这个函数调用是阻塞的\",{\"1\":{\"57\":1}}],[\"这个构造函数不上锁\",{\"1\":{\"103\":1}}],[\"这个构造函数做了两件事情\",{\"1\":{\"103\":1}}],[\"这个构造函数本身并没有做什么\",{\"1\":{\"99\":1}}],[\"这个构造函数没有给互斥量上锁\",{\"1\":{\"31\":1}}],[\"这个结构体\",{\"1\":{\"98\":1}}],[\"这个结构体的\",{\"1\":{\"98\":1}}],[\"这个行为不仅仅适用于std\",{\"1\":{\"77\":1}}],[\"这个参数可以用来指定执行顺序\",{\"1\":{\"75\":1}}],[\"这个参数通常通过\",{\"1\":{\"54\":1}}],[\"这个数量非常之多\",{\"1\":{\"75\":1}}],[\"这个数据结构很少进行改变\",{\"1\":{\"34\":1}}],[\"这个示例非常直观地展示了如何使用\",{\"1\":{\"70\":1}}],[\"这个例子清楚地展示了\",{\"1\":{\"70\":1}}],[\"这个例子其实很好的展示了多线程异步的作用\",{\"1\":{\"67\":1}}],[\"这个计数不能小于\",{\"1\":{\"68\":1}}],[\"这个同步设施的概念应该不会感到陌生\",{\"1\":{\"68\":1}}],[\"这个特化十分简单\",{\"1\":{\"78\":1}}],[\"这个特化\",{\"1\":{\"55\":1}}],[\"这个问题在许多文档中没有明确说明\",{\"1\":{\"55\":1}}],[\"这个问题就能使用\",{\"1\":{\"51\":1}}],[\"这个对象和任务关联\",{\"1\":{\"52\":1}}],[\"这个方法听起来还行\",{\"1\":{\"47\":1}}],[\"这个所有权语义\",{\"1\":{\"31\":1}}],[\"这个建议是很简单的\",{\"1\":{\"30\":1}}],[\"这个玩具有两个部分\",{\"1\":{\"30\":1}}],[\"这个是由操作系统调度决定的\",{\"1\":{\"26\":1}}],[\"这个类型的对象可以在两个状态间切换\",{\"1\":{\"76\":1}}],[\"这个类和\",{\"1\":{\"18\":1}}],[\"这个类就是包装引用对象类模板\",{\"1\":{\"14\":1}}],[\"这个传入了一个临时对象\",{\"1\":{\"15\":1}}],[\"这个命名空间包含了管理当前线程的函数\",{\"1\":{\"15\":1}}],[\"这个指针可以通过\",{\"1\":{\"14\":1}}],[\"这个\",{\"1\":{\"14\":1,\"18\":1,\"99\":1,\"107\":1}}],[\"这个销毁依然会发生\",{\"1\":{\"13\":1}}],[\"这个线程也会多分配一个元素\",{\"1\":{\"10\":1}}],[\"这被编译器解析为函数声明\",{\"1\":{\"12\":1}}],[\"这样简单直观\",{\"1\":{\"95\":1}}],[\"这样写很冗余\",{\"1\":{\"59\":1}}],[\"这样的系统时钟可能会受到系统时间调整或变化的影响\",{\"1\":{\"58\":1}}],[\"这样的方式很好\",{\"1\":{\"57\":1}}],[\"这样的话\",{\"1\":{\"13\":1}}],[\"这样不会有任何问题\",{\"1\":{\"56\":1}}],[\"这样访问的就都是\",{\"1\":{\"56\":1}}],[\"这样就不会错过你要下车的站点\",{\"1\":{\"47\":1}}],[\"这样就确保了所有的元素都被正确地分配给了各个线程进行处理\",{\"1\":{\"10\":1}}],[\"这样一个恶意的函数\",{\"1\":{\"29\":1}}],[\"这样确保了当执行函数\",{\"1\":{\"27\":1}}],[\"这样这个线程占用\",{\"1\":{\"15\":1}}],[\"这样如果前面的代码没有抛出异常\",{\"1\":{\"12\":1}}],[\"这样\",{\"1\":{\"12\":1,\"21\":1,\"47\":1,\"71\":1,\"99\":1,\"108\":2}}],[\"这样系统使用者就可以同时运行文字处理器\",{\"1\":{\"5\":1}}],[\"这里和\",{\"1\":{\"109\":1}}],[\"这里就用到了\",{\"1\":{\"99\":1}}],[\"这里有一个形参包展开\",{\"1\":{\"99\":1}}],[\"这里使用了\",{\"1\":{\"99\":1}}],[\"这里推荐一下\",{\"1\":{\"93\":1,\"100\":1}}],[\"这里实际上有两个独立的操作\",{\"1\":{\"76\":1}}],[\"这里还不是详细展开聊内存序的时候\",{\"1\":{\"76\":1}}],[\"这里还需要提一下\",{\"1\":{\"31\":1}}],[\"这里不再过多赘述\",{\"1\":{\"73\":1}}],[\"这里显示的是子线程的id\",{\"1\":{\"64\":1}}],[\"这里显示的线程\",{\"1\":{\"64\":1}}],[\"这里\",{\"1\":{\"52\":1}}],[\"这里会调用移动构造\",{\"1\":{\"32\":1}}],[\"这里一样选择到移动构造\",{\"1\":{\"16\":1}}],[\"这里相当于是将临时的\",{\"1\":{\"16\":1}}],[\"这里虽然有两个\",{\"1\":{\"16\":1}}],[\"这里调用\",{\"1\":{\"12\":1}}],[\"这里反而是最简单的\",{\"1\":{\"10\":1}}],[\"这里写了一个三目运算符是为了进行分配任务\",{\"1\":{\"10\":1}}],[\"这里的效果相当于给其成员\",{\"1\":{\"99\":1}}],[\"这里的精度并非是实际的时间精度\",{\"1\":{\"60\":1}}],[\"这里的结果是截断的\",{\"1\":{\"59\":1}}],[\"这里的\",{\"1\":{\"10\":1,\"16\":1}}],[\"这里的调用是必须的\",{\"1\":{\"9\":1}}],[\"这是默认值\",{\"1\":{\"115\":1}}],[\"这是\",{\"1\":{\"107\":1}}],[\"这是个好问题\",{\"1\":{\"103\":1}}],[\"这是个管理类\",{\"1\":{\"13\":1}}],[\"这是重载决议的事情\",{\"1\":{\"99\":1}}],[\"这是库中所有原子操作的默认行为\",{\"1\":{\"83\":1}}],[\"这是正常的\",{\"1\":{\"79\":1}}],[\"这是正常现象\",{\"1\":{\"18\":1}}],[\"这是线程安全的\",{\"1\":{\"79\":1}}],[\"这是由时间周期所决定\",{\"1\":{\"58\":1}}],[\"这是我们在本节需要特别讨论的内容\",{\"1\":{\"55\":1}}],[\"这是移动语义的基本语义逻辑\",{\"1\":{\"52\":1}}],[\"这是未定义行为\",{\"1\":{\"35\":1}}],[\"这是一个典型的线程池结构\",{\"1\":{\"112\":1}}],[\"这是一个函数调用\",{\"1\":{\"107\":1}}],[\"这是一个很重要的类\",{\"1\":{\"58\":1}}],[\"这是一个互斥量的声明\",{\"1\":{\"32\":1}}],[\"这是一个非常典型的\",{\"1\":{\"27\":1}}],[\"这是一个\",{\"1\":{\"27\":1}}],[\"这是一个可以检查停止请求的类型\",{\"1\":{\"21\":1}}],[\"这是一个可以发出停止请求的类型\",{\"1\":{\"21\":1}}],[\"这是无所谓的\",{\"1\":{\"25\":1}}],[\"这是唯一标准用法\",{\"1\":{\"14\":1}}],[\"这是为了那些只支持移动的类型\",{\"1\":{\"14\":1,\"52\":1}}],[\"这是为了让迭代器一直向前\",{\"1\":{\"10\":1}}],[\"这是因为实际上\",{\"1\":{\"107\":1}}],[\"这是因为许多内存次序问题是由于极端的\",{\"1\":{\"81\":1}}],[\"这是因为它们没有进行相应的检测\",{\"1\":{\"71\":1}}],[\"这是因为函数模板不是函数\",{\"1\":{\"53\":1}}],[\"这是因为\",{\"1\":{\"14\":1,\"53\":1,\"54\":1,\"56\":1}}],[\"这是因为我们创建线程对象\",{\"1\":{\"9\":1}}],[\"这是好习惯\",{\"1\":{\"12\":1}}],[\"这是必须的\",{\"1\":{\"0\":1,\"99\":1}}],[\"这基本不可能每一个任务分配一个核心\",{\"1\":{\"5\":1}}],[\"线程容器\",{\"1\":{\"116\":1}}],[\"线程继续取下一个任务或者休眠\",{\"1\":{\"114\":1}}],[\"线程在执行完任务后会进入休眠状态\",{\"1\":{\"112\":1}}],[\"线程在调用\",{\"1\":{\"82\":1}}],[\"线程池的基本概念\",{\"1\":{\"117\":1}}],[\"线程池的最大线程数为当前硬件支持的并发线程数\",{\"1\":{\"115\":1}}],[\"线程池最大线程数\",{\"1\":{\"115\":1}}],[\"线程池中的线程会从任务队列中取出任务并执行\",{\"1\":{\"114\":1}}],[\"线程池会创建对应数量的线程\",{\"1\":{\"114\":1}}],[\"线程池设施\",{\"1\":{\"113\":1}}],[\"线程池包含一个任务队列\",{\"1\":{\"112\":1}}],[\"线程池是指代一组预先创建的\",{\"1\":{\"112\":1}}],[\"线程池则是装着线程\",{\"1\":{\"112\":1}}],[\"线程池\",{\"0\":{\"111\":1},\"1\":{\"112\":2}}],[\"线程池作业存放在\",{\"1\":{\"1\":1}}],[\"线程模型\",{\"1\":{\"100\":1}}],[\"线程也能正确地看到其他线程对共享数据的修改\",{\"1\":{\"82\":1}}],[\"线程基本上就是独立的\",{\"1\":{\"72\":1}}],[\"线程id\",{\"1\":{\"64\":2}}],[\"线程执行完新任务后\",{\"1\":{\"112\":1}}],[\"线程执行\",{\"1\":{\"64\":1}}],[\"线程2\",{\"1\":{\"56\":4}}],[\"线程1\",{\"1\":{\"56\":4}}],[\"线程知道预期结果\",{\"1\":{\"51\":1}}],[\"线程保持等待状态\",{\"1\":{\"49\":1}}],[\"线程就被唤醒\",{\"1\":{\"49\":1}}],[\"线程弹出元素\",{\"1\":{\"48\":5}}],[\"线程插入元素\",{\"1\":{\"48\":5}}],[\"线程依然活跃\",{\"1\":{\"38\":1}}],[\"线程变量适合线程的独立状态\",{\"1\":{\"44\":1}}],[\"线程变量\",{\"0\":{\"43\":1},\"1\":{\"37\":1,\"38\":1,\"40\":1}}],[\"线程局部存储\",{\"1\":{\"37\":1}}],[\"线程存储期的对象在线程开始时分配\",{\"1\":{\"37\":1}}],[\"线程存储期\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"线程可以阻塞\",{\"1\":{\"70\":1}}],[\"线程可以等待\",{\"1\":{\"47\":1}}],[\"线程可以在递归互斥体上重复调用\",{\"1\":{\"35\":1}}],[\"线程可以检测到停止状态是否已被设置为\",{\"1\":{\"21\":1}}],[\"线程对已经上锁的\",{\"1\":{\"35\":1}}],[\"线程对象的大小都是\",{\"1\":{\"100\":1}}],[\"线程对象代表了线程\",{\"1\":{\"18\":1}}],[\"线程对象\",{\"1\":{\"14\":1,\"16\":2}}],[\"线程对象现在是否有关联的活跃线程\",{\"1\":{\"13\":1}}],[\"线程对象当前关联了活跃线程\",{\"1\":{\"13\":1}}],[\"线程对象正常析构\",{\"1\":{\"13\":1}}],[\"线程对象可以正常析构\",{\"1\":{\"12\":1}}],[\"线程对象放弃了线程资源的所有权\",{\"1\":{\"12\":1}}],[\"线程对象不再持有线程资源\",{\"1\":{\"12\":1}}],[\"线程对象调用了\",{\"1\":{\"12\":1}}],[\"线程对象没有关联线程的\",{\"1\":{\"12\":1}}],[\"线程对象关联了一个线程资源\",{\"1\":{\"9\":1}}],[\"线程安全的队列\",{\"0\":{\"48\":1}}],[\"线程安全的问题\",{\"1\":{\"45\":1}}],[\"线程安全的初始化过程\",{\"1\":{\"33\":1}}],[\"线程安全的一次初始化\",{\"1\":{\"33\":1}}],[\"线程不安全\",{\"1\":{\"33\":1}}],[\"线程获取一个锁时\",{\"1\":{\"30\":1}}],[\"线程会在那个调用中结束\",{\"1\":{\"23\":1}}],[\"线程内部可以定期检查\",{\"1\":{\"21\":1}}],[\"线程停止设施你会感觉是一种类似于外部与线程进行某种信号通信的设施\",{\"1\":{\"22\":1}}],[\"线程停止\",{\"0\":{\"21\":1},\"1\":{\"21\":1,\"22\":1}}],[\"线程停止功能\",{\"1\":{\"19\":1}}],[\"线程资源的所有权转移给函数调用\",{\"1\":{\"16\":1}}],[\"线程资源\",{\"1\":{\"16\":1}}],[\"线程是一种系统资源\",{\"1\":{\"16\":1}}],[\"线程需要等待某个操作完成\",{\"1\":{\"15\":1}}],[\"线程开始执行\",{\"1\":{\"12\":1}}],[\"线程独立的运行\",{\"1\":{\"12\":1}}],[\"线程分离\",{\"1\":{\"12\":1}}],[\"线程库启动线程\",{\"1\":{\"12\":1}}],[\"线程管理\",{\"0\":{\"11\":1},\"1\":{\"11\":1}}],[\"线程\",{\"1\":{\"10\":1,\"27\":2,\"28\":6,\"30\":3,\"37\":1,\"43\":1,\"62\":1,\"68\":4,\"70\":2,\"71\":3,\"74\":5,\"79\":2,\"82\":1,\"112\":1}}],[\"线程其实是指所谓的逻辑处理器\",{\"1\":{\"10\":1}}],[\"线程的情况下执行耗时任务\",{\"1\":{\"61\":1}}],[\"线程的接口\",{\"1\":{\"37\":1}}],[\"线程的取消\",{\"1\":{\"19\":1}}],[\"线程的\",{\"1\":{\"10\":1}}],[\"线程更是上千\",{\"1\":{\"5\":1}}],[\"进而引发数据竞争\",{\"1\":{\"79\":1}}],[\"进入\",{\"1\":{\"68\":1}}],[\"进入作用域构造\",{\"1\":{\"27\":1}}],[\"进度条\",{\"1\":{\"62\":1}}],[\"进一步学习和实践\",{\"1\":{\"50\":1}}],[\"进程至少上百个\",{\"1\":{\"5\":1}}],[\"进行的一个包装\",{\"1\":{\"115\":1}}],[\"进行最终的清理\",{\"1\":{\"114\":1}}],[\"进行了重写\",{\"1\":{\"108\":1}}],[\"进行了修改\",{\"1\":{\"82\":2}}],[\"进行约束我们传入的可调用对象的类型不能是\",{\"1\":{\"99\":1}}],[\"进行加载操作\",{\"1\":{\"77\":1}}],[\"进行操作\",{\"1\":{\"75\":1}}],[\"进行操作了\",{\"1\":{\"56\":1}}],[\"进行计数等\",{\"1\":{\"75\":1}}],[\"进行传递\",{\"1\":{\"54\":1}}],[\"进行锁定时\",{\"1\":{\"35\":1}}],[\"进行检测\",{\"1\":{\"31\":1}}],[\"进行调用\",{\"1\":{\"31\":1,\"100\":1}}],[\"进行编译\",{\"1\":{\"21\":1}}],[\"进行清理和终止线程\",{\"1\":{\"21\":1}}],[\"进行初始化\",{\"1\":{\"12\":1}}],[\"进行教学\",{\"1\":{\"3\":1}}],[\"进行多线程编程\",{\"1\":{\"0\":1}}],[\"但你也可以手动进行控制\",{\"1\":{\"114\":1}}],[\"但实际上是通过\",{\"1\":{\"107\":1}}],[\"但实际上停止的决定和实现都由用户代码来完成\",{\"1\":{\"21\":1}}],[\"但我们也扩展涉及了许多其他知识\",{\"1\":{\"94\":1}}],[\"但并未给出标准协程库\",{\"1\":{\"92\":1}}],[\"但并不是所有强一致性模型都是\",{\"1\":{\"85\":1}}],[\"但并不是强制性的线程终止方式\",{\"1\":{\"21\":1}}],[\"但真正核心的概念是可见\",{\"1\":{\"82\":1}}],[\"但这需要程序员使用内存屏障等机制来确保正确性\",{\"1\":{\"85\":1}}],[\"但这还不够\",{\"1\":{\"79\":1}}],[\"但这里使用的是字符串字面量\",{\"1\":{\"14\":1}}],[\"但可以使用非原子的\",{\"1\":{\"77\":1}}],[\"但还未完成\",{\"1\":{\"74\":1}}],[\"但多个\",{\"1\":{\"71\":1}}],[\"但反过来不行\",{\"1\":{\"59\":1}}],[\"但只有一个对象可以获得特定的同步结果\",{\"1\":{\"56\":1}}],[\"但\",{\"1\":{\"56\":1}}],[\"但根据通用的语义\",{\"1\":{\"55\":1}}],[\"但通过阅读源码\",{\"1\":{\"55\":1}}],[\"但通常这不符合我们的需求\",{\"1\":{\"14\":1}}],[\"但调用完成后\",{\"1\":{\"55\":1}}],[\"但无法获取返回值\",{\"1\":{\"53\":1}}],[\"但无数据竞争\",{\"1\":{\"25\":1,\"34\":1}}],[\"但在\",{\"1\":{\"50\":1}}],[\"但很难确定正确的休眠时间\",{\"1\":{\"47\":1}}],[\"但由于构造函数修改了共享数据\",{\"1\":{\"45\":1}}],[\"但需要使用同步设施进行保护\",{\"1\":{\"44\":1}}],[\"但却并不是每次都创建一个新的线程\",{\"1\":{\"38\":1}}],[\"但它同样调用\",{\"1\":{\"107\":1}}],[\"但它可以通过符合类型的指针进行构造和赋值\",{\"1\":{\"78\":1}}],[\"但它并不影响不同线程对同一个互斥量进行锁定的情况\",{\"1\":{\"35\":1}}],[\"但它不能用来定义自动存储期的对象\",{\"1\":{\"32\":1}}],[\"但不会出现假失败\",{\"1\":{\"77\":1}}],[\"但不止如此\",{\"1\":{\"31\":1}}],[\"但不用担心\",{\"1\":{\"0\":1}}],[\"但如果他们都不愿意\",{\"1\":{\"30\":1}}],[\"但如果锁已经被其他线程占用\",{\"1\":{\"28\":1}}],[\"但是子类\",{\"1\":{\"108\":1}}],[\"但是你需要大概的看一下\",{\"1\":{\"107\":1}}],[\"但是你可能被过早的叫醒\",{\"1\":{\"47\":1}}],[\"但是我可以将它转换为\",{\"1\":{\"99\":1}}],[\"但是我们无需在乎\",{\"1\":{\"81\":1}}],[\"但是我们通常不用在意这个事情\",{\"1\":{\"68\":1}}],[\"但是我们显然不能寄希望于这种操作系统的调度\",{\"1\":{\"25\":1}}],[\"但是我们也需要执行这个任务\",{\"1\":{\"10\":1}}],[\"但是基本的需求得能做到\",{\"1\":{\"93\":1,\"100\":1}}],[\"但是应该都听过这个名字\",{\"1\":{\"92\":1}}],[\"但是没有意义\",{\"1\":{\"79\":1}}],[\"但是睡眠锁更加节省资源\",{\"1\":{\"76\":1}}],[\"但是也是限时的\",{\"1\":{\"57\":1}}],[\"但是在一些情况下\",{\"1\":{\"57\":1}}],[\"但是却没有使用\",{\"1\":{\"54\":1}}],[\"但是却是少有的准确与完善\",{\"1\":{\"23\":1}}],[\"但是并不急切的需要它\",{\"1\":{\"52\":1}}],[\"但是互斥量只能解决它能解决的问题\",{\"1\":{\"45\":1}}],[\"但是觉得没必要再聊了\",{\"1\":{\"33\":1}}],[\"但是此时还没有创建\",{\"1\":{\"33\":1}}],[\"但是有些时候又不可避免的有修改和读取都要工作的时候\",{\"1\":{\"34\":1}}],[\"但是有所有权\",{\"1\":{\"31\":1}}],[\"但是有的时候即使固定锁顺序\",{\"1\":{\"30\":1}}],[\"但是调用方传递了\",{\"1\":{\"29\":1}}],[\"但是\",{\"1\":{\"25\":1,\"33\":1,\"49\":1,\"52\":1}}],[\"但是实际什么都调用了\",{\"1\":{\"21\":1}}],[\"但是从始至终只有一个线程资源\",{\"1\":{\"16\":1}}],[\"但是它需要接受的参数不同\",{\"1\":{\"15\":1}}],[\"但是如果耐心的看了一遍\",{\"1\":{\"110\":1}}],[\"但是如果它的内部使用互斥量实现\",{\"1\":{\"75\":1}}],[\"但是如果是指向\",{\"1\":{\"14\":1}}],[\"但是如果抛出了异常呢\",{\"1\":{\"12\":1}}],[\"但是这存在个问题\",{\"1\":{\"56\":1}}],[\"但是这会很疲惫\",{\"1\":{\"47\":1}}],[\"但是这个\",{\"1\":{\"14\":1}}],[\"但是这让\",{\"1\":{\"13\":1}}],[\"但是这是不对的\",{\"1\":{\"12\":1}}],[\"但是这是可能有余数的\",{\"1\":{\"10\":1}}],[\"但是主线程\",{\"1\":{\"12\":1}}],[\"但是核心却没有那么多\",{\"1\":{\"5\":1}}],[\"而有些则需要更多的思考和设计\",{\"1\":{\"116\":1}}],[\"而将任务添加到线程池中的做法非常古老原始\",{\"1\":{\"115\":1}}],[\"而已\",{\"1\":{\"114\":1}}],[\"而它又继承自\",{\"1\":{\"107\":1}}],[\"而构造函数体中调用了一个函数\",{\"1\":{\"99\":1}}],[\"而无需再繁琐的继承重写\",{\"1\":{\"115\":1}}],[\"而无需太多关注底层细节\",{\"1\":{\"82\":1}}],[\"而无法共存\",{\"1\":{\"54\":1}}],[\"而线程\",{\"1\":{\"82\":1}}],[\"而线程对象拥有了线程的所有权\",{\"1\":{\"16\":1}}],[\"而标准库中提供的原子对象的原子操作\",{\"1\":{\"81\":1}}],[\"而这些情况很难被重现\",{\"1\":{\"81\":1}}],[\"而这些共享资源又无法同时被多个线程访问的特性\",{\"1\":{\"45\":1}}],[\"而未能获取时\",{\"1\":{\"76\":1}}],[\"而未展开具体使用\",{\"1\":{\"75\":1}}],[\"而赋值和复制涉及两个对象\",{\"1\":{\"76\":1}}],[\"而后者更适合纯\",{\"1\":{\"100\":1}}],[\"而后者只能减少计数\",{\"1\":{\"71\":1}}],[\"而后者是指定等待到一个具体的时间点\",{\"1\":{\"57\":1}}],[\"而屏障则可以\",{\"1\":{\"69\":1}}],[\"而从多个线程访问同一共享状态\",{\"1\":{\"56\":1}}],[\"而对象生存期结束就会调用调用析构函数\",{\"1\":{\"52\":1}}],[\"而多个线程访问同一共享状态\",{\"1\":{\"51\":1}}],[\"而\",{\"1\":{\"51\":1,\"56\":1,\"77\":1,\"79\":1,\"100\":1,\"108\":1}}],[\"而局部对象在函数结束时析构\",{\"1\":{\"55\":1}}],[\"而局部对象\",{\"1\":{\"36\":1,\"108\":1}}],[\"而非\",{\"1\":{\"95\":2}}],[\"而非实际\",{\"1\":{\"72\":1}}],[\"而非实际进行内核编程\",{\"1\":{\"39\":1}}],[\"而非像上面那样将它自己作为可调用对象\",{\"1\":{\"53\":1}}],[\"而非显式调用\",{\"1\":{\"35\":1}}],[\"而非对线程类\",{\"1\":{\"10\":1}}],[\"而那些无需修改数据结构的读线程\",{\"1\":{\"34\":1}}],[\"而只是分配内存对指针写入\",{\"1\":{\"33\":1}}],[\"而互斥量的所有权可以通过移动操作转移给其他的\",{\"1\":{\"32\":1}}],[\"而函数\",{\"1\":{\"30\":1}}],[\"而不必过多关注具体的\",{\"1\":{\"82\":1}}],[\"而不必直接关心底层的\",{\"1\":{\"82\":1}}],[\"而不需要在代码中引入额外的互斥量来保护\",{\"1\":{\"75\":1}}],[\"而不需要写明模板类型参数\",{\"1\":{\"27\":1}}],[\"而不附加同步\",{\"1\":{\"72\":1,\"79\":1}}],[\"而不会进行所谓的四舍五入\",{\"1\":{\"59\":1}}],[\"而不会造成死锁\",{\"1\":{\"35\":1}}],[\"而不是引用传递\",{\"1\":{\"116\":1}}],[\"而不是驼峰命名法\",{\"1\":{\"95\":1}}],[\"而不是底层的实现细节\",{\"1\":{\"82\":1}}],[\"而不是这些底层实现细节\",{\"1\":{\"82\":1}}],[\"而不是一定\",{\"1\":{\"45\":1}}],[\"而不是一种与操作系统系统有关系的线程终止\",{\"1\":{\"21\":1}}],[\"而不是像之前\",{\"1\":{\"31\":1}}],[\"而不是调用我们传递的可调用对象\",{\"1\":{\"14\":1}}],[\"而不是复制\",{\"1\":{\"14\":1}}],[\"而不是\",{\"1\":{\"12\":1,\"59\":1}}],[\"而另一求值读或修改同一内存位置时\",{\"1\":{\"25\":1}}],[\"而没有影响到原来\",{\"1\":{\"20\":1}}],[\"而移动操作可以将一个\",{\"1\":{\"16\":1}}],[\"而新线程此时还没有进行\",{\"1\":{\"14\":1}}],[\"而是应用的造轮子\",{\"1\":{\"118\":1}}],[\"而是先停止\",{\"1\":{\"114\":1}}],[\"而是直接\",{\"1\":{\"107\":1}}],[\"而是使用了微软的\",{\"1\":{\"107\":1}}],[\"而是为了考虑读者的水平和可能的扩展学习需求\",{\"1\":{\"94\":1}}],[\"而是适用于所有std\",{\"1\":{\"77\":1}}],[\"而是持续检查锁的状态\",{\"1\":{\"76\":1}}],[\"而是所有原子类型共有的属性\",{\"1\":{\"76\":1}}],[\"而是从线程池获取线程\",{\"1\":{\"38\":1}}],[\"而是\",{\"1\":{\"33\":1,\"107\":1}}],[\"而是立即返回\",{\"1\":{\"28\":1}}],[\"而是提供一种线程内外都能检查和响应的信号\",{\"1\":{\"23\":1}}],[\"而是创造一个新的线程类型呢\",{\"1\":{\"20\":1}}],[\"而是在创建的新线程中\",{\"1\":{\"14\":1}}],[\"而是会产生编译错误\",{\"1\":{\"14\":1}}],[\"而是按值复制的\",{\"1\":{\"14\":1}}],[\"而此时子线程还持有它的引用\",{\"1\":{\"12\":1}}],[\"而类名可不会直接变成对象\",{\"1\":{\"12\":1}}],[\"而且个人觉得\",{\"1\":{\"101\":1}}],[\"而且也不是重点\",{\"1\":{\"100\":1}}],[\"而且也没必要\",{\"1\":{\"5\":1}}],[\"而且将不以任何方式穿插或截断\",{\"1\":{\"71\":1}}],[\"而且技术上不影响存储期\",{\"1\":{\"32\":1}}],[\"而且即使不是一个添加元素\",{\"1\":{\"25\":1}}],[\"而且重复运行的结果还不一样\",{\"1\":{\"18\":1}}],[\"而且顾名思义\",{\"1\":{\"13\":1}}],[\"而且只是百万数据通常没必要多线程\",{\"1\":{\"10\":1}}],[\"而第三个线程只处理了平均数量的元素\",{\"1\":{\"10\":1}}],[\"而小于这个值的则直接使用标准库函数\",{\"1\":{\"10\":1}}],[\"而我们的\",{\"1\":{\"56\":1}}],[\"而我们先前一直没有写明这个参数\",{\"1\":{\"52\":1}}],[\"而我们知道\",{\"1\":{\"34\":1}}],[\"而我们本节说的\",{\"1\":{\"11\":1}}],[\"而我们回到代码上即可\",{\"1\":{\"7\":1}}],[\"而我们想以更加现代\",{\"1\":{\"0\":1}}],[\"而操作系统调度基本也一样有任务切换\",{\"1\":{\"5\":1}}],[\"的事件循环\",{\"1\":{\"115\":1}}],[\"的事情就行\",{\"1\":{\"13\":1}}],[\"的集合\",{\"1\":{\"115\":1}}],[\"的很多部分\",{\"1\":{\"110\":1}}],[\"的继承关系让人感到头疼\",{\"1\":{\"110\":1}}],[\"的偏特化为例\",{\"1\":{\"109\":1}}],[\"的组合无关\",{\"1\":{\"109\":1}}],[\"的类型是\",{\"1\":{\"108\":1}}],[\"的类对象\",{\"1\":{\"12\":1}}],[\"的共享状态转移给了这个局部对象\",{\"1\":{\"108\":1}}],[\"的任务在其它线程执行完毕\",{\"1\":{\"108\":1}}],[\"的任务能够在等待前被启动并执行完毕\",{\"1\":{\"108\":1}}],[\"的步骤\",{\"1\":{\"108\":1}}],[\"的父类\",{\"1\":{\"107\":1}}],[\"的行为是相同的\",{\"1\":{\"107\":1}}],[\"的行为一致\",{\"1\":{\"107\":1}}],[\"的核心组件之一\",{\"1\":{\"107\":1}}],[\"的包装\",{\"1\":{\"107\":1}}],[\"的具体作用\",{\"1\":{\"107\":1}}],[\"的定义确实在大多数情况下和\",{\"1\":{\"107\":1}}],[\"的例子\",{\"1\":{\"107\":1}}],[\"的确\",{\"1\":{\"103\":1}}],[\"的确算是没问题\",{\"1\":{\"29\":1}}],[\"的情况了\",{\"1\":{\"108\":1}}],[\"的情况\",{\"1\":{\"100\":1,\"107\":1}}],[\"的第一行代码展示了这一点\",{\"1\":{\"100\":1}}],[\"的第二个非类型模板参数\",{\"1\":{\"59\":1}}],[\"的声明\",{\"1\":{\"99\":1}}],[\"的意义是什么呢\",{\"1\":{\"99\":1}}],[\"的旧值用以初始化当前对象的数据成员\",{\"1\":{\"99\":1}}],[\"的结果就可能是\",{\"1\":{\"100\":1}}],[\"的结果就是\",{\"1\":{\"59\":1}}],[\"的结果应该为\",{\"1\":{\"98\":1}}],[\"的东西\",{\"1\":{\"97\":1,\"106\":1}}],[\"的一些库\",{\"1\":{\"97\":1,\"106\":1}}],[\"的一个特化别名\",{\"1\":{\"68\":1}}],[\"的运行测试链接以确保正确性\",{\"1\":{\"94\":1}}],[\"的程序\",{\"1\":{\"94\":1}}],[\"的程序时\",{\"1\":{\"61\":1}}],[\"的协程是复杂的\",{\"1\":{\"92\":1}}],[\"的协程一无所知\",{\"1\":{\"92\":1}}],[\"的控制块是线程安全的\",{\"1\":{\"90\":1}}],[\"的成员函数\",{\"1\":{\"90\":1,\"107\":3,\"108\":2}}],[\"的关系\",{\"0\":{\"90\":1}}],[\"的弱一致性模型有所不同\",{\"1\":{\"85\":1}}],[\"的强一致性模型\",{\"1\":{\"85\":1}}],[\"的设计目标是简化指令集\",{\"1\":{\"85\":1}}],[\"的设计哲学\",{\"1\":{\"20\":1}}],[\"的完成会确保操作\",{\"1\":{\"82\":1}}],[\"的完整运行示例\",{\"1\":{\"32\":1}}],[\"的内容非常之多\",{\"1\":{\"108\":1}}],[\"的内容同样重要\",{\"1\":{\"106\":1}}],[\"的内存模型\",{\"0\":{\"85\":1}}],[\"的内存序机制可以确保数据修改的可见\",{\"1\":{\"82\":1}}],[\"的内部实现\",{\"1\":{\"79\":1}}],[\"的写操作在其他线程\",{\"1\":{\"82\":1}}],[\"的修改对线程\",{\"1\":{\"82\":1}}],[\"的修改\",{\"1\":{\"82\":3}}],[\"的指令重排必须遵循一定的规则\",{\"1\":{\"81\":1}}],[\"的指针\",{\"1\":{\"12\":1,\"79\":1}}],[\"的保护\",{\"1\":{\"79\":1}}],[\"的通常实现只保有两个指针\",{\"1\":{\"79\":1}}],[\"的通常实现就是单纯的保有\",{\"1\":{\"20\":1}}],[\"的实例进行所有访问\",{\"1\":{\"79\":1}}],[\"的实现使用到了微软自己实现的\",{\"1\":{\"107\":1}}],[\"的实现进行讲解\",{\"1\":{\"106\":1}}],[\"的实现是最简单直观的\",{\"1\":{\"101\":1}}],[\"的实现只保有一个\",{\"1\":{\"100\":1}}],[\"的实现中\",{\"1\":{\"38\":1,\"52\":1,\"68\":1}}],[\"的实现\",{\"1\":{\"27\":1,\"101\":1,\"107\":1}}],[\"的另一个不同是\",{\"1\":{\"77\":1}}],[\"的操作\",{\"1\":{\"77\":1}}],[\"的局限性太强\",{\"1\":{\"76\":1}}],[\"的文章\",{\"1\":{\"76\":1}}],[\"的默认构造函数保证对象为\",{\"1\":{\"76\":1}}],[\"的可平凡复制\",{\"1\":{\"75\":1}}],[\"的前缀\",{\"1\":{\"75\":1}}],[\"的静态数据成员\",{\"1\":{\"75\":1}}],[\"的静态成员函数\",{\"1\":{\"10\":1}}],[\"的数量\",{\"1\":{\"79\":2}}],[\"的数据成员的时候已经把这个模板类的全部源码\",{\"1\":{\"103\":1}}],[\"的数据成员\",{\"0\":{\"98\":1,\"102\":1},\"1\":{\"75\":1,\"107\":1}}],[\"的数组\",{\"1\":{\"12\":1}}],[\"的最大值\",{\"1\":{\"72\":1}}],[\"的最小睡眠时间默认就是\",{\"1\":{\"60\":1}}],[\"的非延迟执行策略\",{\"1\":{\"110\":1}}],[\"的非\",{\"1\":{\"72\":1,\"79\":3}}],[\"的作用就非常明显了\",{\"1\":{\"71\":1}}],[\"的计数减少至\",{\"1\":{\"70\":1}}],[\"的计数不可增加\",{\"1\":{\"70\":1}}],[\"的计算\",{\"1\":{\"27\":1}}],[\"的特定构造函数\",{\"1\":{\"107\":1}}],[\"的特化都拥有这些成员函数\",{\"1\":{\"79\":1}}],[\"的特化版本\",{\"1\":{\"79\":1}}],[\"的特化的别名\",{\"1\":{\"68\":1}}],[\"的特殊对象\",{\"1\":{\"26\":1}}],[\"的接收者\",{\"1\":{\"68\":1}}],[\"的响应情况\",{\"1\":{\"67\":1}}],[\"的精度是\",{\"1\":{\"60\":1}}],[\"的时间库极其繁杂\",{\"1\":{\"58\":1}}],[\"的时候上锁了\",{\"1\":{\"30\":1}}],[\"的时候上锁\",{\"1\":{\"27\":1}}],[\"的时候\",{\"1\":{\"12\":1,\"14\":1,\"26\":1,\"79\":1}}],[\"的时候就关联了一个活跃的线程\",{\"1\":{\"9\":1}}],[\"的时候应该都写过这样一段代码\",{\"1\":{\"9\":1}}],[\"的等待函数\",{\"1\":{\"57\":1}}],[\"的副本可以调用一切成员函数\",{\"1\":{\"90\":1}}],[\"的副本\",{\"1\":{\"56\":1,\"79\":1}}],[\"的副本了\",{\"1\":{\"56\":1}}],[\"的所有权\",{\"1\":{\"56\":1}}],[\"的所有特化中\",{\"1\":{\"55\":1}}],[\"的所有功能\",{\"1\":{\"34\":1}}],[\"的状态原子地更改为设置\",{\"1\":{\"76\":2}}],[\"的状态原子地更改为清除\",{\"1\":{\"76\":1}}],[\"的状态变化\",{\"0\":{\"55\":1},\"1\":{\"108\":1}}],[\"的状态是确定的\",{\"1\":{\"27\":1}}],[\"的异常\",{\"1\":{\"54\":2}}],[\"的值都为\",{\"1\":{\"100\":1}}],[\"的值有两种方式\",{\"1\":{\"77\":1}}],[\"的值是多少也不确定\",{\"1\":{\"74\":1}}],[\"的值\",{\"1\":{\"54\":1,\"72\":1,\"74\":2}}],[\"的值相比\",{\"1\":{\"20\":1}}],[\"的平方是\",{\"1\":{\"54\":1}}],[\"的形式\",{\"1\":{\"53\":1}}],[\"的形参是谁传递的\",{\"1\":{\"21\":1}}],[\"的形参类型不是\",{\"1\":{\"14\":1}}],[\"的形参会调整为具有类型\",{\"1\":{\"12\":1}}],[\"的重载版本\",{\"1\":{\"115\":1}}],[\"的重载\",{\"1\":{\"53\":1,\"99\":1}}],[\"的执行策略\",{\"1\":{\"52\":1}}],[\"的返回类型就是\",{\"1\":{\"58\":1}}],[\"的返回类型\",{\"1\":{\"51\":1,\"103\":1}}],[\"的视频教程\",{\"1\":{\"51\":1}}],[\"的音乐\",{\"1\":{\"50\":1}}],[\"的无效开销\",{\"1\":{\"49\":1}}],[\"的功能相当有限\",{\"1\":{\"79\":1}}],[\"的功能受限\",{\"1\":{\"70\":1}}],[\"的功能\",{\"1\":{\"49\":1}}],[\"的模板类\",{\"1\":{\"48\":1}}],[\"的泛化\",{\"1\":{\"47\":1}}],[\"的对象拥有此存储期\",{\"1\":{\"43\":1}}],[\"的对象就是指代线程的对象\",{\"1\":{\"11\":1}}],[\"的扩展\",{\"1\":{\"37\":1}}],[\"的编译器扩展\",{\"1\":{\"37\":2,\"94\":1}}],[\"的编译器扩展即可\",{\"1\":{\"37\":1}}],[\"的概念源自操作系统\",{\"1\":{\"37\":1}}],[\"的开销是过大的\",{\"1\":{\"34\":1}}],[\"的开发者链接\",{\"1\":{\"21\":1}}],[\"的初始化\",{\"1\":{\"33\":1}}],[\"的移动构造罢了\",{\"1\":{\"32\":1}}],[\"的要求\",{\"1\":{\"32\":1}}],[\"的代码\",{\"1\":{\"30\":1,\"52\":1}}],[\"的代码中\",{\"1\":{\"12\":1}}],[\"的互斥量执行完毕才能解锁\",{\"1\":{\"30\":1}}],[\"的互斥量\",{\"1\":{\"30\":7}}],[\"的分支\",{\"1\":{\"28\":1}}],[\"的生存期\",{\"1\":{\"27\":1}}],[\"的性能和内存占用\",{\"1\":{\"20\":1}}],[\"的源码你可能注意到了一个问题\",{\"1\":{\"108\":1}}],[\"的源码我认为无需过多篇幅或者示例\",{\"1\":{\"108\":1}}],[\"的源码解析\",{\"1\":{\"104\":1}}],[\"的源码的时候也提到过\",{\"1\":{\"103\":1}}],[\"的源码实现\",{\"1\":{\"47\":1}}],[\"的源码实现与解析\",{\"0\":{\"101\":1},\"1\":{\"30\":1}}],[\"的源码实现来配合理解\",{\"1\":{\"22\":1}}],[\"的源码\",{\"1\":{\"18\":1}}],[\"的区别\",{\"1\":{\"57\":1}}],[\"的区别就如同\",{\"1\":{\"56\":1}}],[\"的区别就是析构函数会自动\",{\"1\":{\"18\":1}}],[\"的区别无非是\",{\"1\":{\"12\":1}}],[\"的使用\",{\"1\":{\"17\":1,\"70\":1,\"107\":1}}],[\"的使用了\",{\"1\":{\"10\":1}}],[\"的这次\",{\"1\":{\"16\":1}}],[\"的占用\",{\"1\":{\"15\":1}}],[\"的别名\",{\"1\":{\"15\":1}}],[\"的调用在多线程环境中可能会交错\",{\"1\":{\"71\":1}}],[\"的调用次数一样\",{\"1\":{\"35\":1}}],[\"的调用恰好比\",{\"1\":{\"35\":1}}],[\"的调用将阻塞执行\",{\"1\":{\"26\":1}}],[\"的调用\",{\"1\":{\"14\":1}}],[\"的转换构造函数\",{\"1\":{\"14\":1}}],[\"的线程池对象在析构时会自动调用相关的清理方法\",{\"1\":{\"114\":1}}],[\"的线程可见\",{\"1\":{\"82\":1}}],[\"的线程在完成第三轮同步后退出\",{\"1\":{\"71\":1}}],[\"的线程成功调用\",{\"1\":{\"27\":1}}],[\"的线程得以继续往下执行\",{\"1\":{\"26\":1}}],[\"的线程资源所有权到\",{\"1\":{\"16\":1}}],[\"的线程资源的所有权移交给\",{\"1\":{\"16\":1}}],[\"的线程\",{\"1\":{\"14\":1}}],[\"的缩写\",{\"1\":{\"14\":1}}],[\"的引用\",{\"1\":{\"14\":3,\"99\":1}}],[\"的引用被子线程持有\",{\"1\":{\"12\":1}}],[\"的构造与析构\",{\"0\":{\"103\":1}}],[\"的构造与源码分析最后说的\",{\"1\":{\"101\":1}}],[\"的构造函数是\",{\"1\":{\"107\":1}}],[\"的构造函数接受的却不是\",{\"1\":{\"107\":1}}],[\"的构造函数\",{\"0\":{\"99\":1},\"1\":{\"107\":1}}],[\"的构造函数会自增一个全局变量\",{\"1\":{\"45\":1}}],[\"的构造函数中成功调用\",{\"1\":{\"27\":1}}],[\"的构造函数中\",{\"1\":{\"14\":1}}],[\"的构造函数中调用了创建线程的函数\",{\"1\":{\"14\":1}}],[\"的构造函数其实并没有申请资源\",{\"1\":{\"13\":1}}],[\"的构造\",{\"0\":{\"97\":1},\"1\":{\"14\":1,\"17\":1}}],[\"的构造没有问题\",{\"1\":{\"14\":1}}],[\"的构造参数即可\",{\"1\":{\"14\":1}}],[\"的\",{\"1\":{\"12\":2,\"14\":2,\"21\":3,\"25\":1,\"27\":1,\"31\":1,\"52\":1,\"53\":1,\"59\":1,\"65\":2,\"66\":2,\"71\":3,\"77\":1,\"82\":2,\"85\":1,\"107\":1,\"108\":1}}],[\"的参数全部转发给它\",{\"1\":{\"107\":1}}],[\"的参数\",{\"1\":{\"12\":1}}],[\"的空参的函数指针类型\",{\"1\":{\"12\":1}}],[\"的两倍\",{\"1\":{\"10\":1}}],[\"的熟悉程度\",{\"1\":{\"10\":1}}],[\"的简单的模板函数\",{\"1\":{\"10\":1}}],[\"的进行多线程求和\",{\"1\":{\"10\":1}}],[\"的距离\",{\"1\":{\"10\":1}}],[\"的环境运行也可以自行修改为\",{\"1\":{\"10\":1}}],[\"的析构函数调用\",{\"1\":{\"21\":1}}],[\"的析构函数中\",{\"1\":{\"13\":1,\"21\":1}}],[\"的析构函数\",{\"1\":{\"9\":1,\"27\":1}}],[\"的析构函数将调用\",{\"1\":{\"9\":1}}],[\"的假象\",{\"1\":{\"5\":1}}],[\"的教案\",{\"1\":{\"0\":1}}],[\"任一线程使用\",{\"1\":{\"79\":1}}],[\"任务按提交顺序执行\",{\"1\":{\"116\":1}}],[\"任务队列\",{\"1\":{\"116\":1}}],[\"任务执行完毕后\",{\"1\":{\"114\":1}}],[\"任务执行完毕线程是否立即销毁\",{\"1\":{\"52\":1}}],[\"任务会被添加到任务队列中\",{\"1\":{\"114\":1}}],[\"任务开始执行\",{\"1\":{\"70\":2}}],[\"任务与\",{\"1\":{\"53\":1}}],[\"任务在线程中执行\",{\"1\":{\"53\":1,\"62\":1}}],[\"任务并不会在线程中执行\",{\"1\":{\"53\":1}}],[\"任务切换会给你一种\",{\"1\":{\"5\":1}}],[\"任何创建和销毁存在较大开销的设施\",{\"1\":{\"112\":1}}],[\"任何\",{\"1\":{\"75\":1}}],[\"任何持有与这个\",{\"1\":{\"21\":1}}],[\"任何组织和个人遵守\",{\"1\":{\"0\":1}}],[\"多媒体库\",{\"1\":{\"60\":1}}],[\"多数函数都对两种超时方式进行处理\",{\"1\":{\"57\":1}}],[\"多一次\",{\"1\":{\"35\":1}}],[\"多个对象可以指代同一个共享状态\",{\"1\":{\"56\":1}}],[\"多个线程可以安全地创建\",{\"1\":{\"79\":1}}],[\"多个线程可以一起读取\",{\"1\":{\"34\":1}}],[\"多个线程不同步地同时访问同一std\",{\"1\":{\"79\":1}}],[\"多个线程能在不同的\",{\"1\":{\"72\":1,\"79\":1}}],[\"多个线程的等待\",{\"0\":{\"56\":1}}],[\"多个线程同时对其进行访问和修改时\",{\"1\":{\"36\":1}}],[\"多个互斥量才可能遇到死锁问题\",{\"1\":{\"30\":1}}],[\"多次\",{\"1\":{\"33\":1}}],[\"多了一个解除阻塞的可能\",{\"1\":{\"57\":1}}],[\"多了一个\",{\"1\":{\"31\":1}}],[\"多记忆\",{\"1\":{\"23\":1}}],[\"多线程并发编程中的一个重要概念\",{\"1\":{\"82\":1}}],[\"多线程读取\",{\"1\":{\"34\":1}}],[\"多线程共享数据的问题\",{\"1\":{\"24\":1}}],[\"多线程执行就是如此\",{\"1\":{\"18\":1}}],[\"多线程增加了这个问题发生的几率\",{\"1\":{\"12\":1}}],[\"多线程求和只需要介绍三个地方\",{\"1\":{\"10\":1}}],[\"多线程编程\",{\"1\":{\"3\":1}}],[\"多核机器的真正并行\",{\"1\":{\"5\":1}}],[\"在本章中我们详细的介绍了\",{\"1\":{\"117\":1}}],[\"在本节中\",{\"1\":{\"48\":1}}],[\"在某些特殊情况下可能返回\",{\"1\":{\"114\":1}}],[\"在了解了线程池的基本概念与运行逻辑后\",{\"1\":{\"113\":1}}],[\"在函数结束时析构\",{\"1\":{\"108\":1}}],[\"在函数中调用\",{\"1\":{\"16\":1}}],[\"在第四章的\",{\"1\":{\"108\":1}}],[\"在第一次调用\",{\"1\":{\"107\":1}}],[\"在第一步时\",{\"1\":{\"79\":1}}],[\"在当前我们难以直接展示它的作用\",{\"1\":{\"107\":1}}],[\"在讲述\",{\"1\":{\"106\":1,\"108\":1,\"109\":1}}],[\"在讲述它的使用细节之前\",{\"1\":{\"57\":1}}],[\"在上一节讲\",{\"1\":{\"103\":1}}],[\"在上一章内容\",{\"1\":{\"24\":1}}],[\"在64\",{\"1\":{\"98\":1}}],[\"在我在\",{\"1\":{\"92\":1}}],[\"在我们之前讲的\",{\"1\":{\"103\":1}}],[\"在我们初学\",{\"1\":{\"9\":1}}],[\"在我们谈起\",{\"1\":{\"3\":1}}],[\"在其之后的执行中\",{\"1\":{\"82\":1}}],[\"在其后所有的调用中\",{\"1\":{\"43\":1}}],[\"在讨论多线程的内存模型和执行顺序时\",{\"1\":{\"82\":1}}],[\"在讨论了\",{\"1\":{\"72\":1}}],[\"在运行程序时\",{\"1\":{\"81\":1}}],[\"在开始学习之前\",{\"1\":{\"81\":1}}],[\"在开发带有\",{\"1\":{\"61\":1}}],[\"在使用\",{\"1\":{\"79\":1}}],[\"在前文中\",{\"1\":{\"79\":1}}],[\"在后续章节中\",{\"1\":{\"75\":1}}],[\"在后续我们详细介绍\",{\"1\":{\"16\":1}}],[\"在后面的内容会详细讲述\",{\"1\":{\"75\":1}}],[\"在后面详细的展开使用\",{\"1\":{\"75\":1}}],[\"在一些情况下\",{\"1\":{\"75\":1}}],[\"在一起讨论\",{\"1\":{\"37\":1}}],[\"在高频交易系统\",{\"1\":{\"75\":1}}],[\"在实际应用中\",{\"1\":{\"75\":1}}],[\"在预处理阶段就选择编译合适的代码\",{\"1\":{\"75\":1}}],[\"在编译时对各种整数原子类型是否无锁进行判断\",{\"1\":{\"75\":1}}],[\"在下节我们会详细讲解\",{\"1\":{\"74\":1}}],[\"在之前的内容中\",{\"1\":{\"74\":1}}],[\"在这个时候请考虑使用尽可能功能最少的那一个\",{\"1\":{\"70\":1}}],[\"在这个例子中\",{\"1\":{\"70\":1}}],[\"在此方面可把信号量当作条件变量的替代品\",{\"1\":{\"68\":1}}],[\"在各种编程语言中都有自己的抽象实现\",{\"1\":{\"68\":1}}],[\"在启动进度条后\",{\"1\":{\"62\":1}}],[\"在多个线程中对同一个\",{\"1\":{\"56\":2}}],[\"在多线程环境中的访问\",{\"1\":{\"116\":1}}],[\"在多线程编程中\",{\"1\":{\"46\":1}}],[\"在多线程的情况下\",{\"1\":{\"25\":1}}],[\"在需要时调用\",{\"1\":{\"114\":1}}],[\"在需要的时候获取返回值\",{\"1\":{\"53\":1}}],[\"在需要快速响应的程序中就意味着丢帧或错过了一个时间片\",{\"1\":{\"47\":1}}],[\"在没有任务时\",{\"1\":{\"49\":1}}],[\"在程序启动时\",{\"1\":{\"49\":1}}],[\"在执行了三轮同步便直接退出了\",{\"1\":{\"71\":1}}],[\"在执行\",{\"1\":{\"48\":1}}],[\"在循环中等待并判断条件可一并解决\",{\"1\":{\"47\":1}}],[\"在规定时间内等待\",{\"1\":{\"46\":1}}],[\"在临界区中\",{\"1\":{\"45\":1}}],[\"在并发编程中\",{\"1\":{\"40\":1,\"72\":1}}],[\"在创建对象的时候初始化计数器的值\",{\"1\":{\"70\":1}}],[\"在创建\",{\"1\":{\"39\":1}}],[\"在创建线程执行之前先定义了一个开始迭代器\",{\"1\":{\"10\":1}}],[\"在每个任务中被正确销毁析构\",{\"1\":{\"38\":1}}],[\"在不同硬件上有不同的值\",{\"1\":{\"58\":1}}],[\"在不同线程上执行异步任务\",{\"1\":{\"52\":1}}],[\"在不同编译器上的输出结果\",{\"1\":{\"38\":1}}],[\"在不同作用域传递互斥量\",{\"0\":{\"32\":1}}],[\"在持有锁的情况下\",{\"1\":{\"30\":1}}],[\"在无保护的情况下访问保护数据\",{\"1\":{\"29\":1}}],[\"在大多数情况下\",{\"1\":{\"25\":1}}],[\"在最后谈起了\",{\"1\":{\"23\":1}}],[\"在调用\",{\"1\":{\"14\":1,\"108\":1}}],[\"在析构时自动调用\",{\"1\":{\"19\":1}}],[\"在析构的时候进行了\",{\"1\":{\"13\":1}}],[\"在析构函数中使用\",{\"1\":{\"13\":1}}],[\"在异常处理过程中调用\",{\"1\":{\"12\":1}}],[\"在单线程的代码中\",{\"1\":{\"12\":1}}],[\"在线程\",{\"1\":{\"74\":1}}],[\"在线程中执行任务是没有返回值的\",{\"1\":{\"51\":1}}],[\"在线程调用\",{\"1\":{\"35\":1}}],[\"在线程退出时释放所有分配的资源\",{\"1\":{\"12\":1}}],[\"在线程对象构造成功\",{\"1\":{\"9\":1}}],[\"在确定每个形参的类型后\",{\"1\":{\"12\":1}}],[\"在\",{\"1\":{\"11\":1,\"13\":1,\"15\":1,\"37\":1,\"38\":1,\"39\":2,\"47\":2,\"52\":2,\"58\":2,\"59\":2,\"60\":1,\"62\":1,\"68\":1,\"70\":1,\"71\":1,\"75\":1,\"76\":5,\"79\":1,\"100\":1,\"108\":1,\"115\":1}}],[\"在传递给线程执行的lambda表达式中\",{\"1\":{\"10\":1}}],[\"在进行多线程编程时\",{\"1\":{\"10\":1}}],[\"在新线程中执行函数\",{\"1\":{\"14\":1}}],[\"在新线程中执行\",{\"1\":{\"9\":1}}],[\"在标准\",{\"1\":{\"8\":1}}],[\"在现在\",{\"1\":{\"5\":1}}],[\"在早期\",{\"1\":{\"5\":1}}],[\"在计算机中的并发\",{\"0\":{\"5\":1}}],[\"也希望能让读者避免获取二手知识与理解\",{\"1\":{\"94\":1}}],[\"也得在可观测行为发生前回溯了\",{\"1\":{\"81\":1}}],[\"也会对指令进行重排\",{\"1\":{\"81\":1}}],[\"也会稍微涉及一些其它库\",{\"1\":{\"3\":1}}],[\"也能知道它是原子类型\",{\"1\":{\"79\":1}}],[\"也能带来更高的性能\",{\"1\":{\"75\":1}}],[\"也能提升对多处理器系统性能优化的理解\",{\"1\":{\"39\":1}}],[\"也执行了递增操作\",{\"1\":{\"74\":1}}],[\"也提供了屏障机制来支持多线程编程\",{\"1\":{\"69\":1}}],[\"也很好理解\",{\"1\":{\"59\":1}}],[\"也同\",{\"1\":{\"56\":1}}],[\"也要求更高版本的工具链\",{\"1\":{\"50\":1}}],[\"也需要确保没有其他线程正在执行\",{\"1\":{\"48\":1}}],[\"也称\",{\"1\":{\"47\":1}}],[\"也无法跨平台\",{\"1\":{\"44\":1}}],[\"也肯定无法使用\",{\"1\":{\"37\":1}}],[\"也与全局变量\",{\"1\":{\"37\":1}}],[\"也必须是老老实实上锁解锁\",{\"1\":{\"34\":1}}],[\"也只有一个线程会执行\",{\"1\":{\"33\":1}}],[\"也有两个超时的版本\",{\"1\":{\"57\":1}}],[\"也有人喜欢称作\",{\"1\":{\"37\":1}}],[\"也有一些例外情况\",{\"1\":{\"33\":1}}],[\"也有专门的保护方式\",{\"1\":{\"33\":1}}],[\"也有可能先执行\",{\"1\":{\"25\":1}}],[\"也在等待函数\",{\"1\":{\"30\":1}}],[\"也完全有可能连续\",{\"1\":{\"27\":1}}],[\"也一样会有问题\",{\"1\":{\"25\":1}}],[\"也是操作系统的一种抽象资源\",{\"1\":{\"112\":1}}],[\"也是最严格的内存次序\",{\"1\":{\"83\":1}}],[\"也是最好的\",{\"1\":{\"47\":1}}],[\"也是要靠开发者的正确使用\",{\"1\":{\"79\":1}}],[\"也是完全可以的\",{\"1\":{\"75\":1}}],[\"也是完全可行\",{\"1\":{\"32\":1}}],[\"也是良性竞争\",{\"1\":{\"25\":1}}],[\"也是默认按值复制的\",{\"1\":{\"14\":1}}],[\"也没问题\",{\"1\":{\"12\":1}}],[\"也不能保证它在其他平台上也能表现良好\",{\"1\":{\"81\":1}}],[\"也不要求一定是函数\",{\"1\":{\"33\":1}}],[\"也不要想着\",{\"1\":{\"12\":1}}],[\"也不需要会什么元编程\",{\"1\":{\"93\":1,\"100\":1}}],[\"也不需要上锁\",{\"1\":{\"27\":1}}],[\"也不需要再次\",{\"1\":{\"12\":1}}],[\"也不成问题\",{\"1\":{\"0\":1}}],[\"也就完成了\",{\"1\":{\"116\":1}}],[\"也就没有问题了\",{\"1\":{\"110\":1}}],[\"也就满足了我们的要求\",{\"1\":{\"99\":1}}],[\"也就可以了\",{\"1\":{\"48\":1,\"53\":1}}],[\"也就还未释放\",{\"1\":{\"38\":1}}],[\"也就足够了\",{\"1\":{\"12\":1}}],[\"也就是对返回类型为引用和\",{\"1\":{\"108\":1}}],[\"也就是我们传入的可调用对象的返回类型\",{\"1\":{\"107\":1}}],[\"也就是我们要进行求和的元素个数了\",{\"1\":{\"10\":1}}],[\"也就是不指明执行策略的时候就会匹配到第二个重载版本\",{\"1\":{\"107\":1}}],[\"也就是弃值表达式\",{\"1\":{\"103\":1}}],[\"也就是有三个版本\",{\"1\":{\"102\":1}}],[\"也就是置空\",{\"1\":{\"99\":1}}],[\"也就是执行完第三轮同步后只有三个活跃线程继续执行\",{\"1\":{\"71\":1}}],[\"也就是减少计数\",{\"1\":{\"70\":1}}],[\"也就是允许\",{\"1\":{\"68\":1}}],[\"也就是其它线程执行了\",{\"1\":{\"68\":1}}],[\"也就是其实我们可以直接\",{\"1\":{\"59\":1}}],[\"也就是等待到一个时间点\",{\"1\":{\"60\":1}}],[\"也就是一毫秒了\",{\"1\":{\"59\":1}}],[\"也就是一秒\",{\"1\":{\"59\":1}}],[\"也就是一个临时对象\",{\"1\":{\"79\":1}}],[\"也就是一个时钟所用的秒数\",{\"1\":{\"59\":1}}],[\"也就是一个\",{\"1\":{\"53\":1}}],[\"也就是一个线程\",{\"1\":{\"48\":1}}],[\"也就是分子与分母\",{\"1\":{\"58\":1}}],[\"也就是移动传递参数并接受返回值\",{\"1\":{\"52\":1}}],[\"也就是就算全是读的情况\",{\"1\":{\"34\":1}}],[\"也就是说不存在引用类型\",{\"1\":{\"107\":1}}],[\"也就是说我们可以这样初始化\",{\"1\":{\"76\":1}}],[\"也就是说在多线程中可能会被另一个线程观察到只完成一半\",{\"1\":{\"74\":1}}],[\"也就是说第二个参数的实际类型是\",{\"1\":{\"60\":1}}],[\"也就是说虽然最初的那段代码看似什么都没调用\",{\"1\":{\"21\":1}}],[\"也就是说\",{\"1\":{\"14\":1,\"31\":1,\"60\":1,\"82\":2,\"98\":1,\"107\":1}}],[\"也就是线程对象没有关联活跃线程了\",{\"1\":{\"12\":1}}],[\"也就是构造\",{\"1\":{\"12\":1}}],[\"也就是\",{\"1\":{\"12\":1,\"17\":1,\"20\":1,\"23\":1,\"30\":1,\"31\":1,\"53\":1,\"56\":1,\"59\":1,\"82\":1,\"99\":1,\"103\":1}}],[\"也就是真正的\",{\"1\":{\"5\":1}}],[\"也可以简单理解\",{\"1\":{\"107\":1}}],[\"也可以换为更加通用常见的\",{\"1\":{\"77\":1}}],[\"也可以使用原子类型的别名\",{\"1\":{\"75\":1}}],[\"也可以在线程中传递\",{\"1\":{\"53\":1}}],[\"也可以直接使用\",{\"1\":{\"50\":1}}],[\"也可以直接叫函数对象\",{\"1\":{\"12\":1}}],[\"也可以处于解锁\",{\"1\":{\"26\":1}}],[\"也可以两只手同时做不同的动作\",{\"1\":{\"4\":1}}],[\"也意味着这颗\",{\"1\":{\"10\":1}}],[\"那如果我们没有提前显式调用\",{\"1\":{\"114\":1}}],[\"那那将\",{\"1\":{\"114\":1}}],[\"那不如我们先来进行一下基础的名词解释\",{\"1\":{\"112\":1}}],[\"那是因为其实现细节都在其父类\",{\"1\":{\"108\":1}}],[\"那是不现实的\",{\"1\":{\"100\":1}}],[\"那这两个的共同点是什么呢\",{\"1\":{\"103\":1}}],[\"那会显得文章很冗长\",{\"1\":{\"100\":1}}],[\"那自然是全方面的\",{\"1\":{\"94\":1}}],[\"那自然是只有一次\",{\"1\":{\"33\":1}}],[\"那有没有可能\",{\"1\":{\"81\":1}}],[\"那也没有负提升\",{\"1\":{\"75\":1}}],[\"那也是封装好了的\",{\"1\":{\"75\":1}}],[\"那些基于系统时钟的\",{\"1\":{\"60\":1}}],[\"那它等价于\",{\"1\":{\"60\":1}}],[\"那我们就提一下\",{\"1\":{\"59\":1}}],[\"那我们就讲第二种\",{\"1\":{\"6\":1}}],[\"那时开发者通常使用\",{\"1\":{\"37\":1}}],[\"那只有一种可能\",{\"1\":{\"16\":1}}],[\"那里的\",{\"1\":{\"12\":1}}],[\"那就必须显式调用\",{\"1\":{\"77\":1}}],[\"那就打印超时\",{\"1\":{\"60\":1}}],[\"那就记住\",{\"1\":{\"33\":1}}],[\"那就先执行完\",{\"1\":{\"18\":1}}],[\"那就调用\",{\"1\":{\"12\":1}}],[\"那就只能是任务切换\",{\"1\":{\"5\":1}}],[\"那么效果如同\",{\"1\":{\"116\":1}}],[\"那么实际会调用\",{\"1\":{\"108\":1}}],[\"那么接下来就是\",{\"1\":{\"108\":1}}],[\"那么接下来看析构函数\",{\"1\":{\"31\":1}}],[\"那么也得给个\",{\"1\":{\"108\":1}}],[\"那么到此也就够了\",{\"1\":{\"103\":1}}],[\"那么其他线程\",{\"1\":{\"82\":1}}],[\"那么其他线程此时也就能再有一个成功调用\",{\"1\":{\"26\":1}}],[\"那么自然不存在数据竞争\",{\"1\":{\"79\":1}}],[\"那么为什么呢\",{\"1\":{\"79\":1}}],[\"那么第一个线程调用\",{\"1\":{\"77\":1}}],[\"那么依赖这个结果的代码需要显式地进行加载\",{\"1\":{\"77\":1}}],[\"那么我们说线程\",{\"1\":{\"82\":1}}],[\"那么我们可以利用这一点进行性能优化\",{\"1\":{\"75\":1}}],[\"那么我们稍微聊一下\",{\"1\":{\"14\":1}}],[\"那么不可能有性能的提升\",{\"1\":{\"75\":1}}],[\"那么不就卡界面了\",{\"1\":{\"67\":1}}],[\"那么行为有良好定义\",{\"1\":{\"75\":1}}],[\"那么执行\",{\"1\":{\"68\":2}}],[\"那么代表默认\",{\"1\":{\"59\":1}}],[\"那么它的\",{\"1\":{\"58\":1}}],[\"那么它的线程安全就要我们来保证\",{\"1\":{\"36\":1}}],[\"那么将阻塞当前线程\",{\"1\":{\"54\":1}}],[\"那么一切都不成问题\",{\"1\":{\"53\":1}}],[\"那么一样存在数据竞争\",{\"1\":{\"36\":1}}],[\"那么系统可能会选择延迟执行\",{\"1\":{\"52\":1}}],[\"那么系统可能会选择在新线程中执行任务\",{\"1\":{\"52\":1}}],[\"那么当前线程会重新获取锁\",{\"1\":{\"47\":1}}],[\"那么你要如何在正确的站点下车呢\",{\"1\":{\"47\":1}}],[\"那么你不是还得执行一个\",{\"1\":{\"12\":1}}],[\"那么即使局部对象本身是独立的\",{\"1\":{\"45\":1}}],[\"那么在完整表达式结尾\",{\"1\":{\"52\":1}}],[\"那么在\",{\"1\":{\"38\":1}}],[\"那么函数\",{\"1\":{\"32\":1}}],[\"那么函数局部对象的生存期都已经结束了\",{\"1\":{\"12\":1}}],[\"那么可以考虑使用\",{\"1\":{\"31\":1}}],[\"那么灵活在哪\",{\"1\":{\"31\":1}}],[\"那么这个线程在①的时候就不会进入\",{\"1\":{\"33\":1}}],[\"那么这个遥控汽车就谁都没有办法玩\",{\"1\":{\"30\":1}}],[\"那么这个互斥量就处于解锁状态\",{\"1\":{\"26\":1}}],[\"那么线程\",{\"1\":{\"27\":1}}],[\"那么问题来了\",{\"1\":{\"27\":1}}],[\"那么程序的行为未定义\",{\"1\":{\"25\":1}}],[\"那么就都不存在问题\",{\"1\":{\"68\":1}}],[\"那么就可以启动新线程计算\",{\"1\":{\"52\":1}}],[\"那么就是线程对象放弃了对线程资源的所有权\",{\"1\":{\"12\":1}}],[\"那么就当做有关联活跃线程\",{\"1\":{\"9\":1}}],[\"那么回到我们最初的\",{\"1\":{\"12\":1}}],[\"那么编译器会将此语法解析为函数声明\",{\"1\":{\"12\":1}}],[\"那么\",{\"1\":{\"10\":1,\"12\":1,\"14\":1,\"37\":1,\"52\":1,\"75\":1,\"114\":1}}],[\"那么日期数字则为\",{\"1\":{\"1\":1}}],[\"那多进程呢\",{\"1\":{\"3\":1}}],[\"我知道各位肯定有疑问\",{\"1\":{\"82\":1}}],[\"我知道\",{\"1\":{\"79\":1}}],[\"我知道你会有问题\",{\"1\":{\"37\":1}}],[\"我知道你肯定有疑问\",{\"1\":{\"20\":1}}],[\"我知道你可能会想到\",{\"1\":{\"12\":1}}],[\"我知道你可能有很多疑问\",{\"1\":{\"12\":1}}],[\"我知道你或许有疑问\",{\"1\":{\"3\":1}}],[\"我再说一遍\",{\"1\":{\"76\":1}}],[\"我尽量以简单通俗的方式进行讲解\",{\"1\":{\"23\":1}}],[\"我在\",{\"1\":{\"12\":1}}],[\"我相信你可能对\",{\"1\":{\"32\":1}}],[\"我相信你也发现了\",{\"1\":{\"12\":1}}],[\"我相信本章也一定可以让你收获良多\",{\"1\":{\"23\":1}}],[\"我相信\",{\"1\":{\"12\":1,\"112\":1}}],[\"我喜欢第二种\",{\"1\":{\"6\":1}}],[\"我们会收集捐赠者进行感谢\",{\"1\":{\"119\":1}}],[\"我们给出的线程池实现简单完善且直观\",{\"1\":{\"116\":1}}],[\"我们并没有提供一个功能强大的所谓的\",{\"1\":{\"116\":1}}],[\"我们并没有举很多的例子\",{\"1\":{\"22\":1}}],[\"我们稍微介绍线程池的接口\",{\"1\":{\"116\":1}}],[\"我们实现的线程池不会是如此\",{\"1\":{\"115\":1}}],[\"我们使用了\",{\"1\":{\"116\":1}}],[\"我们使用了多线程读写\",{\"1\":{\"34\":1}}],[\"我们使用\",{\"1\":{\"99\":1}}],[\"我们知道\",{\"1\":{\"99\":1}}],[\"我们知道即可\",{\"1\":{\"76\":1}}],[\"我们以\",{\"1\":{\"97\":1,\"106\":1}}],[\"我们提供的链接基本都是较为专业的文档或官方网站\",{\"1\":{\"94\":1}}],[\"我们强调了模板\",{\"1\":{\"93\":1}}],[\"我们假设读者最低水平为\",{\"1\":{\"93\":1}}],[\"我们假设您对\",{\"1\":{\"92\":1}}],[\"我们大多数时候写多线程代码都从来没使用过内存序\",{\"1\":{\"82\":1}}],[\"我们得以确保在修改共享资源时保持操作的原子性\",{\"1\":{\"79\":1}}],[\"我们多次提到\",{\"1\":{\"79\":1}}],[\"我们无需在意\",{\"1\":{\"81\":1}}],[\"我们无需过多赘述\",{\"1\":{\"78\":1}}],[\"我们无需手动控制\",{\"1\":{\"9\":1}}],[\"我们很多时候使用原子对象只是为了简单方便\",{\"1\":{\"75\":1}}],[\"我们可能会选择其它同步机制\",{\"1\":{\"75\":1}}],[\"我们可以先来聊一聊\",{\"1\":{\"113\":1}}],[\"我们可以自己简单实现一下它\",{\"1\":{\"103\":1}}],[\"我们可以开始进入正式的学习内容了\",{\"1\":{\"96\":1}}],[\"我们可以简单的使用测试一下\",{\"1\":{\"76\":1}}],[\"我们可以尝试使用一下它\",{\"1\":{\"75\":1}}],[\"我们可以考虑以下优化策略\",{\"1\":{\"75\":1}}],[\"我们可以更放心地在性能关键的代码路径中使用它\",{\"1\":{\"75\":1}}],[\"我们可以这么做\",{\"1\":{\"53\":1}}],[\"我们可以创建一个音频资源数组\",{\"1\":{\"50\":1}}],[\"我们可以封装一个类型\",{\"1\":{\"49\":1}}],[\"我们可以通过条件变量来实现这一逻辑\",{\"1\":{\"49\":1}}],[\"我们可以通过一些简单的规则\",{\"1\":{\"30\":1}}],[\"我们可以给一个简单的示意图帮助你理解这段运行结果\",{\"1\":{\"48\":1}}],[\"我们可以写一个经典的\",{\"1\":{\"48\":1}}],[\"我们可以在构造函数中使用\",{\"1\":{\"36\":1}}],[\"我们可以使用静态断言\",{\"1\":{\"75\":1}}],[\"我们可以使用这些宏来对代码进行编译时的优化和检查\",{\"1\":{\"75\":1}}],[\"我们可以使用信号量来限制并发请求的数量\",{\"1\":{\"68\":1}}],[\"我们可以使用\",{\"1\":{\"27\":1,\"62\":1}}],[\"我们可以使用互斥量解决这个问题\",{\"1\":{\"26\":1}}],[\"我们可以使用标准库的设施\",{\"1\":{\"14\":1}}],[\"我们可以改成下面这样\",{\"1\":{\"15\":1}}],[\"我们可以打印地址来验证我们的猜想\",{\"1\":{\"14\":1}}],[\"我们可以提供一个类\",{\"1\":{\"13\":1}}],[\"我们可以举个简单的例子运用这个值\",{\"1\":{\"10\":1}}],[\"我们可以参考此值来确定创建的线程数量\",{\"1\":{\"10\":1}}],[\"我们可以轻易的创建线程执行任务\",{\"1\":{\"9\":1}}],[\"我们可以启动一个线程来做这件事情\",{\"1\":{\"9\":1}}],[\"我们可以一边走路一边说话\",{\"1\":{\"4\":1}}],[\"我们想要的是一种原子类型\",{\"1\":{\"74\":1}}],[\"我们想使用\",{\"1\":{\"12\":1}}],[\"我们讲述了使用很多同步设施\",{\"1\":{\"74\":1}}],[\"我们称作\",{\"1\":{\"71\":1}}],[\"我们这单章是为了专门解释一下\",{\"1\":{\"97\":1}}],[\"我们这段代码设置的是\",{\"1\":{\"68\":1}}],[\"我们这里的源码解析涉及到的\",{\"1\":{\"100\":1}}],[\"我们这里的设计比较简单\",{\"1\":{\"10\":1}}],[\"我们这里用一个简单的例子为你展示一下\",{\"1\":{\"79\":1}}],[\"我们这里使用到的\",{\"1\":{\"10\":1}}],[\"我们举一个简单的例子来使用一下\",{\"1\":{\"68\":1}}],[\"我们举一个例子\",{\"1\":{\"27\":1}}],[\"我们就能利用折叠表达式展开形参包并对其调用\",{\"1\":{\"103\":1}}],[\"我们就可以进行调用了\",{\"1\":{\"99\":1}}],[\"我们就直接使用了\",{\"1\":{\"66\":1}}],[\"我们就拿先前的代码改成使用\",{\"1\":{\"37\":1}}],[\"我们设置的是等待到当前时间往后\",{\"1\":{\"60\":1}}],[\"我们设计了一个名为\",{\"1\":{\"48\":1}}],[\"我们进行了一个显式的转换\",{\"1\":{\"60\":1}}],[\"我们分\",{\"1\":{\"57\":1}}],[\"我们展示了\",{\"1\":{\"55\":1}}],[\"我们写了一个简单的示例\",{\"1\":{\"75\":1}}],[\"我们写了这样一个求和函数\",{\"1\":{\"10\":1}}],[\"我们写的是\",{\"1\":{\"54\":1}}],[\"我们套了一个\",{\"1\":{\"53\":1}}],[\"我们一步一步来\",{\"1\":{\"53\":1}}],[\"我们再将第二章实现的并行\",{\"1\":{\"53\":1}}],[\"我们再介绍两个常见问题即可\",{\"1\":{\"52\":1}}],[\"我们再举个例子\",{\"1\":{\"31\":1}}],[\"我们将会在后文详细探讨\",{\"1\":{\"107\":1}}],[\"我们将传入的所有参数包装成一个元组类型\",{\"1\":{\"100\":1}}],[\"我们将更详细地讨论一些版本\",{\"1\":{\"75\":1}}],[\"我们将参数使用\",{\"1\":{\"52\":1}}],[\"我们将开始讲述同步操作\",{\"1\":{\"45\":1}}],[\"我们下面详细聊一下\",{\"1\":{\"52\":1}}],[\"我们推荐\",{\"1\":{\"50\":1}}],[\"我们引入\",{\"1\":{\"49\":1}}],[\"我们需要自定义一个类型继承并重写虚函数\",{\"1\":{\"115\":1}}],[\"我们需要强调一些基本的认识\",{\"1\":{\"81\":1}}],[\"我们需要在调用\",{\"1\":{\"53\":1}}],[\"我们需要额外启动一个线程来专门处理这个任务\",{\"1\":{\"49\":1}}],[\"我们需要使用条件变量来传递一个谓词\",{\"1\":{\"48\":1}}],[\"我们需要考虑以下两个关键点\",{\"1\":{\"48\":1}}],[\"我们介将绍一个更为复杂的示例\",{\"1\":{\"48\":1}}],[\"我们应当使用\",{\"1\":{\"37\":1}}],[\"我们直接从它的最重要\",{\"1\":{\"108\":1}}],[\"我们直接先看\",{\"1\":{\"107\":1}}],[\"我们直接改成\",{\"1\":{\"59\":1}}],[\"我们直接调用它自然不成问题\",{\"1\":{\"36\":1}}],[\"我们直接聊这个所谓的\",{\"1\":{\"21\":1}}],[\"我们也查看了\",{\"1\":{\"101\":1}}],[\"我们也没办法每一个都单独讲\",{\"1\":{\"100\":1}}],[\"我们也完全可以自定义类型创建对应的原子对象\",{\"1\":{\"75\":1}}],[\"我们也可以简单看一下\",{\"1\":{\"47\":1}}],[\"我们也可以使用\",{\"1\":{\"35\":1}}],[\"我们也不打算特别介绍什么\",{\"1\":{\"7\":1}}],[\"我们重点的强调了一下这两个成员函数的这个概念\",{\"1\":{\"35\":1}}],[\"我们不用着急就尝试实现\",{\"1\":{\"113\":1}}],[\"我们不需要在此处就详细介绍这三个类\",{\"1\":{\"107\":1}}],[\"我们不想为各位介绍其它乱七八糟的各种保护初始化的方式\",{\"1\":{\"33\":1}}],[\"我们不详细介绍他们的实现\",{\"1\":{\"14\":1}}],[\"我们通常就不会用互斥量\",{\"1\":{\"33\":1}}],[\"我们说的无非是调用\",{\"1\":{\"32\":1}}],[\"我们当然不在乎小孩抢玩具\",{\"1\":{\"30\":1}}],[\"我们传递的函数就不该是涉及外部副作用的\",{\"1\":{\"29\":1}}],[\"我们定义复制构造与复制赋值为弃置函数\",{\"1\":{\"27\":1}}],[\"我们来看看\",{\"1\":{\"99\":1}}],[\"我们来看它在\",{\"1\":{\"27\":1}}],[\"我们来使用它\",{\"1\":{\"76\":1}}],[\"我们来展示一下\",{\"1\":{\"52\":1}}],[\"我们来展示使用\",{\"1\":{\"52\":1}}],[\"我们来解释一下这个概念\",{\"1\":{\"71\":1}}],[\"我们来解释一下\",{\"1\":{\"14\":1}}],[\"我们本章\",{\"1\":{\"24\":1}}],[\"我们本节的难点只在于使用到了一些\",{\"1\":{\"22\":1}}],[\"我们对于线程的基本使用和管理\",{\"1\":{\"24\":1}}],[\"我们觉得这一个小例子所牵扯到的内容也就足够了\",{\"1\":{\"22\":1}}],[\"我们存储一个\",{\"1\":{\"18\":1}}],[\"我们用一个非常简单直观的示例为你展示\",{\"1\":{\"71\":1}}],[\"我们用一个简单的示例为你展示\",{\"1\":{\"12\":1,\"38\":1}}],[\"我们用\",{\"1\":{\"27\":1}}],[\"我们用源码实现为各位从头讲解\",{\"1\":{\"17\":1}}],[\"我们上一个大节讲解了线程管理\",{\"1\":{\"17\":1}}],[\"我们上一节的示例是传递了一个函数给\",{\"1\":{\"12\":1}}],[\"我们在讲\",{\"1\":{\"107\":1,\"108\":1}}],[\"我们在新线程中通过调用\",{\"1\":{\"54\":1}}],[\"我们在车站等车\",{\"1\":{\"51\":1}}],[\"我们在后续管理多个互斥量\",{\"1\":{\"27\":1}}],[\"我们在函数\",{\"1\":{\"16\":1}}],[\"我们在教学中可能常常为您展示部分标准库源码\",{\"1\":{\"0\":1}}],[\"我们只需要保证一开始提到的两点就行了\",{\"1\":{\"48\":1}}],[\"我们只需要介绍\",{\"1\":{\"16\":1}}],[\"我们只介绍三种\",{\"1\":{\"33\":1}}],[\"我们只是利用条件变量和互斥量\",{\"1\":{\"116\":1}}],[\"我们只是稍微的讲一下使用\",{\"1\":{\"76\":1}}],[\"我们只是告诉各位可能的情况\",{\"1\":{\"29\":1}}],[\"我们只是确保函数\",{\"1\":{\"12\":1}}],[\"我们后续会经常看到这些函数的使用\",{\"1\":{\"15\":1}}],[\"我们延时\",{\"1\":{\"15\":1}}],[\"我们要注意第三章中关于共享数据的一句话\",{\"1\":{\"79\":1}}],[\"我们要了解\",{\"1\":{\"31\":1}}],[\"我们要聊的是线程对锁的竞争\",{\"1\":{\"30\":1}}],[\"我们要尽可能的让互斥量上锁的粒度小\",{\"1\":{\"27\":1}}],[\"我们要特别强调\",{\"1\":{\"14\":1}}],[\"我们要明白\",{\"1\":{\"14\":1}}],[\"我们要判断\",{\"1\":{\"13\":1}}],[\"我们还是一样的\",{\"1\":{\"101\":1}}],[\"我们还是要来先聊一下\",{\"1\":{\"57\":1}}],[\"我们还要先知道\",{\"1\":{\"31\":1}}],[\"我们还可以使用一个枚举类型来表示音频资源的索引\",{\"1\":{\"50\":1}}],[\"我们还可以使用移动赋值来转移线程资源的所有权\",{\"1\":{\"16\":1}}],[\"我们还可以使用模板函数\",{\"1\":{\"14\":1}}],[\"我们还得测试运行\",{\"1\":{\"48\":1}}],[\"我们还得处理线程运行后的异常问题\",{\"1\":{\"12\":1}}],[\"我们还得考虑一个问题\",{\"1\":{\"10\":1}}],[\"我们自然希望能引用调用方传递的参数\",{\"1\":{\"14\":1}}],[\"我们前面一直没有使用\",{\"1\":{\"52\":1}}],[\"我们前面也说了\",{\"1\":{\"32\":1}}],[\"我们前面也都写了\",{\"1\":{\"14\":1}}],[\"我们前面提到了\",{\"1\":{\"31\":1}}],[\"我们前面代码会调用构造函数\",{\"1\":{\"31\":1}}],[\"我们前面聊的很清楚了\",{\"1\":{\"12\":1}}],[\"我们才会执行\",{\"1\":{\"13\":1}}],[\"我们理所应当再次抛出\",{\"1\":{\"12\":1}}],[\"我们既然\",{\"1\":{\"12\":1}}],[\"我们聊一下\",{\"1\":{\"12\":1}}],[\"我们先编写一个最基础的线程池\",{\"1\":{\"116\":1}}],[\"我们先前已经详细介绍过了\",{\"1\":{\"108\":1}}],[\"我们先前讲的\",{\"1\":{\"51\":1}}],[\"我们先前使用的就是\",{\"1\":{\"12\":1}}],[\"我们先获取了迭代器所指向的值的类型\",{\"1\":{\"10\":1}}],[\"我们必须在线程对象的生存期结束之前\",{\"1\":{\"12\":1}}],[\"我们显然没办法直接像函数使用函数名一样\",{\"1\":{\"12\":1}}],[\"我们的线程池的\",{\"1\":{\"116\":1}}],[\"我们的线程对象都没有线程\",{\"1\":{\"12\":1}}],[\"我们的操作几乎只需创建线程池对象\",{\"1\":{\"114\":1}}],[\"我们的标准库的那些互斥量unlock\",{\"1\":{\"103\":1}}],[\"我们的教程中常常会提供\",{\"1\":{\"94\":1}}],[\"我们的教程中常包含许多外部链接\",{\"1\":{\"94\":1}}],[\"我们的代码风格较为简洁明了\",{\"1\":{\"95\":1}}],[\"我们的代码也可以在\",{\"1\":{\"50\":1}}],[\"我们的代码因为调用了\",{\"1\":{\"31\":1}}],[\"我们的代码均会测试三大编译器\",{\"1\":{\"0\":1}}],[\"我们的使用代码是多个线程执行这两个函数\",{\"1\":{\"27\":1}}],[\"我们的这段代码就可以通过编译\",{\"1\":{\"21\":1}}],[\"我们的测试代码是捕获了异常的\",{\"1\":{\"13\":1}}],[\"我们的\",{\"1\":{\"10\":1,\"12\":1,\"56\":1,\"71\":1,\"76\":1}}],[\"我们慢慢介绍\",{\"1\":{\"9\":1}}],[\"我们现在的\",{\"1\":{\"5\":1}}],[\"我们日常使用的机器\",{\"1\":{\"5\":1}}],[\"我们主要使用标准\",{\"1\":{\"3\":1}}],[\"我们希望您的编译器版本和标准尽可能的高\",{\"1\":{\"0\":1}}],[\"我们几乎是从头教学\",{\"1\":{\"0\":1}}],[\"python\",{\"1\":{\"92\":1}}],[\"ppl\",{\"1\":{\"72\":1,\"107\":1,\"110\":1}}],[\"parent\",{\"1\":{\"64\":3}}],[\"package\",{\"1\":{\"53\":1,\"72\":1}}],[\"packaged\",{\"1\":{\"53\":14,\"107\":14,\"108\":2,\"109\":1,\"116\":2}}],[\"path\",{\"1\":{\"49\":6}}],[\"psync\",{\"1\":{\"52\":2,\"107\":2}}],[\"playing\",{\"1\":{\"49\":1}}],[\"play\",{\"1\":{\"49\":1}}],[\"playmusic\",{\"1\":{\"49\":3}}],[\"player\",{\"1\":{\"49\":4}}],[\"period>>\",{\"1\":{\"59\":3}}],[\"period\",{\"1\":{\"58\":2,\"59\":2}}],[\"per\",{\"1\":{\"39\":4}}],[\"permitted\",{\"1\":{\"31\":1}}],[\"pmtx\",{\"1\":{\"31\":5,\"32\":3}}],[\"ptype>\",{\"1\":{\"107\":2}}],[\"ptype\",{\"1\":{\"107\":6}}],[\"ptr>\",{\"1\":{\"72\":1,\"79\":7}}],[\"ptr<\",{\"1\":{\"99\":1}}],[\"ptr<int>>\",{\"1\":{\"79\":3}}],[\"ptr<data>>\",{\"1\":{\"79\":1}}],[\"ptr<data>\",{\"1\":{\"79\":2}}],[\"ptr<t>\",{\"1\":{\"48\":2}}],[\"ptr<some>\",{\"1\":{\"33\":1}}],[\"ptr\",{\"1\":{\"33\":9,\"48\":1,\"51\":2,\"54\":1,\"56\":3,\"72\":3,\"79\":34,\"90\":2,\"107\":4}}],[\"ptrdiff\",{\"1\":{\"10\":1,\"53\":1,\"70\":1,\"72\":1}}],[\"pthreads\",{\"1\":{\"37\":1}}],[\"pthread\",{\"1\":{\"21\":2,\"37\":4,\"66\":1,\"76\":1}}],[\"post\",{\"1\":{\"114\":5}}],[\"posix\",{\"1\":{\"21\":1,\"37\":3,\"66\":1,\"69\":1,\"94\":1,\"100\":1}}],[\"policy\",{\"1\":{\"107\":7}}],[\"pointer\",{\"1\":{\"75\":1}}],[\"point<std\",{\"1\":{\"60\":3}}],[\"point<>\",{\"1\":{\"60\":1}}],[\"point\",{\"1\":{\"57\":1,\"58\":2,\"60\":2}}],[\"pow\",{\"1\":{\"53\":3}}],[\"pop\",{\"1\":{\"48\":20,\"49\":1,\"116\":1}}],[\"pool\",{\"1\":{\"1\":1,\"114\":19,\"115\":2,\"116\":15,\"117\":1}}],[\"push\",{\"1\":{\"27\":2,\"48\":15,\"49\":1}}],[\"put\",{\"1\":{\"15\":3,\"58\":2}}],[\"puts\",{\"1\":{\"13\":1,\"14\":2,\"52\":3,\"95\":3}}],[\"public\",{\"1\":{\"12\":1,\"13\":1,\"18\":1,\"27\":1,\"29\":2,\"34\":1,\"48\":1,\"49\":1,\"64\":2,\"76\":1,\"79\":1,\"100\":1,\"102\":3,\"107\":5,\"108\":4,\"115\":1,\"116\":1}}],[\"p\",{\"1\":{\"12\":3,\"14\":4,\"29\":3,\"36\":11,\"52\":5,\"56\":2,\"78\":10,\"107\":9}}],[\"pred\",{\"1\":{\"47\":4}}],[\"predicate\",{\"1\":{\"47\":2}}],[\"predicate>\",{\"1\":{\"47\":2}}],[\"procedure\",{\"1\":{\"99\":1}}],[\"processing\",{\"1\":{\"68\":2}}],[\"process\",{\"1\":{\"29\":4,\"32\":3}}],[\"proc\",{\"1\":{\"68\":2,\"99\":5}}],[\"progress\",{\"1\":{\"63\":2,\"64\":16}}],[\"progressbar\",{\"1\":{\"62\":2}}],[\"promie\",{\"1\":{\"107\":1}}],[\"promise<\",{\"1\":{\"107\":3,\"108\":1}}],[\"promise<std\",{\"1\":{\"56\":1}}],[\"promise<int>\",{\"1\":{\"54\":7}}],[\"promise只能移动\",{\"1\":{\"54\":1}}],[\"promiseobj\",{\"1\":{\"54\":2}}],[\"promise\",{\"1\":{\"54\":16,\"56\":1,\"72\":1,\"107\":23,\"108\":1,\"109\":1}}],[\"prom\",{\"1\":{\"54\":12}}],[\"producer\",{\"1\":{\"48\":7}}],[\"protected\",{\"1\":{\"29\":2}}],[\"priority\",{\"1\":{\"115\":4}}],[\"print\",{\"1\":{\"27\":8,\"37\":3,\"81\":2,\"114\":3,\"116\":2}}],[\"private\",{\"1\":{\"27\":1,\"30\":1,\"31\":1,\"34\":1,\"49\":1,\"64\":1,\"79\":1,\"98\":1,\"102\":2,\"107\":3,\"108\":1,\"116\":1}}],[\"pr\",{\"1\":{\"0\":1,\"96\":1,\"107\":4}}],[\"tag\",{\"1\":{\"107\":4,\"108\":1}}],[\"task2\",{\"1\":{\"116\":1}}],[\"tasks\",{\"1\":{\"53\":5,\"116\":8}}],[\"task<void\",{\"1\":{\"116\":1}}],[\"task<void>\",{\"1\":{\"107\":1,\"108\":1}}],[\"task<value\",{\"1\":{\"53\":3}}],[\"task<int\",{\"1\":{\"53\":1}}],[\"task<rettype\",{\"1\":{\"116\":1}}],[\"task<r\",{\"1\":{\"53\":2}}],[\"task<double\",{\"1\":{\"53\":3}}],[\"task\",{\"1\":{\"12\":8,\"14\":7,\"52\":7,\"53\":22,\"56\":2,\"62\":1,\"64\":2,\"72\":2,\"107\":14,\"108\":7,\"109\":1,\"114\":5,\"115\":2,\"116\":20}}],[\"tup\",{\"1\":{\"99\":5,\"100\":1}}],[\"tuple<int\",{\"1\":{\"103\":1}}],[\"tuple<std\",{\"1\":{\"102\":1}}],[\"tuple<\",{\"1\":{\"102\":1}}],[\"tuple<decay\",{\"1\":{\"99\":2,\"100\":1}}],[\"tuple>\",{\"1\":{\"99\":5,\"103\":1}}],[\"tuple\",{\"1\":{\"99\":12,\"100\":1,\"102\":1,\"103\":13}}],[\"t第\",{\"1\":{\"71\":2}}],[\"ty2\",{\"1\":{\"109\":1}}],[\"ty2>\",{\"1\":{\"109\":3}}],[\"ty是默认可构造的\",{\"1\":{\"109\":1}}],[\"ty>>\",{\"1\":{\"107\":1}}],[\"ty>\",{\"1\":{\"107\":13,\"108\":15,\"109\":1}}],[\"ty\",{\"1\":{\"55\":2,\"107\":2,\"108\":7,\"109\":5}}],[\"types\",{\"1\":{\"99\":1}}],[\"typedef\",{\"1\":{\"83\":1}}],[\"type<void>\",{\"1\":{\"107\":1}}],[\"type<\",{\"1\":{\"52\":1,\"107\":4}}],[\"typename\",{\"1\":{\"10\":1,\"18\":1,\"53\":2,\"60\":1,\"107\":2,\"116\":1}}],[\"type>>\",{\"1\":{\"53\":2}}],[\"type>\",{\"1\":{\"10\":1,\"52\":1,\"75\":7,\"107\":1}}],[\"type\",{\"1\":{\"10\":8,\"27\":1,\"52\":2,\"53\":8,\"75\":21,\"100\":2,\"102\":1,\"107\":13,\"108\":1}}],[\"tso\",{\"1\":{\"81\":1,\"85\":4,\"94\":1}}],[\"ts\",{\"1\":{\"53\":3}}],[\"tts\",{\"1\":{\"50\":1}}],[\"tlsfree\",{\"1\":{\"37\":1}}],[\"tlsgetvalue\",{\"1\":{\"37\":1}}],[\"tlssetvalue\",{\"1\":{\"37\":1}}],[\"tlsalloc\",{\"1\":{\"37\":1}}],[\"tls\",{\"1\":{\"37\":1}}],[\"t4\",{\"1\":{\"27\":2,\"52\":1}}],[\"t参数的构造函数\",{\"1\":{\"27\":1}}],[\"t3\",{\"1\":{\"25\":1,\"27\":2,\"52\":1}}],[\"t1\",{\"1\":{\"25\":1,\"27\":2,\"28\":2,\"35\":2,\"52\":1}}],[\"t<args>\",{\"1\":{\"116\":2}}],[\"t<argtypes>\",{\"1\":{\"107\":1}}],[\"t<is\",{\"1\":{\"107\":1}}],[\"t<std\",{\"1\":{\"107\":1,\"116\":2}}],[\"t<decay\",{\"1\":{\"107\":5}}],[\"t<tuple>>>\",{\"1\":{\"103\":1}}],[\"t<f>\",{\"1\":{\"116\":2}}],[\"t<fty>\",{\"1\":{\"107\":1}}],[\"t<fn>\",{\"1\":{\"99\":1}}],[\"t<forwardit>\",{\"1\":{\"10\":1,\"53\":1}}],[\"t<\",{\"1\":{\"21\":4,\"99\":7,\"100\":2,\"107\":10}}],[\"t重载决议\",{\"1\":{\"16\":1}}],[\"t2\",{\"1\":{\"16\":14,\"25\":5,\"27\":2,\"28\":2,\"30\":1,\"35\":2,\"52\":1,\"56\":2,\"116\":2}}],[\"timecriticalpriority\",{\"1\":{\"115\":1}}],[\"timeendperiod\",{\"1\":{\"60\":1}}],[\"timebeginperiod\",{\"1\":{\"60\":1}}],[\"timeout\",{\"1\":{\"59\":2,\"60\":3}}],[\"timed\",{\"1\":{\"34\":2}}],[\"time\",{\"1\":{\"15\":19,\"57\":1,\"58\":14,\"60\":6,\"68\":2}}],[\"t>\",{\"1\":{\"14\":1,\"48\":1,\"72\":1,\"116\":3}}],[\"then\",{\"1\":{\"55\":3,\"108\":4}}],[\"the\",{\"1\":{\"31\":2,\"52\":1,\"55\":5,\"76\":1,\"99\":1,\"107\":2,\"108\":12}}],[\"that\",{\"1\":{\"27\":1,\"76\":2,\"102\":1,\"108\":4}}],[\"thr\",{\"1\":{\"68\":1,\"98\":2,\"99\":17,\"114\":1,\"116\":10}}],[\"thrd\",{\"1\":{\"64\":2,\"66\":1,\"98\":6}}],[\"throws\",{\"1\":{\"108\":1}}],[\"thrown\",{\"1\":{\"108\":1}}],[\"throw\",{\"1\":{\"12\":4,\"31\":2,\"33\":1,\"54\":6,\"55\":3,\"99\":2,\"107\":6,\"108\":8,\"109\":1,\"116\":1}}],[\"threadpool\",{\"1\":{\"115\":4,\"116\":10}}],[\"thread1\",{\"1\":{\"56\":4}}],[\"thread2\",{\"1\":{\"18\":1,\"56\":4}}],[\"thread>threads\",{\"1\":{\"18\":2,\"26\":1}}],[\"thread>\",{\"1\":{\"10\":1,\"26\":1,\"53\":1,\"99\":1,\"116\":3}}],[\"threadsafe\",{\"1\":{\"48\":5}}],[\"threads\",{\"1\":{\"10\":9,\"18\":3,\"26\":5,\"53\":9,\"68\":2,\"70\":2,\"71\":7,\"114\":7,\"116\":10}}],[\"threading\",{\"1\":{\"10\":1}}],[\"thread\",{\"0\":{\"97\":1},\"1\":{\"1\":1,\"8\":2,\"9\":6,\"10\":6,\"11\":2,\"12\":35,\"13\":16,\"14\":21,\"15\":8,\"16\":26,\"17\":3,\"18\":27,\"19\":1,\"20\":6,\"21\":4,\"23\":2,\"24\":1,\"25\":5,\"26\":6,\"27\":5,\"28\":6,\"30\":2,\"35\":6,\"37\":23,\"38\":6,\"43\":2,\"47\":3,\"49\":6,\"51\":1,\"52\":11,\"53\":6,\"54\":4,\"56\":11,\"57\":2,\"60\":2,\"62\":1,\"64\":1,\"66\":2,\"68\":11,\"70\":3,\"71\":5,\"79\":13,\"97\":2,\"98\":3,\"99\":23,\"100\":4,\"101\":1,\"103\":2,\"104\":1,\"107\":4,\"109\":4,\"114\":14,\"115\":3,\"116\":10,\"117\":1}}],[\"this\",{\"1\":{\"12\":1,\"15\":7,\"16\":1,\"18\":3,\"21\":2,\"26\":2,\"27\":1,\"28\":1,\"35\":2,\"47\":3,\"48\":2,\"49\":3,\"52\":7,\"54\":1,\"55\":4,\"56\":2,\"57\":2,\"60\":2,\"62\":7,\"64\":13,\"66\":1,\"68\":3,\"70\":2,\"71\":1,\"79\":7,\"90\":1,\"95\":1,\"107\":10,\"108\":7,\"109\":2,\"114\":2,\"116\":2}}],[\"torvalds\",{\"1\":{\"76\":1}}],[\"token\",{\"1\":{\"21\":14,\"22\":1,\"23\":1}}],[\"to\",{\"1\":{\"15\":3,\"27\":7,\"58\":2,\"64\":2,\"68\":6,\"99\":4,\"107\":1}}],[\"todo\",{\"1\":{\"12\":4,\"14\":3,\"53\":2,\"56\":3,\"60\":1,\"70\":1}}],[\"total\",{\"1\":{\"10\":4,\"53\":5,\"81\":1,\"85\":2,\"94\":1}}],[\"trivially\",{\"1\":{\"75\":1}}],[\"triviallycopyable\",{\"1\":{\"75\":1}}],[\"trivial\",{\"1\":{\"75\":14}}],[\"transferred\",{\"1\":{\"99\":1}}],[\"transition\",{\"1\":{\"52\":1,\"99\":1,\"107\":2,\"108\":1,\"109\":1}}],[\"traits<forwardit>\",{\"1\":{\"10\":1}}],[\"trycatch\",{\"1\":{\"12\":1}}],[\"try\",{\"1\":{\"12\":5,\"21\":2,\"28\":3,\"31\":1,\"33\":2,\"48\":1,\"54\":4,\"55\":1,\"77\":2,\"99\":2,\"107\":3,\"109\":1}}],[\"true\",{\"1\":{\"9\":1,\"12\":1,\"28\":1,\"31\":5,\"47\":6,\"49\":1,\"52\":1,\"55\":1,\"60\":1,\"62\":1,\"64\":1,\"71\":1,\"75\":3,\"76\":6,\"77\":16,\"107\":5,\"108\":6,\"109\":1,\"116\":1}}],[\"text\",{\"1\":{\"64\":2}}],[\"test\",{\"1\":{\"14\":4,\"76\":6,\"77\":1,\"107\":2}}],[\"terminates\",{\"1\":{\"99\":1}}],[\"terminate\",{\"1\":{\"9\":2,\"13\":1}}],[\"template<\",{\"1\":{\"60\":1,\"71\":1,\"103\":1}}],[\"template<class\",{\"1\":{\"29\":1,\"47\":1,\"58\":1,\"103\":2,\"107\":1}}],[\"template<typename\",{\"1\":{\"10\":2,\"18\":1,\"48\":1,\"53\":2,\"116\":1}}],[\"template\",{\"1\":{\"0\":1,\"21\":1,\"27\":1,\"47\":1,\"52\":1,\"59\":1,\"93\":1,\"99\":6,\"102\":3,\"107\":13,\"108\":3,\"109\":1,\"115\":1}}],[\"t\",{\"1\":{\"9\":7,\"10\":6,\"12\":19,\"13\":9,\"14\":22,\"15\":10,\"16\":30,\"18\":19,\"25\":4,\"26\":2,\"27\":2,\"30\":2,\"31\":2,\"36\":5,\"37\":1,\"48\":2,\"52\":3,\"53\":10,\"54\":6,\"56\":2,\"58\":6,\"70\":1,\"75\":7,\"78\":3,\"98\":6,\"99\":4,\"100\":3,\"102\":5,\"103\":7,\"107\":8,\"108\":1,\"114\":1,\"116\":7}}],[\"自己实现一个线程池\",{\"1\":{\"117\":1}}],[\"自己手动实现一些库\",{\"1\":{\"0\":1}}],[\"自动决定线程数量\",{\"1\":{\"114\":1}}],[\"自动调用析构函数进行销毁操作\",{\"1\":{\"76\":1}}],[\"自\",{\"1\":{\"50\":1}}],[\"自旋锁的响应更快\",{\"1\":{\"76\":1}}],[\"自旋锁可以理解为一种忙等锁\",{\"1\":{\"76\":1}}],[\"自旋\",{\"1\":{\"47\":1}}],[\"自然也拥有三个不同版本\",{\"1\":{\"107\":1}}],[\"自然也不会启动线程执行任务\",{\"1\":{\"12\":1}}],[\"自然就实现了默认复制\",{\"1\":{\"100\":1}}],[\"自然就得构造对象了\",{\"1\":{\"12\":1}}],[\"自然可以传递给\",{\"1\":{\"53\":1}}],[\"自然会产生数据竞争\",{\"1\":{\"45\":1}}],[\"自然没有数据竞争\",{\"1\":{\"36\":1}}],[\"自然不会产生死锁\",{\"1\":{\"30\":1}}],[\"自然不存在数据竞争\",{\"1\":{\"27\":1}}],[\"自然不可移动不可复制\",{\"1\":{\"27\":1}}],[\"自然抛出\",{\"1\":{\"12\":1}}],[\"自然是会保有一个副本\",{\"1\":{\"14\":1}}],[\"自然是\",{\"1\":{\"1\":1}}],[\"日\",{\"1\":{\"1\":1}}],[\"日期数字\",{\"1\":{\"1\":2}}],[\"39\",{\"1\":{\"71\":1}}],[\"3999\",{\"1\":{\"59\":3}}],[\"38\",{\"1\":{\"71\":1}}],[\"37\",{\"1\":{\"71\":1}}],[\"36304\",{\"1\":{\"116\":3}}],[\"36\",{\"1\":{\"71\":1}}],[\"34\",{\"1\":{\"71\":1}}],[\"33\",{\"1\":{\"71\":1}}],[\"32\",{\"1\":{\"71\":1}}],[\"35ms\",{\"1\":{\"59\":2}}],[\"35\",{\"1\":{\"59\":1,\"71\":1}}],[\"3s\",{\"1\":{\"15\":1,\"21\":1,\"68\":2,\"70\":1}}],[\"3\",{\"1\":{\"10\":1,\"14\":3,\"15\":2,\"21\":2,\"33\":1,\"35\":1,\"39\":1,\"47\":1,\"48\":7,\"59\":4,\"68\":6,\"70\":1,\"71\":4,\"78\":1,\"79\":1,\"115\":1,\"116\":2}}],[\"31416\",{\"1\":{\"116\":1}}],[\"31\",{\"1\":{\"1\":1,\"71\":1}}],[\"300ms\",{\"1\":{\"71\":1}}],[\"30\",{\"1\":{\"0\":1,\"71\":1,\"75\":1}}],[\"月\",{\"1\":{\"1\":1}}],[\"70\",{\"1\":{\"71\":1}}],[\"79\",{\"1\":{\"71\":1}}],[\"78\",{\"1\":{\"71\":1}}],[\"77\",{\"1\":{\"71\":1}}],[\"76\",{\"1\":{\"71\":1}}],[\"75\",{\"1\":{\"71\":1}}],[\"74\",{\"1\":{\"71\":1}}],[\"73\",{\"1\":{\"71\":1}}],[\"72\",{\"1\":{\"71\":1}}],[\"71\",{\"1\":{\"71\":1}}],[\"7fff00\",{\"1\":{\"64\":1}}],[\"7\",{\"1\":{\"1\":1,\"71\":1,\"115\":1,\"116\":2}}],[\"年了\",{\"1\":{\"10\":1}}],[\"年\",{\"1\":{\"1\":1}}],[\"80\",{\"1\":{\"71\":1}}],[\"89\",{\"1\":{\"71\":1}}],[\"88\",{\"1\":{\"71\":1}}],[\"87\",{\"1\":{\"71\":1}}],[\"86\",{\"1\":{\"71\":1}}],[\"85\",{\"1\":{\"71\":1}}],[\"84\",{\"1\":{\"71\":1}}],[\"83\",{\"1\":{\"71\":1}}],[\"82\",{\"1\":{\"71\":1}}],[\"81\",{\"1\":{\"71\":1}}],[\"8\",{\"1\":{\"1\":1,\"10\":5,\"20\":3,\"71\":1,\"98\":1,\"100\":2,\"116\":2}}],[\"image\",{\"0\":{\"121\":1}}],[\"immediate\",{\"1\":{\"107\":10,\"108\":4,\"109\":3}}],[\"impl\",{\"1\":{\"20\":1,\"21\":4,\"103\":2}}],[\"it\",{\"1\":{\"34\":3,\"107\":1}}],[\"iterator\",{\"1\":{\"10\":1}}],[\"iter\",{\"1\":{\"10\":2,\"53\":1}}],[\"iota\",{\"1\":{\"27\":1}}],[\"issue\",{\"1\":{\"96\":1}}],[\"issues\",{\"1\":{\"0\":1}}],[\"isdone\",{\"1\":{\"15\":1}}],[\"is\",{\"1\":{\"13\":1,\"21\":2,\"58\":1,\"71\":1,\"75\":12,\"76\":1,\"99\":2,\"107\":3,\"108\":5,\"109\":2,\"114\":1,\"116\":11}}],[\"i\",{\"1\":{\"10\":9,\"12\":8,\"18\":6,\"26\":4,\"27\":4,\"48\":5,\"53\":11,\"62\":4,\"64\":4,\"68\":3,\"70\":3,\"71\":14,\"76\":1,\"79\":10,\"114\":9,\"115\":3,\"116\":8}}],[\"ifdef\",{\"1\":{\"100\":1}}],[\"if\",{\"1\":{\"10\":1,\"13\":1,\"18\":2,\"21\":3,\"28\":1,\"30\":3,\"31\":6,\"33\":2,\"35\":2,\"49\":3,\"53\":1,\"59\":2,\"60\":1,\"71\":1,\"75\":3,\"77\":2,\"79\":2,\"81\":1,\"99\":5,\"107\":6,\"108\":8,\"109\":2,\"115\":1,\"116\":3}}],[\"i7\",{\"1\":{\"10\":1}}],[\"inheritpriority\",{\"1\":{\"115\":1}}],[\"inside\",{\"1\":{\"109\":1}}],[\"install\",{\"1\":{\"50\":2}}],[\"instance\",{\"1\":{\"33\":5}}],[\"invalidates\",{\"1\":{\"108\":1}}],[\"invoke<\",{\"1\":{\"99\":3}}],[\"invoker\",{\"1\":{\"99\":5}}],[\"invoke\",{\"1\":{\"97\":1,\"99\":13,\"100\":4,\"103\":2,\"106\":1,\"107\":11,\"116\":2}}],[\"invokemethod\",{\"1\":{\"62\":5,\"64\":5,\"65\":1}}],[\"invocable<std\",{\"1\":{\"53\":1}}],[\"invocable\",{\"1\":{\"21\":1,\"71\":1}}],[\"incorrectly\",{\"1\":{\"109\":1}}],[\"incomplete\",{\"1\":{\"99\":1}}],[\"include\",{\"1\":{\"9\":3,\"10\":2,\"12\":4,\"26\":1,\"35\":3,\"52\":3,\"95\":2,\"114\":2,\"115\":4,\"116\":10}}],[\"indices\",{\"1\":{\"99\":3}}],[\"indices>\",{\"1\":{\"99\":4,\"100\":1}}],[\"index>\",{\"1\":{\"103\":1}}],[\"index\",{\"1\":{\"99\":5,\"103\":4}}],[\"information\",{\"1\":{\"64\":3}}],[\"in\",{\"1\":{\"52\":1,\"76\":1,\"107\":1,\"108\":1}}],[\"inline\",{\"1\":{\"33\":1,\"83\":6,\"114\":1,\"116\":1}}],[\"init\",{\"1\":{\"33\":2,\"76\":6}}],[\"initializationsuccessful\",{\"1\":{\"50\":1}}],[\"initializationfailed\",{\"1\":{\"50\":1}}],[\"initialization\",{\"1\":{\"13\":1}}],[\"int>\",{\"1\":{\"14\":1,\"21\":1,\"75\":1,\"99\":2}}],[\"int\",{\"1\":{\"9\":2,\"10\":2,\"12\":16,\"13\":1,\"14\":24,\"15\":4,\"16\":4,\"18\":3,\"21\":2,\"25\":3,\"26\":2,\"27\":2,\"28\":1,\"29\":1,\"31\":2,\"33\":2,\"35\":3,\"36\":2,\"37\":5,\"38\":2,\"48\":3,\"52\":17,\"53\":18,\"54\":5,\"56\":5,\"62\":1,\"64\":1,\"66\":1,\"68\":6,\"70\":4,\"71\":10,\"74\":1,\"75\":11,\"79\":10,\"95\":2,\"98\":2,\"99\":1,\"100\":1,\"107\":3,\"114\":4,\"115\":5,\"116\":7}}],[\"idlepriority\",{\"1\":{\"115\":1}}],[\"identifier\",{\"1\":{\"98\":1}}],[\"id打印主线程和子线程的\",{\"1\":{\"15\":1}}],[\"id\",{\"1\":{\"1\":2,\"15\":6,\"16\":1,\"18\":7,\"26\":2,\"27\":1,\"28\":4,\"35\":2,\"52\":7,\"64\":4,\"65\":1,\"66\":3,\"68\":2,\"70\":3,\"71\":5,\"79\":2,\"98\":5,\"99\":5,\"100\":1,\"114\":1,\"115\":1}}],[\"白老师一天的食品安全就有了着落\",{\"1\":{\"0\":1}}],[\"激励白老师有更多的精力和信心维护本仓库\",{\"1\":{\"0\":1}}],[\"猫猫虫\",{\"1\":{\"0\":1}}],[\"++\",{\"1\":{\"75\":1}}],[\"++a\",{\"1\":{\"74\":4}}],[\"++n\",{\"1\":{\"30\":2,\"33\":1,\"38\":1}}],[\"++i\",{\"1\":{\"10\":1,\"12\":1,\"18\":2,\"26\":2,\"48\":2,\"53\":2,\"62\":1,\"64\":1,\"68\":1,\"70\":1,\"71\":4,\"79\":4,\"114\":2,\"115\":1,\"116\":3}}],[\"+=\",{\"1\":{\"12\":1,\"36\":1,\"53\":1,\"75\":1,\"116\":1}}],[\"+\",{\"1\":{\"0\":2,\"1\":1,\"10\":2,\"15\":1,\"20\":1,\"27\":1,\"48\":66,\"53\":3,\"60\":2,\"63\":1,\"70\":1,\"71\":2,\"72\":1,\"93\":2,\"94\":1,\"99\":3,\"103\":1,\"107\":12,\"108\":12}}],[\"本单章专门介绍标准库在\",{\"1\":{\"101\":1}}],[\"本教程长期维护\",{\"1\":{\"96\":1}}],[\"本教程在中文社区的同类型教程中是绝对的第一\",{\"1\":{\"93\":1}}],[\"本教程不保证你学习之后的成果\",{\"1\":{\"93\":1}}],[\"本教程假设开发者的最低水平为\",{\"1\":{\"0\":1}}],[\"本套教程侧重点在于使用\",{\"1\":{\"93\":1}}],[\"本身有三个特化\",{\"1\":{\"108\":1}}],[\"本身在多线程的支持了\",{\"1\":{\"79\":1}}],[\"本身的值\",{\"1\":{\"79\":1}}],[\"本身不是原子操作\",{\"1\":{\"74\":1}}],[\"本身是重载了\",{\"1\":{\"53\":1}}],[\"本身就是右值表达式\",{\"1\":{\"16\":1}}],[\"本身就是生成了一个函数对象\",{\"1\":{\"12\":1}}],[\"本身设置使用很简单\",{\"1\":{\"15\":1}}],[\"本节主要广泛介绍\",{\"1\":{\"75\":1}}],[\"本节内容也不会对你构成难度\",{\"1\":{\"71\":1}}],[\"本节内容总体来说是很简单的\",{\"1\":{\"16\":1}}],[\"本节是偏向概念的认识\",{\"1\":{\"39\":1}}],[\"本节代码只是为了学习\",{\"1\":{\"10\":1}}],[\"本节其实是要普及一下计算机常识\",{\"1\":{\"10\":1}}],[\"本章讨论了多种用于同步操作的工具\",{\"1\":{\"72\":1}}],[\"本章讨论了多线程的共享数据引发的恶性条件竞争会带来的问题\",{\"1\":{\"45\":1}}],[\"本章将讨论如何使用条件变量等待事件\",{\"1\":{\"46\":1}}],[\"本章的主要内容有\",{\"1\":{\"46\":1}}],[\"本章的内容在市面上并不算少见\",{\"1\":{\"23\":1}}],[\"本章也完全不用担心\",{\"1\":{\"24\":1}}],[\"本章节主要内容\",{\"1\":{\"24\":1}}],[\"本章节的内容围绕着\",{\"1\":{\"23\":1}}],[\"本章围绕着它们来讲解\",{\"1\":{\"8\":1}}],[\"本章中\",{\"1\":{\"8\":1}}],[\"本仓库用来存放\",{\"1\":{\"0\":1}}],[\"准确的方式进行教学\",{\"1\":{\"0\":1}}],[\"不存在这个问题\",{\"1\":{\"116\":1}}],[\"不存在一个对象同时被多个线程修改\",{\"1\":{\"27\":1}}],[\"不区分\",{\"1\":{\"110\":1}}],[\"不获取返回值\",{\"1\":{\"107\":1}}],[\"不获得互斥体的所有权\",{\"1\":{\"31\":1}}],[\"不为空\",{\"1\":{\"99\":1}}],[\"不导致编译错误\",{\"1\":{\"99\":1}}],[\"不使用构造函数\",{\"1\":{\"90\":1}}],[\"不禁止就是有可能\",{\"1\":{\"81\":1}}],[\"不相等\",{\"1\":{\"77\":1}}],[\"不需要模板的水平有多高\",{\"1\":{\"93\":1,\"100\":1}}],[\"不需要额外的同步设施进行保护\",{\"1\":{\"74\":1}}],[\"不需要进行同步操作\",{\"1\":{\"39\":1}}],[\"不影响之后重置计数\",{\"1\":{\"71\":1}}],[\"不少情况很多同步设施都能完成你的需求\",{\"1\":{\"70\":1}}],[\"不少开发者喜欢直接将声明为线程存储期的对象称为\",{\"1\":{\"37\":1}}],[\"不在乎其返回类型只用来实施它的副作用\",{\"1\":{\"103\":1}}],[\"不在\",{\"1\":{\"64\":1}}],[\"不管如何减少计数\",{\"1\":{\"71\":1}}],[\"不管使用哪种时钟获取时间\",{\"1\":{\"58\":1}}],[\"不管是\",{\"1\":{\"100\":1}}],[\"不管是使用上还是概念上\",{\"1\":{\"92\":1}}],[\"不管是书籍\",{\"1\":{\"0\":1}}],[\"不管是否购买课程\",{\"1\":{\"0\":1}}],[\"不然就会抛出异常\",{\"1\":{\"54\":1}}],[\"不然保护将形同虚设\",{\"1\":{\"29\":1,\"79\":1}}],[\"不能被拷贝和移动\",{\"1\":{\"78\":1}}],[\"不能再次调用\",{\"1\":{\"55\":1}}],[\"不能复制\",{\"1\":{\"53\":1}}],[\"不能调用\",{\"1\":{\"52\":1}}],[\"不阻塞\",{\"1\":{\"53\":1}}],[\"不确定的\",{\"1\":{\"57\":1}}],[\"不确定\",{\"1\":{\"52\":1}}],[\"不给出执行策略就是以\",{\"1\":{\"52\":1}}],[\"不创建线程\",{\"1\":{\"52\":2,\"59\":1}}],[\"不知道去哪生成这些语音播报\",{\"1\":{\"50\":1}}],[\"不仅有效减少了\",{\"1\":{\"49\":1}}],[\"不执行\",{\"1\":{\"48\":1}}],[\"不应该执行\",{\"1\":{\"48\":1}}],[\"不考虑非标准用法\",{\"1\":{\"43\":1}}],[\"不考虑静态局部\",{\"0\":{\"41\":1}}],[\"不包括用户定义的\",{\"1\":{\"36\":1}}],[\"不要在用户空间中使用自旋锁\",{\"1\":{\"76\":1}}],[\"不要\",{\"1\":{\"33\":1}}],[\"不再表示执行线程失去了线程的所有权\",{\"1\":{\"99\":1}}],[\"不再拥有共享状态\",{\"1\":{\"55\":1}}],[\"不再强调\",{\"1\":{\"32\":1}}],[\"不再管理此线程\",{\"1\":{\"12\":1}}],[\"不同架构的内存模型\",{\"1\":{\"94\":1}}],[\"不同的指令集架构大多都还是有所不同的\",{\"1\":{\"85\":1}}],[\"不同的变量有不同的使用场景和特点\",{\"1\":{\"40\":1}}],[\"不同于通常情况\",{\"1\":{\"77\":1}}],[\"不同于\",{\"1\":{\"68\":1}}],[\"不同线程对同一个互斥量进行锁定时\",{\"1\":{\"35\":1}}],[\"不同\",{\"1\":{\"28\":1,\"115\":2}}],[\"不会等待所有任务执行完毕\",{\"1\":{\"116\":1}}],[\"不会对\",{\"1\":{\"112\":1}}],[\"不会造成任何额外开销\",{\"1\":{\"102\":1}}],[\"不会模板\",{\"1\":{\"100\":1,\"101\":1,\"104\":1}}],[\"不会单独使用或直接面向普通开发者\",{\"1\":{\"76\":1}}],[\"不会阻塞\",{\"1\":{\"62\":1}}],[\"不会被其它线程的执行所打断\",{\"1\":{\"26\":1}}],[\"不会被打断\",{\"1\":{\"25\":1,\"71\":1}}],[\"不会有任何其他的线程打断这个操作\",{\"1\":{\"26\":1}}],[\"不是可调用类型\",{\"1\":{\"99\":1}}],[\"不是定序约束\",{\"1\":{\"83\":1}}],[\"不是同一个\",{\"1\":{\"27\":1}}],[\"不是线程安全的容器\",{\"1\":{\"25\":1}}],[\"不是真的返回引用\",{\"1\":{\"14\":1}}],[\"不完全支持\",{\"1\":{\"21\":1}}],[\"不直接为\",{\"1\":{\"20\":1}}],[\"不可表示一个线程\",{\"1\":{\"99\":1}}],[\"不可能观察到原子操作完成了一半\",{\"1\":{\"73\":1}}],[\"不可能达到纳秒级别\",{\"1\":{\"60\":1}}],[\"不可能看到正在被add\",{\"1\":{\"27\":1}}],[\"不可能每一个任务都单独给一个核心\",{\"1\":{\"5\":1}}],[\"不可复制不可移动\",{\"1\":{\"32\":1}}],[\"不可复制\",{\"1\":{\"16\":1,\"54\":1,\"99\":1}}],[\"不用感到奇怪\",{\"1\":{\"90\":1,\"106\":1}}],[\"不用感到难以理解\",{\"1\":{\"71\":1}}],[\"不用赘述\",{\"1\":{\"21\":1}}],[\"不用调用\",{\"1\":{\"16\":1}}],[\"不用着急\",{\"1\":{\"15\":1,\"16\":1,\"76\":1}}],[\"不用担心数据竞争\",{\"1\":{\"33\":1}}],[\"不用担心生存期的问题\",{\"1\":{\"14\":1}}],[\"不用担心\",{\"1\":{\"14\":1,\"101\":1}}],[\"不用在乎\",{\"1\":{\"13\":1}}],[\"不用在意\",{\"1\":{\"3\":1}}],[\"不允许这些操作主要在于\",{\"1\":{\"13\":1}}],[\"不掩盖错误\",{\"1\":{\"12\":1}}],[\"不等待线程结束\",{\"1\":{\"12\":1}}],[\"不过总体并无多大区别\",{\"1\":{\"108\":1}}],[\"不过整体大差不差\",{\"1\":{\"108\":1}}],[\"不过可以推测\",{\"1\":{\"107\":1}}],[\"不过可以隐式转换成对应的内置类型\",{\"1\":{\"75\":1}}],[\"不过你可能有疑问\",{\"1\":{\"103\":1}}],[\"不过实测\",{\"1\":{\"100\":1}}],[\"不过实践中这种情况较少\",{\"1\":{\"45\":1}}],[\"不过依然可以自信地说\",{\"1\":{\"93\":1}}],[\"不过也都没什么特别的了\",{\"1\":{\"115\":1}}],[\"不过也可以自己创建\",{\"1\":{\"115\":1}}],[\"不过也可以单独使用\",{\"1\":{\"53\":1}}],[\"不过也有一些不错的\",{\"1\":{\"92\":1}}],[\"不过事实上\",{\"1\":{\"79\":1}}],[\"不过并不推荐各位在实践中使用它\",{\"1\":{\"76\":1}}],[\"不过其实我们的\",{\"1\":{\"75\":1}}],[\"不过因为是通用模板\",{\"1\":{\"75\":1}}],[\"不过不用在意\",{\"1\":{\"70\":1}}],[\"不过不影响\",{\"1\":{\"56\":1}}],[\"不过我们在最后循环遍历了\",{\"1\":{\"116\":1}}],[\"不过我们也可以使用系统\",{\"1\":{\"60\":1}}],[\"不过我们说了\",{\"1\":{\"10\":1}}],[\"不过这并不完全算是好事\",{\"1\":{\"92\":1}}],[\"不过这个\",{\"1\":{\"77\":1}}],[\"不过这个重载的返回类型是\",{\"1\":{\"53\":1}}],[\"不过这显然不是我们的重点\",{\"1\":{\"74\":1}}],[\"不过这不是我们的重点\",{\"1\":{\"72\":1}}],[\"不过这也不是问题\",{\"1\":{\"16\":1}}],[\"不过引用的并非是局部的n\",{\"1\":{\"52\":1}}],[\"不过引用的不是我们传递的局部对象\",{\"1\":{\"52\":1}}],[\"不过新版本的\",{\"1\":{\"50\":1}}],[\"不过还是可以注意一下这个问题\",{\"1\":{\"38\":1}}],[\"不过对于处理一个互斥量的情况\",{\"1\":{\"27\":1}}],[\"不过一般不推荐这样显式的\",{\"1\":{\"27\":1}}],[\"不过在\",{\"1\":{\"21\":1}}],[\"不过需要注意\",{\"1\":{\"14\":1}}],[\"不过有件事情需要注意\",{\"1\":{\"12\":1}}],[\"不过使用类似\",{\"1\":{\"10\":1}}],[\"不过\",{\"1\":{\"9\":1,\"37\":1,\"51\":1,\"71\":1,\"75\":1,\"85\":1,\"116\":1}}],[\"不够准确\",{\"1\":{\"0\":1}}],[\"视频\",{\"1\":{\"0\":1}}],[\"博客\",{\"1\":{\"0\":1}}],[\"国内的\",{\"1\":{\"0\":1}}],[\"捐赠\",{\"1\":{\"0\":1}}],[\"000000\",{\"1\":{\"64\":1}}],[\"01\",{\"1\":{\"57\":1}}],[\"01初始化失败\",{\"1\":{\"50\":1}}],[\"07t12\",{\"1\":{\"57\":1}}],[\"07废料箱即将装满\",{\"1\":{\"50\":1}}],[\"05\",{\"1\":{\"57\":1}}],[\"05清洗液不足\",{\"1\":{\"50\":1}}],[\"09激发液b液不足\",{\"1\":{\"50\":1}}],[\"08激发液a液不足\",{\"1\":{\"50\":1}}],[\"06废液桶即将装满\",{\"1\":{\"50\":1}}],[\"04试剂已失效\",{\"1\":{\"50\":1}}],[\"03试剂不足\",{\"1\":{\"50\":1}}],[\"02初始化成功\",{\"1\":{\"50\":1}}],[\"0>\",{\"1\":{\"21\":1,\"99\":2}}],[\"0\",{\"1\":{\"0\":1,\"10\":5,\"12\":4,\"13\":1,\"14\":4,\"16\":2,\"18\":2,\"25\":2,\"26\":2,\"27\":3,\"33\":1,\"35\":2,\"37\":7,\"38\":1,\"48\":7,\"49\":1,\"52\":2,\"53\":3,\"54\":1,\"62\":2,\"64\":5,\"68\":10,\"70\":4,\"71\":2,\"72\":1,\"74\":1,\"75\":1,\"76\":2,\"79\":5,\"95\":2,\"99\":7,\"108\":1,\"114\":5,\"115\":3,\"116\":7}}],[\"404\",{\"1\":{\"120\":1}}],[\"40\",{\"1\":{\"71\":1,\"75\":1}}],[\"400>\",{\"1\":{\"59\":1}}],[\"49\",{\"1\":{\"71\":1}}],[\"48\",{\"1\":{\"71\":1}}],[\"47\",{\"1\":{\"71\":1}}],[\"46\",{\"1\":{\"71\":1}}],[\"45\",{\"1\":{\"71\":1}}],[\"44\",{\"1\":{\"71\":1}}],[\"43\",{\"1\":{\"71\":1}}],[\"42\",{\"1\":{\"71\":1}}],[\"41\",{\"1\":{\"71\":1}}],[\"4\",{\"1\":{\"0\":1,\"10\":1,\"27\":1,\"33\":1,\"43\":1,\"48\":7,\"68\":1,\"71\":9,\"98\":1,\"108\":1,\"114\":4,\"115\":1,\"116\":6}}],[\"n4950\",{\"1\":{\"108\":2}}],[\"nil\",{\"1\":{\"76\":1}}],[\"n++\",{\"1\":{\"71\":2}}],[\"native\",{\"1\":{\"100\":2}}],[\"nanosecond\",{\"1\":{\"59\":1}}],[\"nanoseconds\",{\"1\":{\"59\":1,\"60\":2}}],[\"nano>\",{\"1\":{\"59\":1}}],[\"namespace\",{\"1\":{\"15\":1,\"21\":1,\"59\":1,\"60\":1}}],[\"new\",{\"1\":{\"32\":1,\"33\":3,\"36\":14,\"45\":2,\"48\":3,\"52\":3,\"64\":4,\"75\":2,\"77\":2,\"79\":6,\"107\":3,\"109\":1,\"114\":1,\"115\":1}}],[\"next\",{\"1\":{\"10\":2,\"53\":1}}],[\"nullptr\",{\"1\":{\"29\":1,\"31\":1,\"32\":1,\"36\":1,\"64\":4,\"99\":2,\"107\":1}}],[\"numbers\",{\"1\":{\"27\":6}}],[\"num\",{\"1\":{\"10\":6,\"53\":6,\"54\":6,\"114\":7,\"116\":12}}],[\"normalpriority\",{\"1\":{\"115\":3}}],[\"non\",{\"1\":{\"108\":1}}],[\"no\",{\"1\":{\"55\":1,\"107\":6,\"108\":2}}],[\"note\",{\"1\":{\"99\":2}}],[\"nothrow\",{\"1\":{\"71\":1}}],[\"notify\",{\"1\":{\"47\":3,\"48\":1,\"49\":2,\"79\":3,\"109\":1,\"116\":2}}],[\"not\",{\"1\":{\"31\":1,\"76\":1,\"108\":1,\"120\":1}}],[\"nodiscard\",{\"1\":{\"21\":1,\"27\":1,\"32\":1,\"99\":2,\"102\":2,\"107\":4,\"108\":1}}],[\"now2\",{\"1\":{\"58\":1}}],[\"now\",{\"1\":{\"15\":11,\"58\":12,\"60\":5,\"107\":1}}],[\"noexcept\",{\"1\":{\"14\":1,\"18\":9,\"21\":1,\"27\":2,\"31\":2,\"32\":1,\"47\":1,\"52\":2,\"71\":5,\"75\":1,\"76\":3,\"95\":2,\"99\":5,\"102\":5,\"103\":2,\"107\":7,\"108\":3,\"116\":1}}],[\"n\",{\"1\":{\"10\":3,\"12\":15,\"13\":2,\"14\":33,\"15\":2,\"16\":5,\"18\":3,\"25\":3,\"26\":2,\"27\":5,\"30\":1,\"33\":3,\"36\":2,\"37\":2,\"38\":7,\"45\":1,\"52\":26,\"53\":3,\"54\":5,\"55\":3,\"56\":1,\"58\":2,\"59\":3,\"60\":2,\"68\":7,\"70\":6,\"71\":6,\"76\":1,\"77\":2,\"79\":2,\"95\":1,\"114\":3,\"116\":9}}],[\"nd\",{\"1\":{\"0\":1}}],[\"nc\",{\"1\":{\"0\":1}}],[\"c2280\",{\"1\":{\"99\":1}}],[\"cisc\",{\"1\":{\"85\":1}}],[\"cstd\",{\"1\":{\"99\":2}}],[\"cst\",{\"1\":{\"75\":3,\"76\":2,\"83\":5}}],[\"csapp\",{\"1\":{\"10\":1}}],[\"centralwidget\",{\"1\":{\"64\":1}}],[\"center\",{\"1\":{\"64\":2}}],[\"cerr\",{\"1\":{\"49\":1,\"54\":2,\"55\":1}}],[\"cmake\",{\"1\":{\"63\":1,\"72\":1,\"94\":1}}],[\"cxx20\",{\"1\":{\"59\":1}}],[\"cnd\",{\"1\":{\"47\":1,\"99\":1}}],[\"cnt++\",{\"1\":{\"25\":1}}],[\"cnt\",{\"1\":{\"25\":1}}],[\"cv\",{\"1\":{\"47\":8,\"60\":3,\"99\":1,\"100\":1,\"116\":6}}],[\"cvref\",{\"1\":{\"21\":1,\"99\":2}}],[\"createthread\",{\"1\":{\"100\":3}}],[\"create\",{\"1\":{\"37\":1,\"52\":2,\"100\":1,\"107\":3,\"115\":1}}],[\"cref\",{\"1\":{\"14\":3,\"27\":2}}],[\"ctor\",{\"1\":{\"21\":1,\"32\":1,\"99\":1}}],[\"current\",{\"1\":{\"15\":1,\"54\":3,\"58\":2,\"107\":3,\"109\":1}}],[\"clear\",{\"1\":{\"76\":4,\"77\":1,\"116\":1}}],[\"cleaningagentinsufficient\",{\"1\":{\"50\":1}}],[\"clicked\",{\"1\":{\"64\":2}}],[\"clock>\",{\"1\":{\"60\":2}}],[\"clock\",{\"1\":{\"15\":5,\"57\":1,\"58\":9,\"60\":8}}],[\"class\",{\"1\":{\"12\":1,\"13\":1,\"18\":1,\"21\":1,\"27\":2,\"29\":2,\"33\":6,\"34\":1,\"48\":1,\"49\":1,\"52\":1,\"58\":2,\"59\":2,\"60\":3,\"64\":1,\"71\":2,\"76\":1,\"79\":1,\"83\":1,\"99\":4,\"100\":1,\"102\":4,\"103\":4,\"107\":9,\"108\":4,\"116\":2}}],[\"clang18\",{\"1\":{\"94\":1}}],[\"clang19\",{\"1\":{\"21\":1,\"92\":1}}],[\"clang\",{\"1\":{\"0\":1,\"21\":1,\"37\":2,\"38\":2,\"71\":1,\"94\":2}}],[\"check\",{\"1\":{\"31\":1}}],[\"chrono\",{\"1\":{\"15\":10,\"21\":1,\"28\":1,\"47\":3,\"52\":1,\"54\":1,\"56\":2,\"57\":1,\"58\":9,\"59\":16,\"60\":21,\"68\":1}}],[\"char>\",{\"1\":{\"75\":2,\"103\":1}}],[\"char8\",{\"1\":{\"75\":1}}],[\"char32\",{\"1\":{\"75\":1}}],[\"char16\",{\"1\":{\"75\":1}}],[\"char\",{\"1\":{\"14\":5,\"75\":2,\"95\":1,\"115\":1}}],[\"chunk\",{\"1\":{\"10\":5,\"53\":2,\"64\":1}}],[\"c\",{\"1\":{\"14\":1,\"64\":2,\"74\":2,\"100\":4,\"103\":1}}],[\"cast\",{\"1\":{\"59\":1}}],[\"cast<long>\",{\"1\":{\"114\":1}}],[\"cast<\",{\"1\":{\"99\":1}}],[\"cast<void\",{\"1\":{\"99\":2,\"109\":1}}],[\"cast<std\",{\"1\":{\"59\":2,\"60\":1}}],[\"cast<>\",{\"1\":{\"59\":1}}],[\"case\",{\"1\":{\"52\":2,\"107\":2}}],[\"calculate\",{\"1\":{\"54\":2}}],[\"calloc\",{\"1\":{\"36\":1}}],[\"call\",{\"1\":{\"33\":9,\"45\":1,\"107\":11,\"108\":4,\"109\":3}}],[\"callable<callable>>\",{\"1\":{\"115\":1}}],[\"callable\",{\"1\":{\"9\":1,\"12\":1,\"14\":1,\"18\":2,\"33\":1,\"52\":2,\"53\":2,\"99\":1,\"103\":5,\"107\":4,\"115\":3}}],[\"can\",{\"1\":{\"31\":1}}],[\"cancel\",{\"1\":{\"21\":4}}],[\"catch\",{\"1\":{\"12\":6,\"33\":2,\"54\":4,\"55\":1,\"107\":6,\"109\":2}}],[\"copied\",{\"1\":{\"99\":7}}],[\"copyable\",{\"1\":{\"108\":1}}],[\"copyable<trivial\",{\"1\":{\"75\":1}}],[\"copyassignable\",{\"1\":{\"75\":1}}],[\"copyconstructible\",{\"1\":{\"75\":1}}],[\"copy\",{\"1\":{\"14\":1,\"75\":2,\"107\":2}}],[\"co\",{\"1\":{\"92\":3}}],[\"complier\",{\"1\":{\"94\":1}}],[\"completion\",{\"1\":{\"71\":1}}],[\"completionfunction\",{\"1\":{\"71\":2}}],[\"compare\",{\"1\":{\"75\":4,\"77\":12,\"78\":2}}],[\"color\",{\"1\":{\"64\":3}}],[\"counting\",{\"1\":{\"68\":7}}],[\"counter++\",{\"1\":{\"37\":2}}],[\"counters\",{\"1\":{\"37\":3}}],[\"counter\",{\"1\":{\"37\":5}}],[\"count\",{\"1\":{\"35\":10,\"36\":2,\"59\":3,\"60\":1,\"70\":4}}],[\"cout\",{\"1\":{\"9\":2,\"10\":1,\"12\":2,\"14\":6,\"15\":5,\"16\":5,\"18\":3,\"21\":2,\"25\":4,\"26\":3,\"27\":3,\"28\":3,\"33\":1,\"35\":2,\"36\":1,\"37\":2,\"38\":4,\"47\":1,\"48\":2,\"52\":11,\"53\":3,\"54\":4,\"55\":2,\"56\":9,\"58\":2,\"59\":3,\"60\":2,\"68\":7,\"70\":5,\"71\":7,\"75\":8,\"76\":1,\"77\":2,\"79\":6,\"103\":1,\"114\":1,\"116\":3}}],[\"code\",{\"1\":{\"14\":3,\"27\":2,\"31\":2,\"63\":1}}],[\"connect\",{\"1\":{\"57\":1,\"64\":2}}],[\"continue\",{\"1\":{\"49\":1}}],[\"consume\",{\"1\":{\"75\":2,\"83\":4}}],[\"consumer\",{\"1\":{\"48\":7}}],[\"constructible\",{\"1\":{\"107\":1,\"108\":1,\"109\":2}}],[\"constructible<trivial\",{\"1\":{\"75\":2}}],[\"construct\",{\"1\":{\"27\":2,\"31\":1,\"52\":1,\"102\":4,\"103\":2,\"107\":1}}],[\"constexpr\",{\"1\":{\"21\":1,\"50\":1,\"75\":3,\"83\":6,\"99\":3,\"103\":3,\"108\":1,\"109\":1}}],[\"const\",{\"1\":{\"12\":3,\"13\":2,\"14\":15,\"18\":4,\"27\":4,\"30\":1,\"31\":1,\"34\":4,\"48\":1,\"49\":1,\"52\":5,\"60\":1,\"72\":1,\"75\":5,\"79\":6,\"90\":1,\"95\":1,\"99\":5,\"102\":6,\"103\":1,\"107\":9,\"108\":5,\"109\":2,\"116\":4}}],[\"cond\",{\"1\":{\"48\":4,\"49\":4,\"107\":1,\"108\":3}}],[\"conditional\",{\"1\":{\"107\":1}}],[\"condition\",{\"1\":{\"47\":11,\"48\":1,\"49\":1,\"57\":1,\"60\":1,\"107\":1,\"116\":3}}],[\"concurrency\",{\"1\":{\"10\":5,\"52\":1,\"53\":1,\"107\":3,\"108\":1,\"114\":3,\"116\":1}}],[\"cpu变量\",{\"0\":{\"44\":1}}],[\"cpu变量的对比\",{\"1\":{\"40\":1}}],[\"cpu\",{\"0\":{\"39\":1},\"1\":{\"5\":2,\"10\":3,\"15\":4,\"37\":1,\"39\":9,\"44\":3,\"45\":2,\"48\":1,\"49\":3,\"76\":2,\"81\":9,\"82\":4,\"85\":1,\"112\":1}}],[\"cpp17destructible\",{\"1\":{\"108\":1}}],[\"cpp\",{\"1\":{\"1\":1,\"50\":1,\"63\":2,\"99\":2}}],[\"cc\",{\"1\":{\"0\":1}}],[\"c++23\",{\"1\":{\"92\":1}}],[\"c++20\",{\"0\":{\"19\":1,\"68\":1,\"69\":1},\"1\":{\"8\":1,\"10\":1,\"20\":1,\"23\":1,\"46\":2,\"68\":2,\"71\":1,\"72\":1,\"75\":1,\"76\":2,\"79\":2,\"83\":1,\"92\":5,\"107\":1}}],[\"c++标准库提供了很多工具\",{\"1\":{\"45\":1}}],[\"c++17\",{\"1\":{\"10\":1,\"16\":1,\"27\":2,\"30\":1,\"34\":1,\"36\":1,\"75\":3,\"97\":1,\"101\":1,\"106\":1}}],[\"c++14\",{\"1\":{\"10\":1,\"15\":1,\"34\":1,\"59\":1,\"97\":3,\"106\":3}}],[\"c++11中\",{\"1\":{\"37\":1}}],[\"c++11\",{\"1\":{\"0\":1,\"10\":1,\"12\":1,\"19\":1,\"27\":1,\"31\":1,\"33\":2,\"36\":2,\"37\":1,\"50\":1,\"66\":1,\"74\":1,\"75\":1,\"93\":1,\"97\":3,\"106\":2}}],[\"c++\",{\"1\":{\"0\":3,\"3\":2,\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"20\":1,\"21\":1,\"23\":2,\"25\":1,\"30\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":2,\"39\":1,\"44\":1,\"47\":2,\"50\":1,\"51\":3,\"57\":1,\"58\":5,\"60\":1,\"68\":2,\"70\":1,\"72\":3,\"82\":5,\"85\":2,\"92\":2,\"93\":2,\"94\":1,\"99\":1,\"100\":1,\"113\":1,\"114\":1}}],[\"站课程\",{\"1\":{\"0\":1}}],[\"broadcast\",{\"1\":{\"99\":1}}],[\"b站发布正经\",{\"1\":{\"92\":1}}],[\"binary\",{\"1\":{\"68\":6,\"72\":1}}],[\"bind\",{\"1\":{\"14\":4,\"53\":1,\"116\":1}}],[\"bind与成员指针一起使用\",{\"1\":{\"14\":1}}],[\"boost\",{\"1\":{\"114\":12,\"117\":1}}],[\"boolalpha\",{\"1\":{\"52\":2,\"55\":2}}],[\"bool\",{\"1\":{\"18\":1,\"28\":1,\"31\":3,\"47\":3,\"48\":1,\"60\":2,\"75\":1,\"76\":2,\"77\":9,\"107\":9,\"108\":2,\"109\":2}}],[\"bold\",{\"1\":{\"64\":1}}],[\"border\",{\"1\":{\"64\":2}}],[\"block\",{\"1\":{\"55\":3,\"108\":4,\"109\":1}}],[\"basically\",{\"1\":{\"76\":1}}],[\"basiclockable\",{\"1\":{\"47\":1}}],[\"barrier\",{\"1\":{\"69\":2,\"71\":17}}],[\"barclass\",{\"1\":{\"64\":1}}],[\"bar\",{\"1\":{\"63\":2,\"64\":15}}],[\"background\",{\"1\":{\"64\":2}}],[\"back\",{\"1\":{\"10\":1,\"18\":2,\"25\":3,\"26\":2,\"27\":2,\"53\":2,\"68\":1,\"70\":1,\"71\":2,\"116\":3}}],[\"before\",{\"1\":{\"108\":1}}],[\"be\",{\"1\":{\"31\":1,\"76\":1,\"108\":1}}],[\"beginthreadex\",{\"1\":{\"14\":1,\"99\":5,\"100\":3}}],[\"begin\",{\"1\":{\"10\":1,\"25\":1,\"27\":2,\"107\":3,\"109\":1}}],[\"b执行完了前面求\",{\"1\":{\"27\":1}}],[\"b执行函数\",{\"1\":{\"27\":1}}],[\"build\",{\"1\":{\"107\":1}}],[\"busy\",{\"1\":{\"47\":1}}],[\"button2\",{\"1\":{\"64\":8}}],[\"button\",{\"1\":{\"62\":4,\"64\":15}}],[\"but\",{\"1\":{\"27\":1,\"31\":1,\"102\":2,\"103\":1}}],[\"buffer\",{\"1\":{\"14\":12,\"95\":1}}],[\"by\",{\"1\":{\"0\":1,\"35\":2}}],[\"b\",{\"1\":{\"0\":1,\"27\":3,\"29\":1,\"30\":10,\"53\":8,\"74\":2,\"75\":2,\"77\":10,\"82\":6}}]],\"version\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
