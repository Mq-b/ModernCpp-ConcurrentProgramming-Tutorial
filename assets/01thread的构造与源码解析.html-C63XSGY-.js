import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as t}from"./app-DWsqdsXW.js";const n={};function h(l,i){return t(),a("div",null,[...i[0]||(i[0]=[e(`<h1 id="std-thread-的构造-源码解析" tabindex="-1"><a class="header-anchor" href="#std-thread-的构造-源码解析"><span><code>std::thread</code> 的构造-源码解析</span></a></h1><p>我们这单章是为了专门解释一下 C++11 引入的 <code>std::thread</code> 是如何构造的，是如何创建线程传递参数的，让你彻底了解这个类。</p><p>我们以 <strong>MSVC</strong> 实现的 <a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread" target="_blank" rel="noopener noreferrer"><code>std::thread</code></a> 代码进行讲解，MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 <strong>C++14</strong>，出于某些原因 <strong>C++17</strong> 的一些库（如 <a href="https://zh.cppreference.com/w/cpp/utility/functional/invoke" target="_blank" rel="noopener noreferrer"><code>invoke</code></a>， _v 变量模板）被向后移植到了 <strong>C++14</strong> 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。</p><h2 id="std-thread-的数据成员" tabindex="-1"><a class="header-anchor" href="#std-thread-的数据成员"><span><code>std::thread</code> 的数据成员</span></a></h2><ul><li><strong>了解一个庞大的类，最简单的方式就是先看它的数据成员有什么</strong>。</li></ul><p><code>std::thread</code> 只保有一个私有数据成员 <a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L163" target="_blank" rel="noopener noreferrer"><code>_Thr</code></a>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">    _Thrd_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Thr;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/__msvc_threads_core.hpp#L20-L24" target="_blank" rel="noopener noreferrer"><code>_Thrd_t</code></a> 是一个结构体，它保有两个数据成员：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Thrd_id_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Thrd_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // thread identifier for Win32</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Hnd;</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // Win32 HANDLE</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">    _Thrd_id_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Id;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构很明确，这个结构体的 <code>_Hnd</code> 成员是指向线程的句柄，<code>_Id</code> 成员就是保有线程的 ID。</p><p>在64 位操作系统，因为内存对齐，指针 8 ，无符号 int 4，这个结构体 <code>_Thrd_t</code> 就是占据 16 个字节。也就是说 <code>sizeof(std::thread)</code> 的结果应该为 <strong>16</strong>。</p><h2 id="std-thread-的构造函数" tabindex="-1"><a class="header-anchor" href="#std-thread-的构造函数"><span><code>std::thread</code> 的构造函数</span></a></h2><p><code>std::thread</code> 有四个<a href="https://zh.cppreference.com/w/cpp/thread/thread/thread" target="_blank" rel="noopener noreferrer">构造函数</a>，分别是：</p><ol><li><p>默认构造函数，构造不关联线程的新 std::thread 对象。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> : _Thr{} {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><a href="https://zh.cppreference.com/w/cpp/language/value_initialization#:~:text=%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%EF%BC%89%EF%BC%8C-,%E9%82%A3%E4%B9%88%E9%9B%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1,-%EF%BC%8C%E7%84%B6%E5%90%8E%E5%A6%82%E6%9E%9C%E5%AE%83" target="_blank" rel="noopener noreferrer">值初始化</a>了数据成员 _Thr ，这里的效果相当于给其成员 <code>_Hnd</code> 和 <code>_Id</code> 都进行<a href="https://zh.cppreference.com/w/cpp/language/zero_initialization" target="_blank" rel="noopener noreferrer">零初始化</a>。</p></li><li><p>移动构造函数，转移线程的所有权，构造 other 关联的执行线程的 <code>std::thread</code> 对象。此调用后 other 不再表示执行线程失去了线程的所有权。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(thread</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Other) </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">_Thr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">_Other</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">_Thr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, {})) {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/yvals_core.h#L1934" target="_blank" rel="noopener noreferrer">_STD</a> 是一个宏，展开就是 <code>::std::</code>，也就是 <a href="https://zh.cppreference.com/w/cpp/utility/exchange" target="_blank" rel="noopener noreferrer"><code>::std::exchange</code></a>，将 <code>_Other._Thr</code> 赋为 <code>{}</code> （也就是置空），返回 <code>_Other._Thr</code> 的旧值用以初始化当前对象的数据成员 <code>_Thr</code>。</p></li><li><p>复制构造函数被定义为弃置的，std::thread 不可复制。两个 std::thread 不可表示一个线程，std::thread 对线程资源是独占所有权。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> thread</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>构造新的 <code>std::thread</code> 对象并将它与执行线程关联。<strong>表示新的执行线程开始执行</strong>。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">enable_if_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">is_same_v</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">_Remove_cvref_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    _NODISCARD_CTOR_THREAD </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">explicit</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_Fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Fx, _Args</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... _Ax) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        _Start</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">forward</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_Fx), _STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">forward</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_Ax)...);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><hr><p>前三个构造函数都没啥要特别聊的，非常简单，只有第四个构造函数较为复杂，且是我们本章重点，需要详细讲解。（<em>注意 MSVC 使用标准库的内容很多时候不加 <strong>std::</strong>，脑补一下就行</em>）</p><p>如你所见，这个构造函数本身并没有做什么，它只是一个可变参数成员函数模板，增加了一些 <a href="https://zh.cppreference.com/w/cpp/language/sfinae" target="_blank" rel="noopener noreferrer">SFINAE</a> 进行约束我们传入的<a href="https://zh.cppreference.com/w/cpp/named_req/Callable" target="_blank" rel="noopener noreferrer">可调用</a>对象的类型不能是 <code>std::thread</code>。关于这个约束你可能有问题，因为 <code>std::thread</code> 他并没有 <code>operator()</code> 的重载，不是可调用类型，这个 <code>enable_if_t</code> 的意义是什么呢？其实很简单，如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> X</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    X</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">X</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    template</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    X</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Args</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#E36209;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">){}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    X</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> X</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">X x{ [] {} };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">X x2{ x };</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 选择到了有参构造函数，不导致编译错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这段代码可以正常的<a href="https://godbolt.org/z/6zhW6xjqP" target="_blank" rel="noopener noreferrer">通过编译</a>。这是重载决议的事情，我们知道，<code>std::thread</code> 是不可复制的，这种代码自然不应该让它通过编译，选择到我们的有参构造，所以我们添加一个约束让其不能选择到我们的有参构造：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">enable_if_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">is_same_v</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">remove_cvref_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样，这段代码就会正常的出现<a href="https://godbolt.org/z/Mc1h1GcdT" target="_blank" rel="noopener noreferrer">编译错误</a>，信息如下：</p><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>error C2280: “X::X(const X &amp;)”: 尝试引用已删除的函数</span></span>
<span class="line"><span>note: 参见“X::X”的声明</span></span>
<span class="line"><span>note: “X::X(const X &amp;)”: 已隐式删除函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就满足了我们的要求，重载决议选择到了弃置复制构造函数产生编译错误，这也就是源码中添加约束的目的。</p><p>而构造函数体中调用了一个函数 <a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L72-L87" target="_blank" rel="noopener noreferrer"><strong><code>_Start</code></strong></a>，将我们构造函数的参数全部完美转发，去调用它，这个函数才是我们的重点，如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _Start</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> _Fx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#E36209;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">_Ax</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                 =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">decay_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;, </span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">decay_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;...&gt;;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    auto</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Decay_copied           </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">make_unique</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">forward</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_Fx), _STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">forward</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_Ax)...);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    constexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Invoker_proc </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _Get_invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(make_index_sequence</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> sizeof...</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_Args)</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    _Thr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">_Hnd</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">        reinterpret_cast</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;void*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_CSTD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">_beginthreadex</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, _Invoker_proc, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">_Decay_copied</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">_Thr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">_Id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">_Thr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">_Hnd</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // ownership transferred to the thread</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">_Decay_copied</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // failed to start thread</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        _Thr</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">_Id</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        _Throw_Cpp_error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_RESOURCE_UNAVAILABLE_TRY_AGAIN);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>它也是一个可变参数成员函数模板，接受一个可调用对象 <code>_Fn</code> 和一系列参数 <code>_Args...</code> ，这些东西用来创建一个线程。</p></li><li><p><code>using _Tuple = tuple&lt;decay_t&lt;_Fn&gt;, decay_t&lt;_Args&gt;...&gt;</code></p><ul><li>定义了一个<a href="https://zh.cppreference.com/w/cpp/utility/tuple" target="_blank" rel="noopener noreferrer">元组</a>类型 <code>_Tuple</code> ，它包含了可调用对象和参数的类型，这里使用了 <a href="https://zh.cppreference.com/w/cpp/types/decay" target="_blank" rel="noopener noreferrer"><code>decay_t</code></a> 来去除了类型的引用和 cv 限定。</li></ul></li><li><p><code>auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...)</code></p><ul><li>使用 <a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique" target="_blank" rel="noopener noreferrer"><code>make_unique</code></a> 创建了一个独占指针，指向的是 <code>_Tuple</code> 类型的对象，<strong>存储了传入的函数对象和参数的副本</strong>。</li></ul></li><li><p><code>constexpr auto _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;1 + sizeof...(_Args)&gt;{})</code></p><ul><li>调用 <a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L65-L68" target="_blank" rel="noopener noreferrer"><code>_Get_invoke</code></a> 函数，传入 <code>_Tuple</code> 类型和一个参数序列的索引序列（为了遍历形参包）。这个函数用于获取一个函数指针，指向了一个静态成员函数 <a href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L55-L63" target="_blank" rel="noopener noreferrer"><code>_Invoke</code></a>，它是线程实际执行的函数。这两个函数都非常的简单，我们来看看：</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> template</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Indices</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _NODISCARD </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> constexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _Get_invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(index_sequence</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">_Indices...</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">     return</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">_Invoke</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">_Tuple, _Indices...</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> template</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Indices</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> __stdcall</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _Invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#E36209;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> _RawVals</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">noexcept</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> /* terminates */</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // adapt invoke of user&#39;s callable object to _beginthreadex&#39;s thread procedure</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">     const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> unique_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">_Tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _FnVals</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">static_cast</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">_Tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_RawVals));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">     _Tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _Tup </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">_FnVals</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // avoid ADL, handle incomplete types</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">     _STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Indices</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_Tup))...);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">     _Cnd_do_broadcast_at_thread_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // TRANSITION, ABI</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">     return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>_Get_invoke 函数很简单，就是接受一个元组类型，和形参包的索引，传递给 _Invoke 静态成员函数模板，实例化，获取它的函数指针。</p><blockquote><p>它的形参类型我们不再过多介绍，你只需要知道 <a href="https://en.cppreference.com/w/cpp/utility/integer_sequence" target="_blank" rel="noopener noreferrer"><code>index_sequence</code></a> 这个东西可以用来接收一个由 <code>make_index_sequence</code> 创建的索引形参包，帮助我们进行遍历元组即可。<a href="https://godbolt.org/z/dv88aPGac" target="_blank" rel="noopener noreferrer">示例代码</a>。</p></blockquote><p><strong>_Invoke 是重中之重，它是线程实际执行的函数</strong>，如你所见它的形参类型是 <code>void*</code> ，这是必须的，要符合 <code>_beginthreadex</code> 执行函数的类型要求。虽然是 <code>void*</code>，但是我可以将它转换为 <code>_Tuple*</code> 类型，构造一个独占智能指针，然后调用 get() 成员函数获取底层指针，解引用指针，得到元组的引用初始化<code>_Tup</code> 。</p><p>此时，我们就可以进行调用了，使用 <a href="https://zh.cppreference.com/w/cpp/utility/functional/invoke" target="_blank" rel="noopener noreferrer"><code>std::invoke</code></a> + <code>std::move</code>（默认移动） ，这里有一个形参包展开，<code>_STD get&lt;_Indices&gt;(_Tup))...</code>，_Tup 就是 std::tuple 的引用，我们使用 <code>std::get&lt;&gt;</code> 获取元组存储的数据，需要传入一个索引，这里就用到了 <code>_Indices</code>。展开之后，就等于 invoke 就接受了我们构造 std::thread 传入的可调用对象，调用可调用对象的参数，invoke 就可以执行了。</p></li><li><p><code>_Thr._Hnd = reinterpret_cast&lt;void*&gt;(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &amp;_Thr._Id))</code></p><ul><li>调用 <a href="https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170" target="_blank" rel="noopener noreferrer"><code>_beginthreadex</code></a> 函数来启动一个线程，并将线程句柄存储到 <code>_Thr._Hnd</code> 中。传递给线程的参数为 <code>_Invoker_proc</code>（一个静态函数指针，就是我们前面讲的 <strong>_Invoke</strong>）和 <code>_Decay_copied.get()</code>（存储了函数对象和参数的副本的指针）。</li></ul></li><li><p><code>if (_Thr._Hnd) {</code></p><ul><li>如果线程句柄 <code>_Thr._Hnd</code> 不为空，则表示线程已成功启动，将独占指针的所有权转移给线程。</li></ul></li><li><p><code>(void) _Decay_copied.release()</code></p><ul><li>释放独占指针的所有权，因为已经将参数传递给了线程。</li></ul></li><li><p><code>} else { // failed to start thread</code></p><ul><li>如果线程启动失败，则进入这个分支</li></ul></li><li><p><code>_Thr._Id = 0;</code></p><ul><li>将线程ID设置为0。</li></ul></li><li><p><code>_Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);</code></p><ul><li>抛出一个 C++ 错误，表示资源不可用，请再次尝试。</li></ul></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>需要注意，libstdc++ 和 libc++ 可能不同，就比如它们 64 位环境下 <code>sizeof(std::thread)</code> 的结果就可能是 <strong>8</strong>。libstdc++ 的实现只<a href="https://github.com/gcc-mirror/gcc/blob/3e3d115c946944c81d8231dfbe778d4dae26cbb7/libstdc%2B%2B-v3/include/bits/std_thread.h#L123" target="_blank" rel="noopener noreferrer">保有一个 <code>std::thread::id</code></a>。<a href="https://github.com/gcc-mirror/gcc/blob/3e3d115c946944c81d8231dfbe778d4dae26cbb7/libstdc%2B%2B-v3/include/bits/std_thread.h#L81-L85" target="_blank" rel="noopener noreferrer">参见</a>。不过实测 gcc 不管是 <code>win32</code> 还是 <code>POSIX</code> 线程模型，线程对象的大小都是 8，宏 <code>_GLIBCXX_HAS_GTHREADS</code> 的值都为 1（<a href="https://docs.gtk.org/glib/struct.Thread.html" target="_blank" rel="noopener noreferrer">GThread</a>）。</p><blockquote><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> thread</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _GLIBCXX_HAS_GTHREADS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> native_handle_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;"> __gthread_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> native_handle_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>__gthread_t</code> 即 <code>void*</code>。</p></blockquote><p>我们这里的源码解析涉及到的 C++ 技术很多，我们也没办法每一个都单独讲，那会显得文章很冗长，而且也不是重点。</p><p>相信你也感受到了，<strong>不会模板，你阅读标准库源码，是无稽之谈</strong>，市面上很多教程教学，教导一些实现容器，过度简化了，真要去出错了去看标准库的代码，那是不现实的。不需要模板的水平有多高，也不需要会什么元编程，但是基本的需求得能做到，得会，这里推荐一下：<a href="https://github.com/Mq-b/Modern-Cpp-templates-tutorial" target="_blank" rel="noopener noreferrer"><strong>现代C++模板教程</strong></a>。</p><hr><p>学习完了也不要忘记了回答最初的问题：</p><ol><li><p><strong>如何做到的默认按值复制？</strong></p><p><code>_Start</code> 的第一行代码展示了这一点。我们将传入的所有参数包装成一个元组类型，这些类型先经过 <code>decay_t</code> 处理，去除了引用与 cv 限定，自然就实现了默认复制。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> _Tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                 =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">decay_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;, </span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">decay_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;...&gt;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>为什么需要 <code>std::ref</code> ？</strong></p><p>实现中将类型先经过 <code>decay</code> 处理，如果要传递引用，则必须用类包装一下才行，使用 <code>std::ref</code> 函数就会返回一个包装对象。</p></li><li><p><strong>如何支持只能移动的对象？</strong></p><p>参数通过完美转发，最终调用时使用 <code>std::move</code>，这在线程实际执行的函数 <code>_Invoke</code> 中体现出来：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_STD</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_STD</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> move</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_STD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">_Indices</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(_Tup))...);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>如何做到接受任意<a href="https://zh.cppreference.com/w/cpp/named_req/Callable" target="_blank" rel="noopener noreferrer">可调用</a>对象？</p><p>源码的实现很简单，主要是通过两层包装，最终将 <code>void*</code> 指针转换到原类型，然后使用 <code>std::invoke</code> 进行调用。</p></li><li><p><strong>如何创建的线程？</strong></p><p>MSVC STL 调用 Win32 API <code>_beginthreadex</code> 创建线程；libstdc++ 调用 <code>__gthread_create</code> 函数创建线程，在 Windows 上实际上就是调用 <code>CreateThread</code>。<br><code>_beginthreadex</code> 和 <code>CreateThread</code> 都是微软提供的用于创建线程的 C 风格接口，它们的主要区别在于前者依赖于 C 运行时库，而后者更适合纯 Windows API 的情况。使用 <code>_beginthreadex</code> 可以确保正确初始化和清理 C 运行时库资源，而 <code>CreateThread</code> 则适用于不依赖于 C 运行时库的环境。</p></li><li><p><strong>传递参数一节中的：“<em><code>std::thread</code> 内部会将保有的参数副本转换为右值表达式进行传递</em>”到底是如何做到的？</strong></p><p>这就是第三个问题，差不多，无非是最后调用 <code>std::invoke</code> 函数之前，先 <code>std::move</code> 了。</p></li></ol>`,34)])])}const r=s(n,[["render",h],["__file","01thread的构造与源码解析.html.vue"]]),d=JSON.parse('{"path":"/md/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/01thread%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html","title":"std::thread 的构造-源码解析","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"std::thread 的数据成员","slug":"std-thread-的数据成员","link":"#std-thread-的数据成员","children":[]},{"level":2,"title":"std::thread 的构造函数","slug":"std-thread-的构造函数","link":"#std-thread-的构造函数","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1710214174000,"updatedTime":1726228933000,"contributors":[{"name":"归故里","email":"3326284481@qq.com","commits":8},{"name":"mq白","email":"3326284481@qq.com","commits":3},{"name":"A. Jiang","email":"de34@live.cn","commits":2}]},"readingTime":{"minutes":9.63,"words":2888},"filePathRelative":"md/详细分析/01thread的构造与源码解析.md","localizedDate":"2024年3月12日","excerpt":"\\n<p>我们这单章是为了专门解释一下 C++11 引入的 <code>std::thread</code> 是如何构造的，是如何创建线程传递参数的，让你彻底了解这个类。</p>\\n<p>我们以 <strong>MSVC</strong> 实现的 <a href=\\"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>std::thread</code></a> 代码进行讲解，MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 <strong>C++14</strong>，出于某些原因 <strong>C++17</strong> 的一些库（如 <a href=\\"https://zh.cppreference.com/w/cpp/utility/functional/invoke\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>invoke</code></a>， _v 变量模板）被向后移植到了 <strong>C++14</strong> 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。</p>"}');export{r as comp,d as data};
